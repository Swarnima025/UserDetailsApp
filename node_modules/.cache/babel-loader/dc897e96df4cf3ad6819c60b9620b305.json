{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;\n\nconst code_1 = require(\"./code\");\n\nclass ValueError extends Error {\n  constructor(name) {\n    super(`CodeGen: \"code\" for ${name} not defined`);\n    this.value = name.value;\n  }\n\n}\n\nvar UsedValueState;\n\n(function (UsedValueState) {\n  UsedValueState[UsedValueState[\"Started\"] = 0] = \"Started\";\n  UsedValueState[UsedValueState[\"Completed\"] = 1] = \"Completed\";\n})(UsedValueState = exports.UsedValueState || (exports.UsedValueState = {}));\n\nexports.varKinds = {\n  const: new code_1.Name(\"const\"),\n  let: new code_1.Name(\"let\"),\n  var: new code_1.Name(\"var\")\n};\n\nclass Scope {\n  constructor() {\n    let {\n      prefixes,\n      parent\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this._names = {};\n    this._prefixes = prefixes;\n    this._parent = parent;\n  }\n\n  toName(nameOrPrefix) {\n    return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);\n  }\n\n  name(prefix) {\n    return new code_1.Name(this._newName(prefix));\n  }\n\n  _newName(prefix) {\n    const ng = this._names[prefix] || this._nameGroup(prefix);\n\n    return `${prefix}${ng.index++}`;\n  }\n\n  _nameGroup(prefix) {\n    var _a, _b;\n\n    if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {\n      throw new Error(`CodeGen: prefix \"${prefix}\" is not allowed in this scope`);\n    }\n\n    return this._names[prefix] = {\n      prefix,\n      index: 0\n    };\n  }\n\n}\n\nexports.Scope = Scope;\n\nclass ValueScopeName extends code_1.Name {\n  constructor(prefix, nameStr) {\n    super(nameStr);\n    this.prefix = prefix;\n  }\n\n  setValue(value, _ref) {\n    let {\n      property,\n      itemIndex\n    } = _ref;\n    this.value = value;\n    this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;\n  }\n\n}\n\nexports.ValueScopeName = ValueScopeName;\nconst line = (0, code_1._)`\\n`;\n\nclass ValueScope extends Scope {\n  constructor(opts) {\n    super(opts);\n    this._values = {};\n    this._scope = opts.scope;\n    this.opts = { ...opts,\n      _n: opts.lines ? line : code_1.nil\n    };\n  }\n\n  get() {\n    return this._scope;\n  }\n\n  name(prefix) {\n    return new ValueScopeName(prefix, this._newName(prefix));\n  }\n\n  value(nameOrPrefix, value) {\n    var _a;\n\n    if (value.ref === undefined) throw new Error(\"CodeGen: ref must be passed in value\");\n    const name = this.toName(nameOrPrefix);\n    const {\n      prefix\n    } = name;\n    const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;\n    let vs = this._values[prefix];\n\n    if (vs) {\n      const _name = vs.get(valueKey);\n\n      if (_name) return _name;\n    } else {\n      vs = this._values[prefix] = new Map();\n    }\n\n    vs.set(valueKey, name);\n    const s = this._scope[prefix] || (this._scope[prefix] = []);\n    const itemIndex = s.length;\n    s[itemIndex] = value.ref;\n    name.setValue(value, {\n      property: prefix,\n      itemIndex\n    });\n    return name;\n  }\n\n  getValue(prefix, keyOrRef) {\n    const vs = this._values[prefix];\n    if (!vs) return;\n    return vs.get(keyOrRef);\n  }\n\n  scopeRefs(scopeName) {\n    let values = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._values;\n    return this._reduceValues(values, name => {\n      if (name.scopePath === undefined) throw new Error(`CodeGen: name \"${name}\" has no value`);\n      return (0, code_1._)`${scopeName}${name.scopePath}`;\n    });\n  }\n\n  scopeCode() {\n    let values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._values;\n    let usedValues = arguments.length > 1 ? arguments[1] : undefined;\n    let getCode = arguments.length > 2 ? arguments[2] : undefined;\n    return this._reduceValues(values, name => {\n      if (name.value === undefined) throw new Error(`CodeGen: name \"${name}\" has no value`);\n      return name.value.code;\n    }, usedValues, getCode);\n  }\n\n  _reduceValues(values, valueCode) {\n    let usedValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let getCode = arguments.length > 3 ? arguments[3] : undefined;\n    let code = code_1.nil;\n\n    for (const prefix in values) {\n      const vs = values[prefix];\n      if (!vs) continue;\n      const nameSet = usedValues[prefix] = usedValues[prefix] || new Map();\n      vs.forEach(name => {\n        if (nameSet.has(name)) return;\n        nameSet.set(name, UsedValueState.Started);\n        let c = valueCode(name);\n\n        if (c) {\n          const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;\n          code = (0, code_1._)`${code}${def} ${name} = ${c};${this.opts._n}`;\n        } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {\n          code = (0, code_1._)`${code}${c}${this.opts._n}`;\n        } else {\n          throw new ValueError(name);\n        }\n\n        nameSet.set(name, UsedValueState.Completed);\n      });\n    }\n\n    return code;\n  }\n\n}\n\nexports.ValueScope = ValueScope;","map":{"version":3,"sources":["../../../lib/compile/codegen/scope.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,MAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;AAeA,MAAM,UAAN,SAAyB,KAAzB,CAA8B;AAE5B,EAAA,WAAA,CAAY,IAAZ,EAAgC;AAC9B,UAAM,uBAAuB,IAAI,cAAjC;AACA,SAAK,KAAL,GAAa,IAAI,CAAC,KAAlB;AACD;;AAL2B;;AA6B9B,IAAY,cAAZ;;AAAA,CAAA,UAAY,cAAZ,EAA0B;AACxB,EAAA,cAAA,CAAA,cAAA,CAAA,SAAA,CAAA,GAAA,CAAA,CAAA,GAAA,SAAA;AACA,EAAA,cAAA,CAAA,cAAA,CAAA,WAAA,CAAA,GAAA,CAAA,CAAA,GAAA,WAAA;AACD,CAHD,EAAY,cAAc,GAAd,OAAA,CAAA,cAAA,KAAA,OAAA,CAAA,cAAA,GAAc,EAAd,CAAZ;;AASa,OAAA,CAAA,QAAA,GAAW;AACtB,EAAA,KAAK,EAAE,IAAI,MAAA,CAAA,IAAJ,CAAS,OAAT,CADe;AAEtB,EAAA,GAAG,EAAE,IAAI,MAAA,CAAA,IAAJ,CAAS,KAAT,CAFiB;AAGtB,EAAA,GAAG,EAAE,IAAI,MAAA,CAAA,IAAJ,CAAS,KAAT;AAHiB,CAAX;;AAMb,MAAa,KAAb,CAAkB;AAKhB,EAAA,WAAA,GAAiD;AAAA,QAArC;AAAC,MAAA,QAAD;AAAW,MAAA;AAAX,KAAqC,uEAAF,EAAE;AAJ9B,SAAA,MAAA,GAA2C,EAA3C;AAKjB,SAAK,SAAL,GAAiB,QAAjB;AACA,SAAK,OAAL,GAAe,MAAf;AACD;;AAED,EAAA,MAAM,CAAC,YAAD,EAA4B;AAChC,WAAO,YAAY,YAAY,MAAA,CAAA,IAAxB,GAA+B,YAA/B,GAA8C,KAAK,IAAL,CAAU,YAAV,CAArD;AACD;;AAED,EAAA,IAAI,CAAC,MAAD,EAAe;AACjB,WAAO,IAAI,MAAA,CAAA,IAAJ,CAAS,KAAK,QAAL,CAAc,MAAd,CAAT,CAAP;AACD;;AAES,EAAA,QAAQ,CAAC,MAAD,EAAe;AAC/B,UAAM,EAAE,GAAG,KAAK,MAAL,CAAY,MAAZ,KAAuB,KAAK,UAAL,CAAgB,MAAhB,CAAlC;;AACA,WAAO,GAAG,MAAM,GAAG,EAAE,CAAC,KAAH,EAAU,EAA7B;AACD;;AAEO,EAAA,UAAU,CAAC,MAAD,EAAe;;;AAC/B,QAAI,CAAA,CAAA,EAAA,GAAA,CAAA,EAAA,GAAA,KAAK,OAAL,MAAY,IAAZ,IAAY,EAAA,KAAA,KAAA,CAAZ,GAAY,KAAA,CAAZ,GAAY,EAAA,CAAE,SAAd,MAAuB,IAAvB,IAAuB,EAAA,KAAA,KAAA,CAAvB,GAAuB,KAAA,CAAvB,GAAuB,EAAA,CAAE,GAAF,CAAM,MAAN,CAAvB,KAAyC,KAAK,SAAL,IAAkB,CAAC,KAAK,SAAL,CAAe,GAAf,CAAmB,MAAnB,CAAhE,EAA6F;AAC3F,YAAM,IAAI,KAAJ,CAAU,oBAAoB,MAAM,gCAApC,CAAN;AACD;;AACD,WAAQ,KAAK,MAAL,CAAY,MAAZ,IAAsB;AAAC,MAAA,MAAD;AAAS,MAAA,KAAK,EAAE;AAAhB,KAA9B;AACD;;AA5Be;;AAAlB,OAAA,CAAA,KAAA,GAAA,KAAA;;AAoCA,MAAa,cAAb,SAAoC,MAAA,CAAA,IAApC,CAAwC;AAKtC,EAAA,WAAA,CAAY,MAAZ,EAA4B,OAA5B,EAA2C;AACzC,UAAM,OAAN;AACA,SAAK,MAAL,GAAc,MAAd;AACD;;AAED,EAAA,QAAQ,CAAC,KAAD,QAAmD;AAAA,QAAhC;AAAC,MAAA,QAAD;AAAW,MAAA;AAAX,KAAgC;AACzD,SAAK,KAAL,GAAa,KAAb;AACA,SAAK,SAAL,GAAiB,CAAA,GAAA,MAAA,CAAA,CAAA,CAAC,IAAI,IAAI,MAAA,CAAA,IAAJ,CAAS,QAAT,CAAkB,IAAI,SAAS,GAArD;AACD;;AAbqC;;AAAxC,OAAA,CAAA,cAAA,GAAA,cAAA;AAoBA,MAAM,IAAI,GAAG,CAAA,GAAA,MAAA,CAAA,CAAA,CAAC,IAAd;;AAEA,MAAa,UAAb,SAAgC,KAAhC,CAAqC;AAKnC,EAAA,WAAA,CAAY,IAAZ,EAAmC;AACjC,UAAM,IAAN;AALiB,SAAA,OAAA,GAAuB,EAAvB;AAMjB,SAAK,MAAL,GAAc,IAAI,CAAC,KAAnB;AACA,SAAK,IAAL,GAAY,EAAC,GAAG,IAAJ;AAAU,MAAA,EAAE,EAAE,IAAI,CAAC,KAAL,GAAa,IAAb,GAAoB,MAAA,CAAA;AAAlC,KAAZ;AACD;;AAED,EAAA,GAAG,GAAA;AACD,WAAO,KAAK,MAAZ;AACD;;AAED,EAAA,IAAI,CAAC,MAAD,EAAe;AACjB,WAAO,IAAI,cAAJ,CAAmB,MAAnB,EAA2B,KAAK,QAAL,CAAc,MAAd,CAA3B,CAAP;AACD;;AAED,EAAA,KAAK,CAAC,YAAD,EAAwC,KAAxC,EAAwD;;;AAC3D,QAAI,KAAK,CAAC,GAAN,KAAc,SAAlB,EAA6B,MAAM,IAAI,KAAJ,CAAU,sCAAV,CAAN;AAC7B,UAAM,IAAI,GAAG,KAAK,MAAL,CAAY,YAAZ,CAAb;AACA,UAAM;AAAC,MAAA;AAAD,QAAW,IAAjB;AACA,UAAM,QAAQ,GAAG,CAAA,EAAA,GAAA,KAAK,CAAC,GAAN,MAAS,IAAT,IAAS,EAAA,KAAA,KAAA,CAAT,GAAS,EAAT,GAAa,KAAK,CAAC,GAApC;AACA,QAAI,EAAE,GAAG,KAAK,OAAL,CAAa,MAAb,CAAT;;AACA,QAAI,EAAJ,EAAQ;AACN,YAAM,KAAK,GAAG,EAAE,CAAC,GAAH,CAAO,QAAP,CAAd;;AACA,UAAI,KAAJ,EAAW,OAAO,KAAP;AACZ,KAHD,MAGO;AACL,MAAA,EAAE,GAAG,KAAK,OAAL,CAAa,MAAb,IAAuB,IAAI,GAAJ,EAA5B;AACD;;AACD,IAAA,EAAE,CAAC,GAAH,CAAO,QAAP,EAAiB,IAAjB;AAEA,UAAM,CAAC,GAAG,KAAK,MAAL,CAAY,MAAZ,MAAwB,KAAK,MAAL,CAAY,MAAZ,IAAsB,EAA9C,CAAV;AACA,UAAM,SAAS,GAAG,CAAC,CAAC,MAApB;AACA,IAAA,CAAC,CAAC,SAAD,CAAD,GAAe,KAAK,CAAC,GAArB;AACA,IAAA,IAAI,CAAC,QAAL,CAAc,KAAd,EAAqB;AAAC,MAAA,QAAQ,EAAE,MAAX;AAAmB,MAAA;AAAnB,KAArB;AACA,WAAO,IAAP;AACD;;AAED,EAAA,QAAQ,CAAC,MAAD,EAAiB,QAAjB,EAAkC;AACxC,UAAM,EAAE,GAAG,KAAK,OAAL,CAAa,MAAb,CAAX;AACA,QAAI,CAAC,EAAL,EAAS;AACT,WAAO,EAAE,CAAC,GAAH,CAAO,QAAP,CAAP;AACD;;AAED,EAAA,SAAS,CAAC,SAAD,EAAqE;AAAA,QAAnD,MAAmD,uEAAZ,KAAK,OAAO;AAC5E,WAAO,KAAK,aAAL,CAAmB,MAAnB,EAA4B,IAAD,IAAyB;AACzD,UAAI,IAAI,CAAC,SAAL,KAAmB,SAAvB,EAAkC,MAAM,IAAI,KAAJ,CAAU,kBAAkB,IAAI,gBAAhC,CAAN;AAClC,aAAO,CAAA,GAAA,MAAA,CAAA,CAAA,CAAC,GAAG,SAAS,GAAG,IAAI,CAAC,SAAS,EAArC;AACD,KAHM,CAAP;AAID;;AAED,EAAA,SAAS,GAG0C;AAAA,QAFjD,MAEiD,uEAFV,KAAK,OAEK;AAAA,QADjD,UACiD;AAAA,QAAjD,OAAiD;AAEjD,WAAO,KAAK,aAAL,CACL,MADK,EAEJ,IAAD,IAAyB;AACvB,UAAI,IAAI,CAAC,KAAL,KAAe,SAAnB,EAA8B,MAAM,IAAI,KAAJ,CAAU,kBAAkB,IAAI,gBAAhC,CAAN;AAC9B,aAAO,IAAI,CAAC,KAAL,CAAW,IAAlB;AACD,KALI,EAML,UANK,EAOL,OAPK,CAAP;AASD;;AAEO,EAAA,aAAa,CACnB,MADmB,EAEnB,SAFmB,EAI8B;AAAA,QADjD,UACiD,uEADnB,EACmB;AAAA,QAAjD,OAAiD;AAEjD,QAAI,IAAI,GAAS,MAAA,CAAA,GAAjB;;AACA,SAAK,MAAM,MAAX,IAAqB,MAArB,EAA6B;AAC3B,YAAM,EAAE,GAAG,MAAM,CAAC,MAAD,CAAjB;AACA,UAAI,CAAC,EAAL,EAAS;AACT,YAAM,OAAO,GAAI,UAAU,CAAC,MAAD,CAAV,GAAqB,UAAU,CAAC,MAAD,CAAV,IAAsB,IAAI,GAAJ,EAA5D;AACA,MAAA,EAAE,CAAC,OAAH,CAAY,IAAD,IAAyB;AAClC,YAAI,OAAO,CAAC,GAAR,CAAY,IAAZ,CAAJ,EAAuB;AACvB,QAAA,OAAO,CAAC,GAAR,CAAY,IAAZ,EAAkB,cAAc,CAAC,OAAjC;AACA,YAAI,CAAC,GAAG,SAAS,CAAC,IAAD,CAAjB;;AACA,YAAI,CAAJ,EAAO;AACL,gBAAM,GAAG,GAAG,KAAK,IAAL,CAAU,GAAV,GAAgB,OAAA,CAAA,QAAA,CAAS,GAAzB,GAA+B,OAAA,CAAA,QAAA,CAAS,KAApD;AACA,UAAA,IAAI,GAAG,CAAA,GAAA,MAAA,CAAA,CAAA,CAAC,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,MAAM,CAAC,IAAI,KAAK,IAAL,CAAU,EAAE,EAApD;AACD,SAHD,MAGO,IAAK,CAAC,GAAG,OAAO,KAAA,IAAP,IAAA,OAAO,KAAA,KAAA,CAAP,GAAO,KAAA,CAAP,GAAA,OAAO,CAAG,IAAH,CAAhB,EAA2B;AAChC,UAAA,IAAI,GAAG,CAAA,GAAA,MAAA,CAAA,CAAA,CAAC,GAAG,IAAI,GAAG,CAAC,GAAG,KAAK,IAAL,CAAU,EAAE,EAAlC;AACD,SAFM,MAEA;AACL,gBAAM,IAAI,UAAJ,CAAe,IAAf,CAAN;AACD;;AACD,QAAA,OAAO,CAAC,GAAR,CAAY,IAAZ,EAAkB,cAAc,CAAC,SAAjC;AACD,OAbD;AAcD;;AACD,WAAO,IAAP;AACD;;AAhGkC;;AAArC,OAAA,CAAA,UAAA,GAAA,UAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;\nconst code_1 = require(\"./code\");\nclass ValueError extends Error {\n    constructor(name) {\n        super(`CodeGen: \"code\" for ${name} not defined`);\n        this.value = name.value;\n    }\n}\nvar UsedValueState;\n(function (UsedValueState) {\n    UsedValueState[UsedValueState[\"Started\"] = 0] = \"Started\";\n    UsedValueState[UsedValueState[\"Completed\"] = 1] = \"Completed\";\n})(UsedValueState = exports.UsedValueState || (exports.UsedValueState = {}));\nexports.varKinds = {\n    const: new code_1.Name(\"const\"),\n    let: new code_1.Name(\"let\"),\n    var: new code_1.Name(\"var\"),\n};\nclass Scope {\n    constructor({ prefixes, parent } = {}) {\n        this._names = {};\n        this._prefixes = prefixes;\n        this._parent = parent;\n    }\n    toName(nameOrPrefix) {\n        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);\n    }\n    name(prefix) {\n        return new code_1.Name(this._newName(prefix));\n    }\n    _newName(prefix) {\n        const ng = this._names[prefix] || this._nameGroup(prefix);\n        return `${prefix}${ng.index++}`;\n    }\n    _nameGroup(prefix) {\n        var _a, _b;\n        if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || (this._prefixes && !this._prefixes.has(prefix))) {\n            throw new Error(`CodeGen: prefix \"${prefix}\" is not allowed in this scope`);\n        }\n        return (this._names[prefix] = { prefix, index: 0 });\n    }\n}\nexports.Scope = Scope;\nclass ValueScopeName extends code_1.Name {\n    constructor(prefix, nameStr) {\n        super(nameStr);\n        this.prefix = prefix;\n    }\n    setValue(value, { property, itemIndex }) {\n        this.value = value;\n        this.scopePath = (0, code_1._) `.${new code_1.Name(property)}[${itemIndex}]`;\n    }\n}\nexports.ValueScopeName = ValueScopeName;\nconst line = (0, code_1._) `\\n`;\nclass ValueScope extends Scope {\n    constructor(opts) {\n        super(opts);\n        this._values = {};\n        this._scope = opts.scope;\n        this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };\n    }\n    get() {\n        return this._scope;\n    }\n    name(prefix) {\n        return new ValueScopeName(prefix, this._newName(prefix));\n    }\n    value(nameOrPrefix, value) {\n        var _a;\n        if (value.ref === undefined)\n            throw new Error(\"CodeGen: ref must be passed in value\");\n        const name = this.toName(nameOrPrefix);\n        const { prefix } = name;\n        const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;\n        let vs = this._values[prefix];\n        if (vs) {\n            const _name = vs.get(valueKey);\n            if (_name)\n                return _name;\n        }\n        else {\n            vs = this._values[prefix] = new Map();\n        }\n        vs.set(valueKey, name);\n        const s = this._scope[prefix] || (this._scope[prefix] = []);\n        const itemIndex = s.length;\n        s[itemIndex] = value.ref;\n        name.setValue(value, { property: prefix, itemIndex });\n        return name;\n    }\n    getValue(prefix, keyOrRef) {\n        const vs = this._values[prefix];\n        if (!vs)\n            return;\n        return vs.get(keyOrRef);\n    }\n    scopeRefs(scopeName, values = this._values) {\n        return this._reduceValues(values, (name) => {\n            if (name.scopePath === undefined)\n                throw new Error(`CodeGen: name \"${name}\" has no value`);\n            return (0, code_1._) `${scopeName}${name.scopePath}`;\n        });\n    }\n    scopeCode(values = this._values, usedValues, getCode) {\n        return this._reduceValues(values, (name) => {\n            if (name.value === undefined)\n                throw new Error(`CodeGen: name \"${name}\" has no value`);\n            return name.value.code;\n        }, usedValues, getCode);\n    }\n    _reduceValues(values, valueCode, usedValues = {}, getCode) {\n        let code = code_1.nil;\n        for (const prefix in values) {\n            const vs = values[prefix];\n            if (!vs)\n                continue;\n            const nameSet = (usedValues[prefix] = usedValues[prefix] || new Map());\n            vs.forEach((name) => {\n                if (nameSet.has(name))\n                    return;\n                nameSet.set(name, UsedValueState.Started);\n                let c = valueCode(name);\n                if (c) {\n                    const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;\n                    code = (0, code_1._) `${code}${def} ${name} = ${c};${this.opts._n}`;\n                }\n                else if ((c = getCode === null || getCode === void 0 ? void 0 : getCode(name))) {\n                    code = (0, code_1._) `${code}${c}${this.opts._n}`;\n                }\n                else {\n                    throw new ValueError(name);\n                }\n                nameSet.set(name, UsedValueState.Completed);\n            });\n        }\n        return code;\n    }\n}\nexports.ValueScope = ValueScope;\n//# sourceMappingURL=scope.js.map"]},"metadata":{},"sourceType":"script"}