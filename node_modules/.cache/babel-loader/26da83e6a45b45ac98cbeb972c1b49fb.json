{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst codegen_1 = require(\"../../compile/codegen\");\n\nconst util_1 = require(\"../../compile/util\");\n\nconst equal_1 = require(\"../../runtime/equal\");\n\nconst error = {\n  message: \"must be equal to one of the allowed values\",\n  params: _ref => {\n    let {\n      schemaCode\n    } = _ref;\n    return (0, codegen_1._)`{allowedValues: ${schemaCode}}`;\n  }\n};\nconst def = {\n  keyword: \"enum\",\n  schemaType: \"array\",\n  $data: true,\n  error,\n\n  code(cxt) {\n    const {\n      gen,\n      data,\n      $data,\n      schema,\n      schemaCode,\n      it\n    } = cxt;\n    if (!$data && schema.length === 0) throw new Error(\"enum must have non-empty array\");\n    const useLoop = schema.length >= it.opts.loopEnum;\n    let eql;\n\n    const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1.useFunc)(gen, equal_1.default);\n\n    let valid;\n\n    if (useLoop || $data) {\n      valid = gen.let(\"valid\");\n      cxt.block$data(valid, loopEnum);\n    } else {\n      /* istanbul ignore if */\n      if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\");\n      const vSchema = gen.const(\"vSchema\", schemaCode);\n      valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));\n    }\n\n    cxt.pass(valid);\n\n    function loopEnum() {\n      gen.assign(valid, false);\n      gen.forOf(\"v\", schemaCode, v => gen.if((0, codegen_1._)`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));\n    }\n\n    function equalCode(vSchema, i) {\n      const sch = schema[i];\n      return typeof sch === \"object\" && sch !== null ? (0, codegen_1._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1._)`${data} === ${sch}`;\n    }\n  }\n\n};\nexports.default = def;","map":{"version":3,"sources":["../../../lib/vocabularies/validation/enum.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst equal_1 = require(\"../../runtime/equal\");\nconst error = {\n    message: \"must be equal to one of the allowed values\",\n    params: ({ schemaCode }) => (0, codegen_1._) `{allowedValues: ${schemaCode}}`,\n};\nconst def = {\n    keyword: \"enum\",\n    schemaType: \"array\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, $data, schema, schemaCode, it } = cxt;\n        if (!$data && schema.length === 0)\n            throw new Error(\"enum must have non-empty array\");\n        const useLoop = schema.length >= it.opts.loopEnum;\n        let eql;\n        const getEql = () => (eql !== null && eql !== void 0 ? eql : (eql = (0, util_1.useFunc)(gen, equal_1.default)));\n        let valid;\n        if (useLoop || $data) {\n            valid = gen.let(\"valid\");\n            cxt.block$data(valid, loopEnum);\n        }\n        else {\n            /* istanbul ignore if */\n            if (!Array.isArray(schema))\n                throw new Error(\"ajv implementation error\");\n            const vSchema = gen.const(\"vSchema\", schemaCode);\n            valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));\n        }\n        cxt.pass(valid);\n        function loopEnum() {\n            gen.assign(valid, false);\n            gen.forOf(\"v\", schemaCode, (v) => gen.if((0, codegen_1._) `${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));\n        }\n        function equalCode(vSchema, i) {\n            const sch = schema[i];\n            return typeof sch === \"object\" && sch !== null\n                ? (0, codegen_1._) `${getEql()}(${data}, ${vSchema}[${i}])`\n                : (0, codegen_1._) `${data} === ${sch}`;\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=enum.js.map"]},"metadata":{},"sourceType":"script"}