{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.boolOrEmptySchema = exports.topBoolOrEmptySchema = void 0;\n\nconst errors_1 = require(\"../errors\");\n\nconst codegen_1 = require(\"../codegen\");\n\nconst names_1 = require(\"../names\");\n\nconst boolError = {\n  message: \"boolean schema is false\"\n};\n\nfunction topBoolOrEmptySchema(it) {\n  const {\n    gen,\n    schema,\n    validateName\n  } = it;\n\n  if (schema === false) {\n    falseSchemaError(it, false);\n  } else if (typeof schema == \"object\" && schema.$async === true) {\n    gen.return(names_1.default.data);\n  } else {\n    gen.assign((0, codegen_1._)`${validateName}.errors`, null);\n    gen.return(true);\n  }\n}\n\nexports.topBoolOrEmptySchema = topBoolOrEmptySchema;\n\nfunction boolOrEmptySchema(it, valid) {\n  const {\n    gen,\n    schema\n  } = it;\n\n  if (schema === false) {\n    gen.var(valid, false); // TODO var\n\n    falseSchemaError(it);\n  } else {\n    gen.var(valid, true); // TODO var\n  }\n}\n\nexports.boolOrEmptySchema = boolOrEmptySchema;\n\nfunction falseSchemaError(it, overrideAllErrors) {\n  const {\n    gen,\n    data\n  } = it; // TODO maybe some other interface should be used for non-keyword validation errors...\n\n  const cxt = {\n    gen,\n    keyword: \"false schema\",\n    data,\n    schema: false,\n    schemaCode: false,\n    schemaValue: false,\n    params: {},\n    it\n  };\n  (0, errors_1.reportError)(cxt, boolError, undefined, overrideAllErrors);\n}","map":{"version":3,"sources":["../../../lib/compile/validate/boolSchema.ts"],"names":[],"mappings":";;;;;;;AAEA,MAAA,QAAA,GAAA,OAAA,CAAA,WAAA,CAAA;;AACA,MAAA,SAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;AACA,MAAA,OAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AAEA,MAAM,SAAS,GAA2B;AACxC,EAAA,OAAO,EAAE;AAD+B,CAA1C;;AAIA,SAAgB,oBAAhB,CAAqC,EAArC,EAAkD;AAChD,QAAM;AAAC,IAAA,GAAD;AAAM,IAAA,MAAN;AAAc,IAAA;AAAd,MAA8B,EAApC;;AACA,MAAI,MAAM,KAAK,KAAf,EAAsB;AACpB,IAAA,gBAAgB,CAAC,EAAD,EAAK,KAAL,CAAhB;AACD,GAFD,MAEO,IAAI,OAAO,MAAP,IAAiB,QAAjB,IAA6B,MAAM,CAAC,MAAP,KAAkB,IAAnD,EAAyD;AAC9D,IAAA,GAAG,CAAC,MAAJ,CAAW,OAAA,CAAA,OAAA,CAAE,IAAb;AACD,GAFM,MAEA;AACL,IAAA,GAAG,CAAC,MAAJ,CAAW,CAAA,GAAA,SAAA,CAAA,CAAA,CAAC,GAAG,YAAY,SAA3B,EAAsC,IAAtC;AACA,IAAA,GAAG,CAAC,MAAJ,CAAW,IAAX;AACD;AACF;;AAVD,OAAA,CAAA,oBAAA,GAAA,oBAAA;;AAYA,SAAgB,iBAAhB,CAAkC,EAAlC,EAAiD,KAAjD,EAA4D;AAC1D,QAAM;AAAC,IAAA,GAAD;AAAM,IAAA;AAAN,MAAgB,EAAtB;;AACA,MAAI,MAAM,KAAK,KAAf,EAAsB;AACpB,IAAA,GAAG,CAAC,GAAJ,CAAQ,KAAR,EAAe,KAAf,EADoB,CACE;;AACtB,IAAA,gBAAgB,CAAC,EAAD,CAAhB;AACD,GAHD,MAGO;AACL,IAAA,GAAG,CAAC,GAAJ,CAAQ,KAAR,EAAe,IAAf,EADK,CACgB;AACtB;AACF;;AARD,OAAA,CAAA,iBAAA,GAAA,iBAAA;;AAUA,SAAS,gBAAT,CAA0B,EAA1B,EAAyC,iBAAzC,EAAoE;AAClE,QAAM;AAAC,IAAA,GAAD;AAAM,IAAA;AAAN,MAAc,EAApB,CADkE,CAElE;;AACA,QAAM,GAAG,GAAoB;AAC3B,IAAA,GAD2B;AAE3B,IAAA,OAAO,EAAE,cAFkB;AAG3B,IAAA,IAH2B;AAI3B,IAAA,MAAM,EAAE,KAJmB;AAK3B,IAAA,UAAU,EAAE,KALe;AAM3B,IAAA,WAAW,EAAE,KANc;AAO3B,IAAA,MAAM,EAAE,EAPmB;AAQ3B,IAAA;AAR2B,GAA7B;AAUA,GAAA,GAAA,QAAA,CAAA,WAAA,EAAY,GAAZ,EAAiB,SAAjB,EAA4B,SAA5B,EAAuC,iBAAvC;AACD","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.boolOrEmptySchema = exports.topBoolOrEmptySchema = void 0;\nconst errors_1 = require(\"../errors\");\nconst codegen_1 = require(\"../codegen\");\nconst names_1 = require(\"../names\");\nconst boolError = {\n    message: \"boolean schema is false\",\n};\nfunction topBoolOrEmptySchema(it) {\n    const { gen, schema, validateName } = it;\n    if (schema === false) {\n        falseSchemaError(it, false);\n    }\n    else if (typeof schema == \"object\" && schema.$async === true) {\n        gen.return(names_1.default.data);\n    }\n    else {\n        gen.assign((0, codegen_1._) `${validateName}.errors`, null);\n        gen.return(true);\n    }\n}\nexports.topBoolOrEmptySchema = topBoolOrEmptySchema;\nfunction boolOrEmptySchema(it, valid) {\n    const { gen, schema } = it;\n    if (schema === false) {\n        gen.var(valid, false); // TODO var\n        falseSchemaError(it);\n    }\n    else {\n        gen.var(valid, true); // TODO var\n    }\n}\nexports.boolOrEmptySchema = boolOrEmptySchema;\nfunction falseSchemaError(it, overrideAllErrors) {\n    const { gen, data } = it;\n    // TODO maybe some other interface should be used for non-keyword validation errors...\n    const cxt = {\n        gen,\n        keyword: \"false schema\",\n        data,\n        schema: false,\n        schemaCode: false,\n        schemaValue: false,\n        params: {},\n        it,\n    };\n    (0, errors_1.reportError)(cxt, boolError, undefined, overrideAllErrors);\n}\n//# sourceMappingURL=boolSchema.js.map"]},"metadata":{},"sourceType":"script"}