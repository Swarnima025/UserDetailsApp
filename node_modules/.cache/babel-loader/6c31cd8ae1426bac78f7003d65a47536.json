{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst util_1 = require(\"../../compile/util\");\n\nconst def = {\n  keyword: \"allOf\",\n  schemaType: \"array\",\n\n  code(cxt) {\n    const {\n      gen,\n      schema,\n      it\n    } = cxt;\n    /* istanbul ignore if */\n\n    if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\");\n    const valid = gen.name(\"valid\");\n    schema.forEach((sch, i) => {\n      if ((0, util_1.alwaysValidSchema)(it, sch)) return;\n      const schCxt = cxt.subschema({\n        keyword: \"allOf\",\n        schemaProp: i\n      }, valid);\n      cxt.ok(valid);\n      cxt.mergeEvaluated(schCxt);\n    });\n  }\n\n};\nexports.default = def;","map":{"version":3,"sources":["../../../lib/vocabularies/applicator/allOf.ts"],"names":[],"mappings":";;;;;;AAEA,MAAA,MAAA,GAAA,OAAA,CAAA,oBAAA,CAAA;;AAEA,MAAM,GAAG,GAA0B;AACjC,EAAA,OAAO,EAAE,OADwB;AAEjC,EAAA,UAAU,EAAE,OAFqB;;AAGjC,EAAA,IAAI,CAAC,GAAD,EAAgB;AAClB,UAAM;AAAC,MAAA,GAAD;AAAM,MAAA,MAAN;AAAc,MAAA;AAAd,QAAoB,GAA1B;AACA;;AACA,QAAI,CAAC,KAAK,CAAC,OAAN,CAAc,MAAd,CAAL,EAA4B,MAAM,IAAI,KAAJ,CAAU,0BAAV,CAAN;AAC5B,UAAM,KAAK,GAAG,GAAG,CAAC,IAAJ,CAAS,OAAT,CAAd;AACA,IAAA,MAAM,CAAC,OAAP,CAAe,CAAC,GAAD,EAAiB,CAAjB,KAA8B;AAC3C,UAAI,CAAA,GAAA,MAAA,CAAA,iBAAA,EAAkB,EAAlB,EAAsB,GAAtB,CAAJ,EAAgC;AAChC,YAAM,MAAM,GAAG,GAAG,CAAC,SAAJ,CAAc;AAAC,QAAA,OAAO,EAAE,OAAV;AAAmB,QAAA,UAAU,EAAE;AAA/B,OAAd,EAAiD,KAAjD,CAAf;AACA,MAAA,GAAG,CAAC,EAAJ,CAAO,KAAP;AACA,MAAA,GAAG,CAAC,cAAJ,CAAmB,MAAnB;AACD,KALD;AAMD;;AAdgC,CAAnC;AAiBA,OAAA,CAAA,OAAA,GAAe,GAAf","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst util_1 = require(\"../../compile/util\");\nconst def = {\n    keyword: \"allOf\",\n    schemaType: \"array\",\n    code(cxt) {\n        const { gen, schema, it } = cxt;\n        /* istanbul ignore if */\n        if (!Array.isArray(schema))\n            throw new Error(\"ajv implementation error\");\n        const valid = gen.name(\"valid\");\n        schema.forEach((sch, i) => {\n            if ((0, util_1.alwaysValidSchema)(it, sch))\n                return;\n            const schCxt = cxt.subschema({ keyword: \"allOf\", schemaProp: i }, valid);\n            cxt.ok(valid);\n            cxt.mergeEvaluated(schCxt);\n        });\n    },\n};\nexports.default = def;\n//# sourceMappingURL=allOf.js.map"]},"metadata":{},"sourceType":"script"}