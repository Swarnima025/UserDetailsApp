{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.callRef = exports.getValidate = void 0;\n\nconst ref_error_1 = require(\"../../compile/ref_error\");\n\nconst code_1 = require(\"../code\");\n\nconst codegen_1 = require(\"../../compile/codegen\");\n\nconst names_1 = require(\"../../compile/names\");\n\nconst compile_1 = require(\"../../compile\");\n\nconst util_1 = require(\"../../compile/util\");\n\nconst def = {\n  keyword: \"$ref\",\n  schemaType: \"string\",\n\n  code(cxt) {\n    const {\n      gen,\n      schema: $ref,\n      it\n    } = cxt;\n    const {\n      baseId,\n      schemaEnv: env,\n      validateName,\n      opts,\n      self\n    } = it;\n    const {\n      root\n    } = env;\n    if (($ref === \"#\" || $ref === \"#/\") && baseId === root.baseId) return callRootRef();\n    const schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);\n    if (schOrEnv === undefined) throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);\n    if (schOrEnv instanceof compile_1.SchemaEnv) return callValidate(schOrEnv);\n    return inlineRefSchema(schOrEnv);\n\n    function callRootRef() {\n      if (env === root) return callRef(cxt, validateName, env, env.$async);\n      const rootName = gen.scopeValue(\"root\", {\n        ref: root\n      });\n      return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root, root.$async);\n    }\n\n    function callValidate(sch) {\n      const v = getValidate(cxt, sch);\n      callRef(cxt, v, sch, sch.$async);\n    }\n\n    function inlineRefSchema(sch) {\n      const schName = gen.scopeValue(\"schema\", opts.code.source === true ? {\n        ref: sch,\n        code: (0, codegen_1.stringify)(sch)\n      } : {\n        ref: sch\n      });\n      const valid = gen.name(\"valid\");\n      const schCxt = cxt.subschema({\n        schema: sch,\n        dataTypes: [],\n        schemaPath: codegen_1.nil,\n        topSchemaRef: schName,\n        errSchemaPath: $ref\n      }, valid);\n      cxt.mergeEvaluated(schCxt);\n      cxt.ok(valid);\n    }\n  }\n\n};\n\nfunction getValidate(cxt, sch) {\n  const {\n    gen\n  } = cxt;\n  return sch.validate ? gen.scopeValue(\"validate\", {\n    ref: sch.validate\n  }) : (0, codegen_1._)`${gen.scopeValue(\"wrapper\", {\n    ref: sch\n  })}.validate`;\n}\n\nexports.getValidate = getValidate;\n\nfunction callRef(cxt, v, sch, $async) {\n  const {\n    gen,\n    it\n  } = cxt;\n  const {\n    allErrors,\n    schemaEnv: env,\n    opts\n  } = it;\n  const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;\n  if ($async) callAsyncRef();else callSyncRef();\n\n  function callAsyncRef() {\n    if (!env.$async) throw new Error(\"async schema referenced by sync schema\");\n    const valid = gen.let(\"valid\");\n    gen.try(() => {\n      gen.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);\n      addEvaluatedFrom(v); // TODO will not work with async, it has to be returned with the result\n\n      if (!allErrors) gen.assign(valid, true);\n    }, e => {\n      gen.if((0, codegen_1._)`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));\n      addErrorsFrom(e);\n      if (!allErrors) gen.assign(valid, false);\n    });\n    cxt.ok(valid);\n  }\n\n  function callSyncRef() {\n    cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));\n  }\n\n  function addErrorsFrom(source) {\n    const errs = (0, codegen_1._)`${source}.errors`;\n    gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`); // TODO tagged\n\n    gen.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);\n  }\n\n  function addEvaluatedFrom(source) {\n    var _a;\n\n    if (!it.opts.unevaluated) return;\n    const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated; // TODO refactor\n\n    if (it.props !== true) {\n      if (schEvaluated && !schEvaluated.dynamicProps) {\n        if (schEvaluated.props !== undefined) {\n          it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);\n        }\n      } else {\n        const props = gen.var(\"props\", (0, codegen_1._)`${source}.evaluated.props`);\n        it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);\n      }\n    }\n\n    if (it.items !== true) {\n      if (schEvaluated && !schEvaluated.dynamicItems) {\n        if (schEvaluated.items !== undefined) {\n          it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);\n        }\n      } else {\n        const items = gen.var(\"items\", (0, codegen_1._)`${source}.evaluated.items`);\n        it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);\n      }\n    }\n  }\n}\n\nexports.callRef = callRef;\nexports.default = def;","map":{"version":3,"sources":["../../../lib/vocabularies/core/ref.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.callRef = exports.getValidate = void 0;\nconst ref_error_1 = require(\"../../compile/ref_error\");\nconst code_1 = require(\"../code\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst names_1 = require(\"../../compile/names\");\nconst compile_1 = require(\"../../compile\");\nconst util_1 = require(\"../../compile/util\");\nconst def = {\n    keyword: \"$ref\",\n    schemaType: \"string\",\n    code(cxt) {\n        const { gen, schema: $ref, it } = cxt;\n        const { baseId, schemaEnv: env, validateName, opts, self } = it;\n        const { root } = env;\n        if (($ref === \"#\" || $ref === \"#/\") && baseId === root.baseId)\n            return callRootRef();\n        const schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);\n        if (schOrEnv === undefined)\n            throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);\n        if (schOrEnv instanceof compile_1.SchemaEnv)\n            return callValidate(schOrEnv);\n        return inlineRefSchema(schOrEnv);\n        function callRootRef() {\n            if (env === root)\n                return callRef(cxt, validateName, env, env.$async);\n            const rootName = gen.scopeValue(\"root\", { ref: root });\n            return callRef(cxt, (0, codegen_1._) `${rootName}.validate`, root, root.$async);\n        }\n        function callValidate(sch) {\n            const v = getValidate(cxt, sch);\n            callRef(cxt, v, sch, sch.$async);\n        }\n        function inlineRefSchema(sch) {\n            const schName = gen.scopeValue(\"schema\", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });\n            const valid = gen.name(\"valid\");\n            const schCxt = cxt.subschema({\n                schema: sch,\n                dataTypes: [],\n                schemaPath: codegen_1.nil,\n                topSchemaRef: schName,\n                errSchemaPath: $ref,\n            }, valid);\n            cxt.mergeEvaluated(schCxt);\n            cxt.ok(valid);\n        }\n    },\n};\nfunction getValidate(cxt, sch) {\n    const { gen } = cxt;\n    return sch.validate\n        ? gen.scopeValue(\"validate\", { ref: sch.validate })\n        : (0, codegen_1._) `${gen.scopeValue(\"wrapper\", { ref: sch })}.validate`;\n}\nexports.getValidate = getValidate;\nfunction callRef(cxt, v, sch, $async) {\n    const { gen, it } = cxt;\n    const { allErrors, schemaEnv: env, opts } = it;\n    const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;\n    if ($async)\n        callAsyncRef();\n    else\n        callSyncRef();\n    function callAsyncRef() {\n        if (!env.$async)\n            throw new Error(\"async schema referenced by sync schema\");\n        const valid = gen.let(\"valid\");\n        gen.try(() => {\n            gen.code((0, codegen_1._) `await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);\n            addEvaluatedFrom(v); // TODO will not work with async, it has to be returned with the result\n            if (!allErrors)\n                gen.assign(valid, true);\n        }, (e) => {\n            gen.if((0, codegen_1._) `!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));\n            addErrorsFrom(e);\n            if (!allErrors)\n                gen.assign(valid, false);\n        });\n        cxt.ok(valid);\n    }\n    function callSyncRef() {\n        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));\n    }\n    function addErrorsFrom(source) {\n        const errs = (0, codegen_1._) `${source}.errors`;\n        gen.assign(names_1.default.vErrors, (0, codegen_1._) `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`); // TODO tagged\n        gen.assign(names_1.default.errors, (0, codegen_1._) `${names_1.default.vErrors}.length`);\n    }\n    function addEvaluatedFrom(source) {\n        var _a;\n        if (!it.opts.unevaluated)\n            return;\n        const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;\n        // TODO refactor\n        if (it.props !== true) {\n            if (schEvaluated && !schEvaluated.dynamicProps) {\n                if (schEvaluated.props !== undefined) {\n                    it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);\n                }\n            }\n            else {\n                const props = gen.var(\"props\", (0, codegen_1._) `${source}.evaluated.props`);\n                it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);\n            }\n        }\n        if (it.items !== true) {\n            if (schEvaluated && !schEvaluated.dynamicItems) {\n                if (schEvaluated.items !== undefined) {\n                    it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);\n                }\n            }\n            else {\n                const items = gen.var(\"items\", (0, codegen_1._) `${source}.evaluated.items`);\n                it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);\n            }\n        }\n    }\n}\nexports.callRef = callRef;\nexports.default = def;\n//# sourceMappingURL=ref.js.map"]},"metadata":{},"sourceType":"script"}