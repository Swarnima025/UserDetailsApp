{"ast":null,"code":"import toPath from 'lodash-es/toPath';\nimport isObject from 'lodash-es/isObject';\nimport clone from 'lodash-es/clone';\nimport { ADDITIONAL_PROPERTY_FLAG, RJSF_ADDITONAL_PROPERTIES_FLAG, ErrorSchemaBuilder, ERRORS_KEY, getUiOptions, PROPERTIES_KEY, getDefaultFormState, mergeValidationData, REF_KEY } from '@rjsf/utils';\nimport get from 'lodash-es/get';\nimport Ajv from 'ajv';\nimport addFormats from 'ajv-formats';\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nvar AJV_CONFIG = {\n  allErrors: true,\n  multipleOfPrecision: 8,\n  strict: false,\n  verbose: true\n};\nvar COLOR_FORMAT_REGEX = /^(#?([0-9A-Fa-f]{3}){1,2}\\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\\(\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*\\))|(rgb\\(\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*\\)))$/;\nvar DATA_URL_FORMAT_REGEX = /^data:([a-z]+\\/[a-z0-9-+.]+)?;(?:name=(.*);)?base64,(.*)$/;\n/** Creates an Ajv version 8 implementation object with standard support for the 'color` and `data-url` custom formats.\r\n * If `additionalMetaSchemas` are provided then the Ajv instance is modified to add each of the meta schemas in the\r\n * list. If `customFormats` are provided then those additional formats are added to the list of supported formats. If\r\n * `ajvOptionsOverrides` are provided then they are spread on top of the default `AJV_CONFIG` options when constructing\r\n * the `Ajv` instance. With Ajv v8, the JSON Schema formats are not provided by default, but can be plugged in. By\r\n * default, all formats from the `ajv-formats` library are added. To disable this capability, set the `ajvFormatOptions`\r\n * parameter to `false`. Additionally, you can configure the `ajv-formats` by providing a custom set of\r\n * [format options](https://github.com/ajv-validator/ajv-formats) to the `ajvFormatOptions` parameter.\r\n *\r\n * @param [additionalMetaSchemas] - The list of additional meta schemas that the validator can access\r\n * @param [customFormats] - The set of additional custom formats that the validator will support\r\n * @param [ajvOptionsOverrides={}] - The set of validator config override options\r\n * @param [ajvFormatOptions] - The `ajv-format` options to use when adding formats to `ajv`; pass `false` to disable it\r\n * @param [AjvClass] - The `Ajv` class to use when creating the validator instance\r\n */\n\nfunction createAjvInstance(additionalMetaSchemas, customFormats, ajvOptionsOverrides, ajvFormatOptions, AjvClass) {\n  if (ajvOptionsOverrides === void 0) {\n    ajvOptionsOverrides = {};\n  }\n\n  if (AjvClass === void 0) {\n    AjvClass = Ajv;\n  }\n\n  var ajv = new AjvClass(_extends({}, AJV_CONFIG, ajvOptionsOverrides));\n\n  if (ajvFormatOptions) {\n    addFormats(ajv, ajvFormatOptions);\n  } else if (ajvFormatOptions !== false) {\n    addFormats(ajv);\n  } // add custom formats\n\n\n  ajv.addFormat('data-url', DATA_URL_FORMAT_REGEX);\n  ajv.addFormat('color', COLOR_FORMAT_REGEX); // Add RJSF-specific additional properties keywords so Ajv doesn't report errors if strict is enabled.\n\n  ajv.addKeyword(ADDITIONAL_PROPERTY_FLAG);\n  ajv.addKeyword(RJSF_ADDITONAL_PROPERTIES_FLAG); // add more schemas to validate against\n\n  if (Array.isArray(additionalMetaSchemas)) {\n    ajv.addMetaSchema(additionalMetaSchemas);\n  } // add more custom formats to validate against\n\n\n  if (isObject(customFormats)) {\n    Object.keys(customFormats).forEach(function (formatName) {\n      ajv.addFormat(formatName, customFormats[formatName]);\n    });\n  }\n\n  return ajv;\n}\n\nvar _excluded = [\"instancePath\", \"keyword\", \"params\", \"schemaPath\", \"parentSchema\"];\nvar ROOT_SCHEMA_PREFIX = '__rjsf_rootSchema';\n/** `ValidatorType` implementation that uses the AJV 8 validation mechanism.\r\n */\n\nvar AJV8Validator = /*#__PURE__*/function () {\n  /** The AJV instance to use for all validations\r\n   *\r\n   * @private\r\n   */\n\n  /** The Localizer function to use for localizing Ajv errors\r\n   *\r\n   * @private\r\n   */\n\n  /** Constructs an `AJV8Validator` instance using the `options`\r\n   *\r\n   * @param options - The `CustomValidatorOptionsType` options that are used to create the AJV instance\r\n   * @param [localizer] - If provided, is used to localize a list of Ajv `ErrorObject`s\r\n   */\n  function AJV8Validator(options, localizer) {\n    this.ajv = void 0;\n    this.localizer = void 0;\n    var additionalMetaSchemas = options.additionalMetaSchemas,\n        customFormats = options.customFormats,\n        ajvOptionsOverrides = options.ajvOptionsOverrides,\n        ajvFormatOptions = options.ajvFormatOptions,\n        AjvClass = options.AjvClass;\n    this.ajv = createAjvInstance(additionalMetaSchemas, customFormats, ajvOptionsOverrides, ajvFormatOptions, AjvClass);\n    this.localizer = localizer;\n  }\n  /** Transforms a ajv validation errors list:\r\n   * [\r\n   *   {property: '.level1.level2[2].level3', message: 'err a'},\r\n   *   {property: '.level1.level2[2].level3', message: 'err b'},\r\n   *   {property: '.level1.level2[4].level3', message: 'err b'},\r\n   * ]\r\n   * Into an error tree:\r\n   * {\r\n   *   level1: {\r\n   *     level2: {\r\n   *       2: {level3: {errors: ['err a', 'err b']}},\r\n   *       4: {level3: {errors: ['err b']}},\r\n   *     }\r\n   *   }\r\n   * };\r\n   *\r\n   * @param errors - The list of RJSFValidationError objects\r\n   * @private\r\n   */\n\n\n  var _proto = AJV8Validator.prototype;\n\n  _proto.toErrorSchema = function toErrorSchema(errors) {\n    var builder = new ErrorSchemaBuilder();\n\n    if (errors.length) {\n      errors.forEach(function (error) {\n        var property = error.property,\n            message = error.message;\n        var path = toPath(property); // If the property is at the root (.level1) then toPath creates\n        // an empty array element at the first index. Remove it.\n\n        if (path.length > 0 && path[0] === '') {\n          path.splice(0, 1);\n        }\n\n        if (message) {\n          builder.addErrors(message, path);\n        }\n      });\n    }\n\n    return builder.ErrorSchema;\n  }\n  /** Converts an `errorSchema` into a list of `RJSFValidationErrors`\r\n   *\r\n   * @param errorSchema - The `ErrorSchema` instance to convert\r\n   * @param [fieldPath=[]] - The current field path, defaults to [] if not specified\r\n   */\n  ;\n\n  _proto.toErrorList = function toErrorList(errorSchema, fieldPath) {\n    var _this = this;\n\n    if (fieldPath === void 0) {\n      fieldPath = [];\n    }\n\n    if (!errorSchema) {\n      return [];\n    }\n\n    var errorList = [];\n\n    if (ERRORS_KEY in errorSchema) {\n      errorList = errorList.concat(errorSchema[ERRORS_KEY].map(function (message) {\n        var property = \".\" + fieldPath.join('.');\n        return {\n          property: property,\n          message: message,\n          stack: property + \" \" + message\n        };\n      }));\n    }\n\n    return Object.keys(errorSchema).reduce(function (acc, key) {\n      if (key !== ERRORS_KEY) {\n        acc = acc.concat(_this.toErrorList(errorSchema[key], [].concat(fieldPath, [key])));\n      }\n\n      return acc;\n    }, errorList);\n  }\n  /** Given a `formData` object, recursively creates a `FormValidation` error handling structure around it\r\n   *\r\n   * @param formData - The form data around which the error handler is created\r\n   * @private\r\n   */\n  ;\n\n  _proto.createErrorHandler = function createErrorHandler(formData) {\n    var _this2 = this;\n\n    var handler = {\n      // We store the list of errors for this node in a property named __errors\n      // to avoid name collision with a possible sub schema field named\n      // 'errors' (see `utils.toErrorSchema`).\n      __errors: [],\n      addError: function addError(message) {\n        this.__errors.push(message);\n      }\n    };\n\n    if (Array.isArray(formData)) {\n      return formData.reduce(function (acc, value, key) {\n        var _extends2;\n\n        return _extends({}, acc, (_extends2 = {}, _extends2[key] = _this2.createErrorHandler(value), _extends2));\n      }, handler);\n    }\n\n    if (isObject(formData)) {\n      var formObject = formData;\n      return Object.keys(formObject).reduce(function (acc, key) {\n        var _extends3;\n\n        return _extends({}, acc, (_extends3 = {}, _extends3[key] = _this2.createErrorHandler(formObject[key]), _extends3));\n      }, handler);\n    }\n\n    return handler;\n  }\n  /** Unwraps the `errorHandler` structure into the associated `ErrorSchema`, stripping the `addError` functions from it\r\n   *\r\n   * @param errorHandler - The `FormValidation` error handling structure\r\n   * @private\r\n   */\n  ;\n\n  _proto.unwrapErrorHandler = function unwrapErrorHandler(errorHandler) {\n    var _this3 = this;\n\n    return Object.keys(errorHandler).reduce(function (acc, key) {\n      var _extends5;\n\n      if (key === 'addError') {\n        return acc;\n      } else if (key === ERRORS_KEY) {\n        var _extends4;\n\n        return _extends({}, acc, (_extends4 = {}, _extends4[key] = errorHandler[key], _extends4));\n      }\n\n      return _extends({}, acc, (_extends5 = {}, _extends5[key] = _this3.unwrapErrorHandler(errorHandler[key]), _extends5));\n    }, {});\n  }\n  /** Transforming the error output from ajv to format used by @rjsf/utils.\r\n   * At some point, components should be updated to support ajv.\r\n   *\r\n   * @param errors - The list of AJV errors to convert to `RJSFValidationErrors`\r\n   * @protected\r\n   */\n  ;\n\n  _proto.transformRJSFValidationErrors = function transformRJSFValidationErrors(errors, uiSchema) {\n    if (errors === void 0) {\n      errors = [];\n    }\n\n    return errors.map(function (e) {\n      var instancePath = e.instancePath,\n          keyword = e.keyword,\n          params = e.params,\n          schemaPath = e.schemaPath,\n          parentSchema = e.parentSchema,\n          rest = _objectWithoutPropertiesLoose(e, _excluded);\n\n      var _rest$message = rest.message,\n          message = _rest$message === void 0 ? '' : _rest$message;\n      var property = instancePath.replace(/\\//g, '.');\n      var stack = (property + \" \" + message).trim();\n\n      if ('missingProperty' in params) {\n        property = property ? property + \".\" + params.missingProperty : params.missingProperty;\n        var currentProperty = params.missingProperty;\n        var uiSchemaTitle = getUiOptions(get(uiSchema, \"\" + property.replace(/^\\./, ''))).title;\n\n        if (uiSchemaTitle) {\n          message = message.replace(currentProperty, uiSchemaTitle);\n        } else {\n          var parentSchemaTitle = get(parentSchema, [PROPERTIES_KEY, currentProperty, 'title']);\n\n          if (parentSchemaTitle) {\n            message = message.replace(currentProperty, parentSchemaTitle);\n          }\n        }\n\n        stack = message;\n      } else {\n        var _uiSchemaTitle = getUiOptions(get(uiSchema, \"\" + property.replace(/^\\./, ''))).title;\n\n        if (_uiSchemaTitle) {\n          stack = (\"'\" + _uiSchemaTitle + \"' \" + message).trim();\n        } else {\n          var _parentSchemaTitle = parentSchema === null || parentSchema === void 0 ? void 0 : parentSchema.title;\n\n          if (_parentSchemaTitle) {\n            stack = (\"'\" + _parentSchemaTitle + \"' \" + message).trim();\n          }\n        }\n      } // put data in expected format\n\n\n      return {\n        name: keyword,\n        property: property,\n        message: message,\n        params: params,\n        stack: stack,\n        schemaPath: schemaPath\n      };\n    });\n  }\n  /** Runs the pure validation of the `schema` and `formData` without any of the RJSF functionality. Provided for use\r\n   * by the playground. Returns the `errors` from the validation\r\n   *\r\n   * @param schema - The schema against which to validate the form data   * @param schema\r\n   * @param formData - The form data to validate\r\n   */\n  ;\n\n  _proto.rawValidation = function rawValidation(schema, formData) {\n    var compilationError = undefined;\n    var compiledValidator;\n\n    if (schema['$id']) {\n      compiledValidator = this.ajv.getSchema(schema['$id']);\n    }\n\n    try {\n      if (compiledValidator === undefined) {\n        compiledValidator = this.ajv.compile(schema);\n      }\n\n      compiledValidator(formData);\n    } catch (err) {\n      compilationError = err;\n    }\n\n    var errors;\n\n    if (compiledValidator) {\n      if (typeof this.localizer === 'function') {\n        this.localizer(compiledValidator.errors);\n      }\n\n      errors = compiledValidator.errors || undefined; // Clear errors to prevent persistent errors, see #1104\n\n      compiledValidator.errors = null;\n    }\n\n    return {\n      errors: errors,\n      validationError: compilationError\n    };\n  }\n  /** This function processes the `formData` with an optional user contributed `customValidate` function, which receives\r\n   * the form data and a `errorHandler` function that will be used to add custom validation errors for each field. Also\r\n   * supports a `transformErrors` function that will take the raw AJV validation errors, prior to custom validation and\r\n   * transform them in what ever way it chooses.\r\n   *\r\n   * @param formData - The form data to validate\r\n   * @param schema - The schema against which to validate the form data\r\n   * @param [customValidate] - An optional function that is used to perform custom validation\r\n   * @param [transformErrors] - An optional function that is used to transform errors after AJV validation\r\n   * @param [uiSchema] - An optional uiSchema that is passed to `transformErrors` and `customValidate`\r\n   */\n  ;\n\n  _proto.validateFormData = function validateFormData(formData, schema, customValidate, transformErrors, uiSchema) {\n    var rawErrors = this.rawValidation(schema, formData);\n    var invalidSchemaError = rawErrors.validationError;\n    var errors = this.transformRJSFValidationErrors(rawErrors.errors, uiSchema);\n\n    if (invalidSchemaError) {\n      errors = [].concat(errors, [{\n        stack: invalidSchemaError.message\n      }]);\n    }\n\n    if (typeof transformErrors === 'function') {\n      errors = transformErrors(errors, uiSchema);\n    }\n\n    var errorSchema = this.toErrorSchema(errors);\n\n    if (invalidSchemaError) {\n      errorSchema = _extends({}, errorSchema, {\n        $schema: {\n          __errors: [invalidSchemaError.message]\n        }\n      });\n    }\n\n    if (typeof customValidate !== 'function') {\n      return {\n        errors: errors,\n        errorSchema: errorSchema\n      };\n    } // Include form data with undefined values, which is required for custom validation.\n\n\n    var newFormData = getDefaultFormState(this, schema, formData, schema, true);\n    var errorHandler = customValidate(newFormData, this.createErrorHandler(newFormData), uiSchema);\n    var userErrorSchema = this.unwrapErrorHandler(errorHandler);\n    return mergeValidationData(this, {\n      errors: errors,\n      errorSchema: errorSchema\n    }, userErrorSchema);\n  }\n  /** Takes a `node` object and transforms any contained `$ref` node variables with a prefix, recursively calling\r\n   * `withIdRefPrefix` for any other elements.\r\n   *\r\n   * @param node - The object node to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\r\n   * @private\r\n   */\n  ;\n\n  _proto.withIdRefPrefixObject = function withIdRefPrefixObject(node) {\n    for (var key in node) {\n      var realObj = node;\n      var value = realObj[key];\n\n      if (key === REF_KEY && typeof value === 'string' && value.startsWith('#')) {\n        realObj[key] = ROOT_SCHEMA_PREFIX + value;\n      } else {\n        realObj[key] = this.withIdRefPrefix(value);\n      }\n    }\n\n    return node;\n  }\n  /** Takes a `node` object list and transforms any contained `$ref` node variables with a prefix, recursively calling\r\n   * `withIdRefPrefix` for any other elements.\r\n   *\r\n   * @param node - The list of object nodes to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\r\n   * @private\r\n   */\n  ;\n\n  _proto.withIdRefPrefixArray = function withIdRefPrefixArray(node) {\n    for (var i = 0; i < node.length; i++) {\n      node[i] = this.withIdRefPrefix(node[i]);\n    }\n\n    return node;\n  }\n  /** Validates data against a schema, returning true if the data is valid, or\r\n   * false otherwise. If the schema is invalid, then this function will return\r\n   * false.\r\n   *\r\n   * @param schema - The schema against which to validate the form data\r\n   * @param formData - The form data to validate\r\n   * @param rootSchema - The root schema used to provide $ref resolutions\r\n   */\n  ;\n\n  _proto.isValid = function isValid(schema, formData, rootSchema) {\n    var _rootSchema$$id;\n\n    var rootSchemaId = (_rootSchema$$id = rootSchema['$id']) != null ? _rootSchema$$id : ROOT_SCHEMA_PREFIX;\n\n    try {\n      // add the rootSchema ROOT_SCHEMA_PREFIX as id.\n      // then rewrite the schema ref's to point to the rootSchema\n      // this accounts for the case where schema have references to models\n      // that lives in the rootSchema but not in the schema in question.\n      if (this.ajv.getSchema(rootSchemaId) === undefined) {\n        this.ajv.addSchema(rootSchema, rootSchemaId);\n      }\n\n      var schemaWithIdRefPrefix = this.withIdRefPrefix(schema);\n      var compiledValidator;\n\n      if (schemaWithIdRefPrefix['$id']) {\n        compiledValidator = this.ajv.getSchema(schemaWithIdRefPrefix['$id']);\n      }\n\n      if (compiledValidator === undefined) {\n        compiledValidator = this.ajv.compile(schemaWithIdRefPrefix);\n      }\n\n      var result = compiledValidator(formData);\n      return result;\n    } catch (e) {\n      console.warn('Error encountered compiling schema:', e);\n      return false;\n    } finally {\n      // TODO: A function should be called if the root schema changes so we don't have to remove and recompile the schema every run.\n      // make sure we remove the rootSchema from the global ajv instance\n      this.ajv.removeSchema(rootSchemaId);\n    }\n  }\n  /** Recursively prefixes all $ref's in a schema with `ROOT_SCHEMA_PREFIX`\r\n   * This is used in isValid to make references to the rootSchema\r\n   *\r\n   * @param schemaNode - The object node to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\r\n   * @protected\r\n   */\n  ;\n\n  _proto.withIdRefPrefix = function withIdRefPrefix(schemaNode) {\n    if (Array.isArray(schemaNode)) {\n      return this.withIdRefPrefixArray([].concat(schemaNode));\n    }\n\n    if (isObject(schemaNode)) {\n      return this.withIdRefPrefixObject(clone(schemaNode));\n    }\n\n    return schemaNode;\n  };\n\n  return AJV8Validator;\n}();\n/** Creates and returns a customized implementation of the `ValidatorType` with the given customization `options` if\r\n * provided.\r\n *\r\n * @param [options={}] - The `CustomValidatorOptionsType` options that are used to create the `ValidatorType` instance\r\n * @param [localizer] - If provided, is used to localize a list of Ajv `ErrorObject`s\r\n */\n\n\nfunction customizeValidator(options, localizer) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return new AJV8Validator(options, localizer);\n}\n\nvar index = /*#__PURE__*/customizeValidator();\nexport { customizeValidator, index as default };","map":{"version":3,"sources":["../src/createAjvInstance.ts","../src/validator.ts","../src/customizeValidator.ts","../src/index.ts"],"names":["AJV_CONFIG","allErrors","multipleOfPrecision","strict","verbose","COLOR_FORMAT_REGEX","DATA_URL_FORMAT_REGEX","additionalMetaSchemas","customFormats","ajvOptionsOverrides","ajvFormatOptions","AjvClass","Ajv","ajv","addFormats","addFormat","addKeyword","ADDITIONAL_PROPERTY_FLAG","RJSF_ADDITONAL_PROPERTIES_FLAG","Array","isArray","addMetaSchema","isObject","Object","keys","forEach","formatName","ROOT_SCHEMA_PREFIX","AJV8Validator","localizer","options","createAjvInstance","toErrorSchema","errors","builder","ErrorSchemaBuilder","length","error","property","message","path","toPath","splice","addErrors","ErrorSchema","toErrorList","errorSchema","fieldPath","errorList","ERRORS_KEY","concat","map","join","stack","reduce","acc","key","_this","createErrorHandler","formData","handler","__errors","addError","push","value","_this2","formObject","unwrapErrorHandler","errorHandler","_this3","transformRJSFValidationErrors","uiSchema","e","instancePath","keyword","params","schemaPath","parentSchema","rest","replace","trim","missingProperty","currentProperty","uiSchemaTitle","getUiOptions","get","title","parentSchemaTitle","PROPERTIES_KEY","name","rawValidation","schema","compilationError","undefined","compiledValidator","getSchema","compile","err","validationError","validateFormData","customValidate","transformErrors","rawErrors","invalidSchemaError","$schema","newFormData","getDefaultFormState","userErrorSchema","mergeValidationData","withIdRefPrefixObject","node","realObj","REF_KEY","startsWith","withIdRefPrefix","withIdRefPrefixArray","i","isValid","rootSchema","rootSchemaId","addSchema","schemaWithIdRefPrefix","result","console","warn","removeSchema","schemaNode","clone","customizeValidator"],"mappings":"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","sourcesContent":["import Ajv, { Options } from 'ajv';\nimport addFormats, { FormatsPluginOptions } from 'ajv-formats';\nimport isObject from 'lodash/isObject';\n\nimport { CustomValidatorOptionsType } from './types';\nimport { ADDITIONAL_PROPERTY_FLAG, RJSF_ADDITONAL_PROPERTIES_FLAG } from '@rjsf/utils';\n\nexport const AJV_CONFIG: Options = {\n  allErrors: true,\n  multipleOfPrecision: 8,\n  strict: false,\n  verbose: true,\n} as const;\nexport const COLOR_FORMAT_REGEX =\n  /^(#?([0-9A-Fa-f]{3}){1,2}\\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\\(\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*\\))|(rgb\\(\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*\\)))$/;\nexport const DATA_URL_FORMAT_REGEX = /^data:([a-z]+\\/[a-z0-9-+.]+)?;(?:name=(.*);)?base64,(.*)$/;\n\n/** Creates an Ajv version 8 implementation object with standard support for the 'color` and `data-url` custom formats.\n * If `additionalMetaSchemas` are provided then the Ajv instance is modified to add each of the meta schemas in the\n * list. If `customFormats` are provided then those additional formats are added to the list of supported formats. If\n * `ajvOptionsOverrides` are provided then they are spread on top of the default `AJV_CONFIG` options when constructing\n * the `Ajv` instance. With Ajv v8, the JSON Schema formats are not provided by default, but can be plugged in. By\n * default, all formats from the `ajv-formats` library are added. To disable this capability, set the `ajvFormatOptions`\n * parameter to `false`. Additionally, you can configure the `ajv-formats` by providing a custom set of\n * [format options](https://github.com/ajv-validator/ajv-formats) to the `ajvFormatOptions` parameter.\n *\n * @param [additionalMetaSchemas] - The list of additional meta schemas that the validator can access\n * @param [customFormats] - The set of additional custom formats that the validator will support\n * @param [ajvOptionsOverrides={}] - The set of validator config override options\n * @param [ajvFormatOptions] - The `ajv-format` options to use when adding formats to `ajv`; pass `false` to disable it\n * @param [AjvClass] - The `Ajv` class to use when creating the validator instance\n */\nexport default function createAjvInstance(\n  additionalMetaSchemas?: CustomValidatorOptionsType['additionalMetaSchemas'],\n  customFormats?: CustomValidatorOptionsType['customFormats'],\n  ajvOptionsOverrides: CustomValidatorOptionsType['ajvOptionsOverrides'] = {},\n  ajvFormatOptions?: FormatsPluginOptions | false,\n  AjvClass: typeof Ajv = Ajv\n) {\n  const ajv = new AjvClass({ ...AJV_CONFIG, ...ajvOptionsOverrides });\n  if (ajvFormatOptions) {\n    addFormats(ajv, ajvFormatOptions);\n  } else if (ajvFormatOptions !== false) {\n    addFormats(ajv);\n  }\n\n  // add custom formats\n  ajv.addFormat('data-url', DATA_URL_FORMAT_REGEX);\n  ajv.addFormat('color', COLOR_FORMAT_REGEX);\n\n  // Add RJSF-specific additional properties keywords so Ajv doesn't report errors if strict is enabled.\n  ajv.addKeyword(ADDITIONAL_PROPERTY_FLAG);\n  ajv.addKeyword(RJSF_ADDITONAL_PROPERTIES_FLAG);\n\n  // add more schemas to validate against\n  if (Array.isArray(additionalMetaSchemas)) {\n    ajv.addMetaSchema(additionalMetaSchemas);\n  }\n\n  // add more custom formats to validate against\n  if (isObject(customFormats)) {\n    Object.keys(customFormats).forEach((formatName) => {\n      ajv.addFormat(formatName, customFormats[formatName]);\n    });\n  }\n\n  return ajv;\n}\n","import Ajv, { ErrorObject, ValidateFunction } from 'ajv';\nimport toPath from 'lodash/toPath';\nimport isObject from 'lodash/isObject';\nimport clone from 'lodash/clone';\nimport {\n  CustomValidator,\n  ERRORS_KEY,\n  ErrorSchema,\n  ErrorSchemaBuilder,\n  ErrorTransformer,\n  FieldValidation,\n  FormContextType,\n  FormValidation,\n  GenericObjectType,\n  getDefaultFormState,\n  mergeValidationData,\n  REF_KEY,\n  RJSFSchema,\n  RJSFValidationError,\n  StrictRJSFSchema,\n  UiSchema,\n  ValidationData,\n  ValidatorType,\n  PROPERTIES_KEY,\n  getUiOptions,\n} from '@rjsf/utils';\nimport get from 'lodash/get';\n\nimport { CustomValidatorOptionsType, Localizer } from './types';\nimport createAjvInstance from './createAjvInstance';\n\nconst ROOT_SCHEMA_PREFIX = '__rjsf_rootSchema';\n\n/** `ValidatorType` implementation that uses the AJV 8 validation mechanism.\n */\nexport default class AJV8Validator<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>\n  implements ValidatorType<T, S, F>\n{\n  /** The AJV instance to use for all validations\n   *\n   * @private\n   */\n  private ajv: Ajv;\n\n  /** The Localizer function to use for localizing Ajv errors\n   *\n   * @private\n   */\n  readonly localizer?: Localizer;\n\n  /** Constructs an `AJV8Validator` instance using the `options`\n   *\n   * @param options - The `CustomValidatorOptionsType` options that are used to create the AJV instance\n   * @param [localizer] - If provided, is used to localize a list of Ajv `ErrorObject`s\n   */\n  constructor(options: CustomValidatorOptionsType, localizer?: Localizer) {\n    const { additionalMetaSchemas, customFormats, ajvOptionsOverrides, ajvFormatOptions, AjvClass } = options;\n    this.ajv = createAjvInstance(additionalMetaSchemas, customFormats, ajvOptionsOverrides, ajvFormatOptions, AjvClass);\n    this.localizer = localizer;\n  }\n\n  /** Transforms a ajv validation errors list:\n   * [\n   *   {property: '.level1.level2[2].level3', message: 'err a'},\n   *   {property: '.level1.level2[2].level3', message: 'err b'},\n   *   {property: '.level1.level2[4].level3', message: 'err b'},\n   * ]\n   * Into an error tree:\n   * {\n   *   level1: {\n   *     level2: {\n   *       2: {level3: {errors: ['err a', 'err b']}},\n   *       4: {level3: {errors: ['err b']}},\n   *     }\n   *   }\n   * };\n   *\n   * @param errors - The list of RJSFValidationError objects\n   * @private\n   */\n  private toErrorSchema(errors: RJSFValidationError[]): ErrorSchema<T> {\n    const builder = new ErrorSchemaBuilder<T>();\n    if (errors.length) {\n      errors.forEach((error) => {\n        const { property, message } = error;\n        const path = toPath(property);\n\n        // If the property is at the root (.level1) then toPath creates\n        // an empty array element at the first index. Remove it.\n        if (path.length > 0 && path[0] === '') {\n          path.splice(0, 1);\n        }\n        if (message) {\n          builder.addErrors(message, path);\n        }\n      });\n    }\n    return builder.ErrorSchema;\n  }\n\n  /** Converts an `errorSchema` into a list of `RJSFValidationErrors`\n   *\n   * @param errorSchema - The `ErrorSchema` instance to convert\n   * @param [fieldPath=[]] - The current field path, defaults to [] if not specified\n   */\n  toErrorList(errorSchema?: ErrorSchema<T>, fieldPath: string[] = []) {\n    if (!errorSchema) {\n      return [];\n    }\n    let errorList: RJSFValidationError[] = [];\n    if (ERRORS_KEY in errorSchema) {\n      errorList = errorList.concat(\n        errorSchema[ERRORS_KEY]!.map((message: string) => {\n          const property = `.${fieldPath.join('.')}`;\n          return {\n            property,\n            message,\n            stack: `${property} ${message}`,\n          };\n        })\n      );\n    }\n    return Object.keys(errorSchema).reduce((acc, key) => {\n      if (key !== ERRORS_KEY) {\n        acc = acc.concat(this.toErrorList((errorSchema as GenericObjectType)[key], [...fieldPath, key]));\n      }\n      return acc;\n    }, errorList);\n  }\n\n  /** Given a `formData` object, recursively creates a `FormValidation` error handling structure around it\n   *\n   * @param formData - The form data around which the error handler is created\n   * @private\n   */\n  private createErrorHandler(formData: T): FormValidation<T> {\n    const handler: FieldValidation = {\n      // We store the list of errors for this node in a property named __errors\n      // to avoid name collision with a possible sub schema field named\n      // 'errors' (see `utils.toErrorSchema`).\n      __errors: [],\n      addError(message: string) {\n        this.__errors!.push(message);\n      },\n    };\n    if (Array.isArray(formData)) {\n      return formData.reduce((acc, value, key) => {\n        return { ...acc, [key]: this.createErrorHandler(value) };\n      }, handler);\n    }\n    if (isObject(formData)) {\n      const formObject: GenericObjectType = formData as GenericObjectType;\n      return Object.keys(formObject).reduce((acc, key) => {\n        return { ...acc, [key]: this.createErrorHandler(formObject[key]) };\n      }, handler as FormValidation<T>);\n    }\n    return handler as FormValidation<T>;\n  }\n\n  /** Unwraps the `errorHandler` structure into the associated `ErrorSchema`, stripping the `addError` functions from it\n   *\n   * @param errorHandler - The `FormValidation` error handling structure\n   * @private\n   */\n  private unwrapErrorHandler(errorHandler: FormValidation<T>): ErrorSchema<T> {\n    return Object.keys(errorHandler).reduce((acc, key) => {\n      if (key === 'addError') {\n        return acc;\n      } else if (key === ERRORS_KEY) {\n        return { ...acc, [key]: (errorHandler as GenericObjectType)[key] };\n      }\n      return {\n        ...acc,\n        [key]: this.unwrapErrorHandler((errorHandler as GenericObjectType)[key]),\n      };\n    }, {} as ErrorSchema<T>);\n  }\n\n  /** Transforming the error output from ajv to format used by @rjsf/utils.\n   * At some point, components should be updated to support ajv.\n   *\n   * @param errors - The list of AJV errors to convert to `RJSFValidationErrors`\n   * @protected\n   */\n  protected transformRJSFValidationErrors(\n    errors: ErrorObject[] = [],\n    uiSchema?: UiSchema<T, S, F>\n  ): RJSFValidationError[] {\n    return errors.map((e: ErrorObject) => {\n      const { instancePath, keyword, params, schemaPath, parentSchema, ...rest } = e;\n      let { message = '' } = rest;\n      let property = instancePath.replace(/\\//g, '.');\n      let stack = `${property} ${message}`.trim();\n\n      if ('missingProperty' in params) {\n        property = property ? `${property}.${params.missingProperty}` : params.missingProperty;\n        const currentProperty: string = params.missingProperty;\n        const uiSchemaTitle = getUiOptions(get(uiSchema, `${property.replace(/^\\./, '')}`)).title;\n\n        if (uiSchemaTitle) {\n          message = message.replace(currentProperty, uiSchemaTitle);\n        } else {\n          const parentSchemaTitle = get(parentSchema, [PROPERTIES_KEY, currentProperty, 'title']);\n\n          if (parentSchemaTitle) {\n            message = message.replace(currentProperty, parentSchemaTitle);\n          }\n        }\n\n        stack = message;\n      } else {\n        const uiSchemaTitle = getUiOptions(get(uiSchema, `${property.replace(/^\\./, '')}`)).title;\n\n        if (uiSchemaTitle) {\n          stack = `'${uiSchemaTitle}' ${message}`.trim();\n        } else {\n          const parentSchemaTitle = parentSchema?.title;\n\n          if (parentSchemaTitle) {\n            stack = `'${parentSchemaTitle}' ${message}`.trim();\n          }\n        }\n      }\n\n      // put data in expected format\n      return {\n        name: keyword,\n        property,\n        message,\n        params, // specific to ajv\n        stack,\n        schemaPath,\n      };\n    });\n  }\n\n  /** Runs the pure validation of the `schema` and `formData` without any of the RJSF functionality. Provided for use\n   * by the playground. Returns the `errors` from the validation\n   *\n   * @param schema - The schema against which to validate the form data   * @param schema\n   * @param formData - The form data to validate\n   */\n  rawValidation<Result = any>(schema: RJSFSchema, formData?: T): { errors?: Result[]; validationError?: Error } {\n    let compilationError: Error | undefined = undefined;\n    let compiledValidator: ValidateFunction | undefined;\n    if (schema['$id']) {\n      compiledValidator = this.ajv.getSchema(schema['$id']);\n    }\n    try {\n      if (compiledValidator === undefined) {\n        compiledValidator = this.ajv.compile(schema);\n      }\n      compiledValidator(formData);\n    } catch (err) {\n      compilationError = err as Error;\n    }\n\n    let errors;\n    if (compiledValidator) {\n      if (typeof this.localizer === 'function') {\n        this.localizer(compiledValidator.errors);\n      }\n      errors = compiledValidator.errors || undefined;\n\n      // Clear errors to prevent persistent errors, see #1104\n      compiledValidator.errors = null;\n    }\n\n    return {\n      errors: errors as unknown as Result[],\n      validationError: compilationError,\n    };\n  }\n\n  /** This function processes the `formData` with an optional user contributed `customValidate` function, which receives\n   * the form data and a `errorHandler` function that will be used to add custom validation errors for each field. Also\n   * supports a `transformErrors` function that will take the raw AJV validation errors, prior to custom validation and\n   * transform them in what ever way it chooses.\n   *\n   * @param formData - The form data to validate\n   * @param schema - The schema against which to validate the form data\n   * @param [customValidate] - An optional function that is used to perform custom validation\n   * @param [transformErrors] - An optional function that is used to transform errors after AJV validation\n   * @param [uiSchema] - An optional uiSchema that is passed to `transformErrors` and `customValidate`\n   */\n  validateFormData(\n    formData: T | undefined,\n    schema: S,\n    customValidate?: CustomValidator<T, S, F>,\n    transformErrors?: ErrorTransformer<T, S, F>,\n    uiSchema?: UiSchema<T, S, F>\n  ): ValidationData<T> {\n    const rawErrors = this.rawValidation<ErrorObject>(schema, formData);\n    const { validationError: invalidSchemaError } = rawErrors;\n    let errors = this.transformRJSFValidationErrors(rawErrors.errors, uiSchema);\n\n    if (invalidSchemaError) {\n      errors = [...errors, { stack: invalidSchemaError!.message }];\n    }\n    if (typeof transformErrors === 'function') {\n      errors = transformErrors(errors, uiSchema);\n    }\n\n    let errorSchema = this.toErrorSchema(errors);\n\n    if (invalidSchemaError) {\n      errorSchema = {\n        ...errorSchema,\n        $schema: {\n          __errors: [invalidSchemaError!.message],\n        },\n      };\n    }\n\n    if (typeof customValidate !== 'function') {\n      return { errors, errorSchema };\n    }\n\n    // Include form data with undefined values, which is required for custom validation.\n    const newFormData = getDefaultFormState<T, S, F>(this, schema, formData, schema, true) as T;\n\n    const errorHandler = customValidate(newFormData, this.createErrorHandler(newFormData), uiSchema);\n    const userErrorSchema = this.unwrapErrorHandler(errorHandler);\n    return mergeValidationData<T, S, F>(this, { errors, errorSchema }, userErrorSchema);\n  }\n\n  /** Takes a `node` object and transforms any contained `$ref` node variables with a prefix, recursively calling\n   * `withIdRefPrefix` for any other elements.\n   *\n   * @param node - The object node to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\n   * @private\n   */\n  private withIdRefPrefixObject(node: S) {\n    for (const key in node) {\n      const realObj: GenericObjectType = node;\n      const value = realObj[key];\n      if (key === REF_KEY && typeof value === 'string' && value.startsWith('#')) {\n        realObj[key] = ROOT_SCHEMA_PREFIX + value;\n      } else {\n        realObj[key] = this.withIdRefPrefix(value);\n      }\n    }\n    return node;\n  }\n\n  /** Takes a `node` object list and transforms any contained `$ref` node variables with a prefix, recursively calling\n   * `withIdRefPrefix` for any other elements.\n   *\n   * @param node - The list of object nodes to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\n   * @private\n   */\n  private withIdRefPrefixArray(node: S[]): S[] {\n    for (let i = 0; i < node.length; i++) {\n      node[i] = this.withIdRefPrefix(node[i]) as S;\n    }\n    return node;\n  }\n\n  /** Validates data against a schema, returning true if the data is valid, or\n   * false otherwise. If the schema is invalid, then this function will return\n   * false.\n   *\n   * @param schema - The schema against which to validate the form data\n   * @param formData - The form data to validate\n   * @param rootSchema - The root schema used to provide $ref resolutions\n   */\n  isValid(schema: S, formData: T | undefined, rootSchema: S) {\n    const rootSchemaId = rootSchema['$id'] ?? ROOT_SCHEMA_PREFIX;\n    try {\n      // add the rootSchema ROOT_SCHEMA_PREFIX as id.\n      // then rewrite the schema ref's to point to the rootSchema\n      // this accounts for the case where schema have references to models\n      // that lives in the rootSchema but not in the schema in question.\n      if (this.ajv.getSchema(rootSchemaId) === undefined) {\n        this.ajv.addSchema(rootSchema, rootSchemaId);\n      }\n      const schemaWithIdRefPrefix = this.withIdRefPrefix(schema) as S;\n      let compiledValidator: ValidateFunction | undefined;\n      if (schemaWithIdRefPrefix['$id']) {\n        compiledValidator = this.ajv.getSchema(schemaWithIdRefPrefix['$id']);\n      }\n      if (compiledValidator === undefined) {\n        compiledValidator = this.ajv.compile(schemaWithIdRefPrefix);\n      }\n      const result = compiledValidator(formData);\n      return result as boolean;\n    } catch (e) {\n      console.warn('Error encountered compiling schema:', e);\n      return false;\n    } finally {\n      // TODO: A function should be called if the root schema changes so we don't have to remove and recompile the schema every run.\n      // make sure we remove the rootSchema from the global ajv instance\n      this.ajv.removeSchema(rootSchemaId);\n    }\n  }\n\n  /** Recursively prefixes all $ref's in a schema with `ROOT_SCHEMA_PREFIX`\n   * This is used in isValid to make references to the rootSchema\n   *\n   * @param schemaNode - The object node to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\n   * @protected\n   */\n  protected withIdRefPrefix(schemaNode: S | S[]): S | S[] {\n    if (Array.isArray(schemaNode)) {\n      return this.withIdRefPrefixArray([...schemaNode]);\n    }\n    if (isObject(schemaNode)) {\n      return this.withIdRefPrefixObject(clone<S>(schemaNode));\n    }\n    return schemaNode;\n  }\n}\n","import { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '@rjsf/utils';\n\nimport { CustomValidatorOptionsType, Localizer } from './types';\nimport AJV8Validator from './validator';\n\n/** Creates and returns a customized implementation of the `ValidatorType` with the given customization `options` if\n * provided.\n *\n * @param [options={}] - The `CustomValidatorOptionsType` options that are used to create the `ValidatorType` instance\n * @param [localizer] - If provided, is used to localize a list of Ajv `ErrorObject`s\n */\nexport default function customizeValidator<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(options: CustomValidatorOptionsType = {}, localizer?: Localizer): ValidatorType<T, S, F> {\n  return new AJV8Validator<T, S, F>(options, localizer);\n}\n","import customizeValidator from './customizeValidator';\n\nexport { customizeValidator };\nexport * from './types';\n\nexport default customizeValidator();\n"]},"metadata":{},"sourceType":"module"}