{"ast":null,"code":"const compare = require('json-schema-compare');\n\nconst forEach = require('lodash/forEach');\n\nconst {\n  allUniqueKeys,\n  deleteUndefinedProps,\n  getValues,\n  keys,\n  notUndefined,\n  uniqWith,\n  withoutArr\n} = require('../common');\n\nfunction removeFalseSchemas(target) {\n  forEach(target, function (schema, prop) {\n    if (schema === false) {\n      delete target[prop];\n    }\n  });\n}\n\nfunction mergeSchemaGroup(group, mergeSchemas) {\n  const allKeys = allUniqueKeys(group);\n  return allKeys.reduce(function (all, key) {\n    const schemas = getValues(group, key);\n    const compacted = uniqWith(schemas.filter(notUndefined), compare);\n    all[key] = mergeSchemas(compacted, key);\n    return all;\n  }, {});\n}\n\nmodule.exports = {\n  keywords: ['properties', 'patternProperties', 'additionalProperties'],\n\n  resolver(values, parents, mergers, options) {\n    // first get rid of all non permitted properties\n    if (!options.ignoreAdditionalProperties) {\n      values.forEach(function (subSchema) {\n        const otherSubSchemas = values.filter(s => s !== subSchema);\n        const ownKeys = keys(subSchema.properties);\n        const ownPatternKeys = keys(subSchema.patternProperties);\n        const ownPatterns = ownPatternKeys.map(k => new RegExp(k));\n        otherSubSchemas.forEach(function (other) {\n          const allOtherKeys = keys(other.properties);\n          const keysMatchingPattern = allOtherKeys.filter(k => ownPatterns.some(pk => pk.test(k)));\n          const additionalKeys = withoutArr(allOtherKeys, ownKeys, keysMatchingPattern);\n          additionalKeys.forEach(function (key) {\n            other.properties[key] = mergers.properties([other.properties[key], subSchema.additionalProperties], key);\n          });\n        });\n      }); // remove disallowed patternProperties\n\n      values.forEach(function (subSchema) {\n        const otherSubSchemas = values.filter(s => s !== subSchema);\n        const ownPatternKeys = keys(subSchema.patternProperties);\n\n        if (subSchema.additionalProperties === false) {\n          otherSubSchemas.forEach(function (other) {\n            const allOtherPatterns = keys(other.patternProperties);\n            const additionalPatternKeys = withoutArr(allOtherPatterns, ownPatternKeys);\n            additionalPatternKeys.forEach(key => delete other.patternProperties[key]);\n          });\n        }\n      });\n    }\n\n    const returnObject = {\n      additionalProperties: mergers.additionalProperties(values.map(s => s.additionalProperties)),\n      patternProperties: mergeSchemaGroup(values.map(s => s.patternProperties), mergers.patternProperties),\n      properties: mergeSchemaGroup(values.map(s => s.properties), mergers.properties)\n    };\n\n    if (returnObject.additionalProperties === false) {\n      removeFalseSchemas(returnObject.properties);\n    }\n\n    return deleteUndefinedProps(returnObject);\n  }\n\n};","map":{"version":3,"sources":["C:/Users/swarnima.mazumdar/Desktop/Contact-app/node_modules/json-schema-merge-allof/src/complex-resolvers/properties.js"],"names":["compare","require","forEach","allUniqueKeys","deleteUndefinedProps","getValues","keys","notUndefined","uniqWith","withoutArr","removeFalseSchemas","target","schema","prop","mergeSchemaGroup","group","mergeSchemas","allKeys","reduce","all","key","schemas","compacted","filter","module","exports","keywords","resolver","values","parents","mergers","options","ignoreAdditionalProperties","subSchema","otherSubSchemas","s","ownKeys","properties","ownPatternKeys","patternProperties","ownPatterns","map","k","RegExp","other","allOtherKeys","keysMatchingPattern","some","pk","test","additionalKeys","additionalProperties","allOtherPatterns","additionalPatternKeys","returnObject"],"mappings":"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","sourcesContent":["\nconst compare = require('json-schema-compare')\nconst forEach = require('lodash/forEach')\nconst {\n  allUniqueKeys,\n  deleteUndefinedProps,\n  getValues,\n  keys,\n  notUndefined,\n  uniqWith,\n  withoutArr\n} = require('../common')\n\nfunction removeFalseSchemas(target) {\n  forEach(target, function(schema, prop) {\n    if (schema === false) {\n      delete target[prop]\n    }\n  })\n}\n\nfunction mergeSchemaGroup(group, mergeSchemas) {\n  const allKeys = allUniqueKeys(group)\n  return allKeys.reduce(function(all, key) {\n    const schemas = getValues(group, key)\n    const compacted = uniqWith(schemas.filter(notUndefined), compare)\n    all[key] = mergeSchemas(compacted, key)\n    return all\n  }, {})\n}\n\nmodule.exports = {\n  keywords: ['properties', 'patternProperties', 'additionalProperties'],\n  resolver(values, parents, mergers, options) {\n    // first get rid of all non permitted properties\n    if (!options.ignoreAdditionalProperties) {\n      values.forEach(function(subSchema) {\n        const otherSubSchemas = values.filter(s => s !== subSchema)\n        const ownKeys = keys(subSchema.properties)\n        const ownPatternKeys = keys(subSchema.patternProperties)\n        const ownPatterns = ownPatternKeys.map(k => new RegExp(k))\n        otherSubSchemas.forEach(function(other) {\n          const allOtherKeys = keys(other.properties)\n          const keysMatchingPattern = allOtherKeys.filter(k => ownPatterns.some(pk => pk.test(k)))\n          const additionalKeys = withoutArr(allOtherKeys, ownKeys, keysMatchingPattern)\n          additionalKeys.forEach(function(key) {\n            other.properties[key] = mergers.properties([\n              other.properties[key], subSchema.additionalProperties\n            ], key)\n          })\n        })\n      })\n\n      // remove disallowed patternProperties\n      values.forEach(function(subSchema) {\n        const otherSubSchemas = values.filter(s => s !== subSchema)\n        const ownPatternKeys = keys(subSchema.patternProperties)\n        if (subSchema.additionalProperties === false) {\n          otherSubSchemas.forEach(function(other) {\n            const allOtherPatterns = keys(other.patternProperties)\n            const additionalPatternKeys = withoutArr(allOtherPatterns, ownPatternKeys)\n            additionalPatternKeys.forEach(key => delete other.patternProperties[key])\n          })\n        }\n      })\n    }\n\n    const returnObject = {\n      additionalProperties: mergers.additionalProperties(values.map(s => s.additionalProperties)),\n      patternProperties: mergeSchemaGroup(values.map(s => s.patternProperties), mergers.patternProperties),\n      properties: mergeSchemaGroup(values.map(s => s.properties), mergers.properties)\n    }\n\n    if (returnObject.additionalProperties === false) {\n      removeFalseSchemas(returnObject.properties)\n    }\n\n    return deleteUndefinedProps(returnObject)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}