{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst dataType_1 = require(\"../../compile/validate/dataType\");\n\nconst codegen_1 = require(\"../../compile/codegen\");\n\nconst util_1 = require(\"../../compile/util\");\n\nconst equal_1 = require(\"../../runtime/equal\");\n\nconst error = {\n  message: _ref => {\n    let {\n      params: {\n        i,\n        j\n      }\n    } = _ref;\n    return (0, codegen_1.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`;\n  },\n  params: _ref2 => {\n    let {\n      params: {\n        i,\n        j\n      }\n    } = _ref2;\n    return (0, codegen_1._)`{i: ${i}, j: ${j}}`;\n  }\n};\nconst def = {\n  keyword: \"uniqueItems\",\n  type: \"array\",\n  schemaType: \"boolean\",\n  $data: true,\n  error,\n\n  code(cxt) {\n    const {\n      gen,\n      data,\n      $data,\n      schema,\n      parentSchema,\n      schemaCode,\n      it\n    } = cxt;\n    if (!$data && !schema) return;\n    const valid = gen.let(\"valid\");\n    const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];\n    cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`);\n    cxt.ok(valid);\n\n    function validateUniqueItems() {\n      const i = gen.let(\"i\", (0, codegen_1._)`${data}.length`);\n      const j = gen.let(\"j\");\n      cxt.setParams({\n        i,\n        j\n      });\n      gen.assign(valid, true);\n      gen.if((0, codegen_1._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));\n    }\n\n    function canOptimize() {\n      return itemTypes.length > 0 && !itemTypes.some(t => t === \"object\" || t === \"array\");\n    }\n\n    function loopN(i, j) {\n      const item = gen.name(\"item\");\n      const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);\n      const indices = gen.const(\"indices\", (0, codegen_1._)`{}`);\n      gen.for((0, codegen_1._)`;${i}--;`, () => {\n        gen.let(item, (0, codegen_1._)`${data}[${i}]`);\n        gen.if(wrongType, (0, codegen_1._)`continue`);\n        if (itemTypes.length > 1) gen.if((0, codegen_1._)`typeof ${item} == \"string\"`, (0, codegen_1._)`${item} += \"_\"`);\n        gen.if((0, codegen_1._)`typeof ${indices}[${item}] == \"number\"`, () => {\n          gen.assign(j, (0, codegen_1._)`${indices}[${item}]`);\n          cxt.error();\n          gen.assign(valid, false).break();\n        }).code((0, codegen_1._)`${indices}[${item}] = ${i}`);\n      });\n    }\n\n    function loopN2(i, j) {\n      const eql = (0, util_1.useFunc)(gen, equal_1.default);\n      const outer = gen.name(\"outer\");\n      gen.label(outer).for((0, codegen_1._)`;${i}--;`, () => gen.for((0, codegen_1._)`${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._)`${eql}(${data}[${i}], ${data}[${j}])`, () => {\n        cxt.error();\n        gen.assign(valid, false).break(outer);\n      })));\n    }\n  }\n\n};\nexports.default = def;","map":{"version":3,"sources":["../../../lib/vocabularies/validation/uniqueItems.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst dataType_1 = require(\"../../compile/validate/dataType\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst equal_1 = require(\"../../runtime/equal\");\nconst error = {\n    message: ({ params: { i, j } }) => (0, codegen_1.str) `must NOT have duplicate items (items ## ${j} and ${i} are identical)`,\n    params: ({ params: { i, j } }) => (0, codegen_1._) `{i: ${i}, j: ${j}}`,\n};\nconst def = {\n    keyword: \"uniqueItems\",\n    type: \"array\",\n    schemaType: \"boolean\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;\n        if (!$data && !schema)\n            return;\n        const valid = gen.let(\"valid\");\n        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];\n        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._) `${schemaCode} === false`);\n        cxt.ok(valid);\n        function validateUniqueItems() {\n            const i = gen.let(\"i\", (0, codegen_1._) `${data}.length`);\n            const j = gen.let(\"j\");\n            cxt.setParams({ i, j });\n            gen.assign(valid, true);\n            gen.if((0, codegen_1._) `${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));\n        }\n        function canOptimize() {\n            return itemTypes.length > 0 && !itemTypes.some((t) => t === \"object\" || t === \"array\");\n        }\n        function loopN(i, j) {\n            const item = gen.name(\"item\");\n            const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);\n            const indices = gen.const(\"indices\", (0, codegen_1._) `{}`);\n            gen.for((0, codegen_1._) `;${i}--;`, () => {\n                gen.let(item, (0, codegen_1._) `${data}[${i}]`);\n                gen.if(wrongType, (0, codegen_1._) `continue`);\n                if (itemTypes.length > 1)\n                    gen.if((0, codegen_1._) `typeof ${item} == \"string\"`, (0, codegen_1._) `${item} += \"_\"`);\n                gen\n                    .if((0, codegen_1._) `typeof ${indices}[${item}] == \"number\"`, () => {\n                    gen.assign(j, (0, codegen_1._) `${indices}[${item}]`);\n                    cxt.error();\n                    gen.assign(valid, false).break();\n                })\n                    .code((0, codegen_1._) `${indices}[${item}] = ${i}`);\n            });\n        }\n        function loopN2(i, j) {\n            const eql = (0, util_1.useFunc)(gen, equal_1.default);\n            const outer = gen.name(\"outer\");\n            gen.label(outer).for((0, codegen_1._) `;${i}--;`, () => gen.for((0, codegen_1._) `${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._) `${eql}(${data}[${i}], ${data}[${j}])`, () => {\n                cxt.error();\n                gen.assign(valid, false).break(outer);\n            })));\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=uniqueItems.js.map"]},"metadata":{},"sourceType":"script"}