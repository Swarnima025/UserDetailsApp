{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.formatLimitDefinition = void 0;\n\nconst ajv_1 = require(\"ajv\");\n\nconst codegen_1 = require(\"ajv/dist/compile/codegen\");\n\nconst ops = codegen_1.operators;\nconst KWDs = {\n  formatMaximum: {\n    okStr: \"<=\",\n    ok: ops.LTE,\n    fail: ops.GT\n  },\n  formatMinimum: {\n    okStr: \">=\",\n    ok: ops.GTE,\n    fail: ops.LT\n  },\n  formatExclusiveMaximum: {\n    okStr: \"<\",\n    ok: ops.LT,\n    fail: ops.GTE\n  },\n  formatExclusiveMinimum: {\n    okStr: \">\",\n    ok: ops.GT,\n    fail: ops.LTE\n  }\n};\nconst error = {\n  message: _ref => {\n    let {\n      keyword,\n      schemaCode\n    } = _ref;\n    return codegen_1.str`should be ${KWDs[keyword].okStr} ${schemaCode}`;\n  },\n  params: _ref2 => {\n    let {\n      keyword,\n      schemaCode\n    } = _ref2;\n    return codegen_1._`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`;\n  }\n};\nexports.formatLimitDefinition = {\n  keyword: Object.keys(KWDs),\n  type: \"string\",\n  schemaType: \"string\",\n  $data: true,\n  error,\n\n  code(cxt) {\n    const {\n      gen,\n      data,\n      schemaCode,\n      keyword,\n      it\n    } = cxt;\n    const {\n      opts,\n      self\n    } = it;\n    if (!opts.validateFormats) return;\n    const fCxt = new ajv_1.KeywordCxt(it, self.RULES.all.format.definition, \"format\");\n    if (fCxt.$data) validate$DataFormat();else validateFormat();\n\n    function validate$DataFormat() {\n      const fmts = gen.scopeValue(\"formats\", {\n        ref: self.formats,\n        code: opts.code.formats\n      });\n      const fmt = gen.const(\"fmt\", codegen_1._`${fmts}[${fCxt.schemaCode}]`);\n      cxt.fail$data(codegen_1.or(codegen_1._`typeof ${fmt} != \"object\"`, codegen_1._`${fmt} instanceof RegExp`, codegen_1._`typeof ${fmt}.compare != \"function\"`, compareCode(fmt)));\n    }\n\n    function validateFormat() {\n      const format = fCxt.schema;\n      const fmtDef = self.formats[format];\n      if (!fmtDef || fmtDef === true) return;\n\n      if (typeof fmtDef != \"object\" || fmtDef instanceof RegExp || typeof fmtDef.compare != \"function\") {\n        throw new Error(`\"${keyword}\": format \"${format}\" does not define \"compare\" function`);\n      }\n\n      const fmt = gen.scopeValue(\"formats\", {\n        key: format,\n        ref: fmtDef,\n        code: opts.code.formats ? codegen_1._`${opts.code.formats}${codegen_1.getProperty(format)}` : undefined\n      });\n      cxt.fail$data(compareCode(fmt));\n    }\n\n    function compareCode(fmt) {\n      return codegen_1._`${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword].fail} 0`;\n    }\n  },\n\n  dependencies: [\"format\"]\n};\n\nconst formatLimitPlugin = ajv => {\n  ajv.addKeyword(exports.formatLimitDefinition);\n  return ajv;\n};\n\nexports.default = formatLimitPlugin;","map":{"version":3,"sources":["../src/limit.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.formatLimitDefinition = void 0;\nconst ajv_1 = require(\"ajv\");\nconst codegen_1 = require(\"ajv/dist/compile/codegen\");\nconst ops = codegen_1.operators;\nconst KWDs = {\n    formatMaximum: { okStr: \"<=\", ok: ops.LTE, fail: ops.GT },\n    formatMinimum: { okStr: \">=\", ok: ops.GTE, fail: ops.LT },\n    formatExclusiveMaximum: { okStr: \"<\", ok: ops.LT, fail: ops.GTE },\n    formatExclusiveMinimum: { okStr: \">\", ok: ops.GT, fail: ops.LTE },\n};\nconst error = {\n    message: ({ keyword, schemaCode }) => codegen_1.str `should be ${KWDs[keyword].okStr} ${schemaCode}`,\n    params: ({ keyword, schemaCode }) => codegen_1._ `{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`,\n};\nexports.formatLimitDefinition = {\n    keyword: Object.keys(KWDs),\n    type: \"string\",\n    schemaType: \"string\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, schemaCode, keyword, it } = cxt;\n        const { opts, self } = it;\n        if (!opts.validateFormats)\n            return;\n        const fCxt = new ajv_1.KeywordCxt(it, self.RULES.all.format.definition, \"format\");\n        if (fCxt.$data)\n            validate$DataFormat();\n        else\n            validateFormat();\n        function validate$DataFormat() {\n            const fmts = gen.scopeValue(\"formats\", {\n                ref: self.formats,\n                code: opts.code.formats,\n            });\n            const fmt = gen.const(\"fmt\", codegen_1._ `${fmts}[${fCxt.schemaCode}]`);\n            cxt.fail$data(codegen_1.or(codegen_1._ `typeof ${fmt} != \"object\"`, codegen_1._ `${fmt} instanceof RegExp`, codegen_1._ `typeof ${fmt}.compare != \"function\"`, compareCode(fmt)));\n        }\n        function validateFormat() {\n            const format = fCxt.schema;\n            const fmtDef = self.formats[format];\n            if (!fmtDef || fmtDef === true)\n                return;\n            if (typeof fmtDef != \"object\" ||\n                fmtDef instanceof RegExp ||\n                typeof fmtDef.compare != \"function\") {\n                throw new Error(`\"${keyword}\": format \"${format}\" does not define \"compare\" function`);\n            }\n            const fmt = gen.scopeValue(\"formats\", {\n                key: format,\n                ref: fmtDef,\n                code: opts.code.formats ? codegen_1._ `${opts.code.formats}${codegen_1.getProperty(format)}` : undefined,\n            });\n            cxt.fail$data(compareCode(fmt));\n        }\n        function compareCode(fmt) {\n            return codegen_1._ `${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword].fail} 0`;\n        }\n    },\n    dependencies: [\"format\"],\n};\nconst formatLimitPlugin = (ajv) => {\n    ajv.addKeyword(exports.formatLimitDefinition);\n    return ajv;\n};\nexports.default = formatLimitPlugin;\n//# sourceMappingURL=limit.js.map"]},"metadata":{},"sourceType":"script"}