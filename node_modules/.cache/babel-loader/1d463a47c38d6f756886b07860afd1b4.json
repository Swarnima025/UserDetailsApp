{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = void 0;\n\nconst codegen_1 = require(\"./codegen\");\n\nconst validation_error_1 = require(\"../runtime/validation_error\");\n\nconst names_1 = require(\"./names\");\n\nconst resolve_1 = require(\"./resolve\");\n\nconst util_1 = require(\"./util\");\n\nconst validate_1 = require(\"./validate\");\n\nclass SchemaEnv {\n  constructor(env) {\n    var _a;\n\n    this.refs = {};\n    this.dynamicAnchors = {};\n    let schema;\n    if (typeof env.schema == \"object\") schema = env.schema;\n    this.schema = env.schema;\n    this.schemaId = env.schemaId;\n    this.root = env.root || this;\n    this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || \"$id\"]);\n    this.schemaPath = env.schemaPath;\n    this.localRefs = env.localRefs;\n    this.meta = env.meta;\n    this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;\n    this.refs = {};\n  }\n\n}\n\nexports.SchemaEnv = SchemaEnv; // let codeSize = 0\n// let nodeCount = 0\n// Compiles schema in SchemaEnv\n\nfunction compileSchema(sch) {\n  // TODO refactor - remove compilations\n  const _sch = getCompilingSchema.call(this, sch);\n\n  if (_sch) return _sch;\n  const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId); // TODO if getFullPath removed 1 tests fails\n\n  const {\n    es5,\n    lines\n  } = this.opts.code;\n  const {\n    ownProperties\n  } = this.opts;\n  const gen = new codegen_1.CodeGen(this.scope, {\n    es5,\n    lines,\n    ownProperties\n  });\n\n  let _ValidationError;\n\n  if (sch.$async) {\n    _ValidationError = gen.scopeValue(\"Error\", {\n      ref: validation_error_1.default,\n      code: (0, codegen_1._)`require(\"ajv/dist/runtime/validation_error\").default`\n    });\n  }\n\n  const validateName = gen.scopeName(\"validate\");\n  sch.validateName = validateName;\n  const schemaCxt = {\n    gen,\n    allErrors: this.opts.allErrors,\n    data: names_1.default.data,\n    parentData: names_1.default.parentData,\n    parentDataProperty: names_1.default.parentDataProperty,\n    dataNames: [names_1.default.data],\n    dataPathArr: [codegen_1.nil],\n    dataLevel: 0,\n    dataTypes: [],\n    definedProperties: new Set(),\n    topSchemaRef: gen.scopeValue(\"schema\", this.opts.code.source === true ? {\n      ref: sch.schema,\n      code: (0, codegen_1.stringify)(sch.schema)\n    } : {\n      ref: sch.schema\n    }),\n    validateName,\n    ValidationError: _ValidationError,\n    schema: sch.schema,\n    schemaEnv: sch,\n    rootId,\n    baseId: sch.baseId || rootId,\n    schemaPath: codegen_1.nil,\n    errSchemaPath: sch.schemaPath || (this.opts.jtd ? \"\" : \"#\"),\n    errorPath: (0, codegen_1._)`\"\"`,\n    opts: this.opts,\n    self: this\n  };\n  let sourceCode;\n\n  try {\n    this._compilations.add(sch);\n\n    (0, validate_1.validateFunctionCode)(schemaCxt);\n    gen.optimize(this.opts.code.optimize); // gen.optimize(1)\n\n    const validateCode = gen.toString();\n    sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`; // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))\n\n    if (this.opts.code.process) sourceCode = this.opts.code.process(sourceCode, sch); // console.log(\"\\n\\n\\n *** \\n\", sourceCode)\n\n    const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);\n    const validate = makeValidate(this, this.scope.get());\n    this.scope.value(validateName, {\n      ref: validate\n    });\n    validate.errors = null;\n    validate.schema = sch.schema;\n    validate.schemaEnv = sch;\n    if (sch.$async) validate.$async = true;\n\n    if (this.opts.code.source === true) {\n      validate.source = {\n        validateName,\n        validateCode,\n        scopeValues: gen._values\n      };\n    }\n\n    if (this.opts.unevaluated) {\n      const {\n        props,\n        items\n      } = schemaCxt;\n      validate.evaluated = {\n        props: props instanceof codegen_1.Name ? undefined : props,\n        items: items instanceof codegen_1.Name ? undefined : items,\n        dynamicProps: props instanceof codegen_1.Name,\n        dynamicItems: items instanceof codegen_1.Name\n      };\n      if (validate.source) validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);\n    }\n\n    sch.validate = validate;\n    return sch;\n  } catch (e) {\n    delete sch.validate;\n    delete sch.validateName;\n    if (sourceCode) this.logger.error(\"Error compiling schema, function code:\", sourceCode); // console.log(\"\\n\\n\\n *** \\n\", sourceCode, this.opts)\n\n    throw e;\n  } finally {\n    this._compilations.delete(sch);\n  }\n}\n\nexports.compileSchema = compileSchema;\n\nfunction resolveRef(root, baseId, ref) {\n  var _a;\n\n  ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);\n  const schOrFunc = root.refs[ref];\n  if (schOrFunc) return schOrFunc;\n\n  let _sch = resolve.call(this, root, ref);\n\n  if (_sch === undefined) {\n    const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref]; // TODO maybe localRefs should hold SchemaEnv\n\n    const {\n      schemaId\n    } = this.opts;\n    if (schema) _sch = new SchemaEnv({\n      schema,\n      schemaId,\n      root,\n      baseId\n    });\n  }\n\n  if (_sch === undefined) return;\n  return root.refs[ref] = inlineOrCompile.call(this, _sch);\n}\n\nexports.resolveRef = resolveRef;\n\nfunction inlineOrCompile(sch) {\n  if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs)) return sch.schema;\n  return sch.validate ? sch : compileSchema.call(this, sch);\n} // Index of schema compilation in the currently compiled list\n\n\nfunction getCompilingSchema(schEnv) {\n  for (const sch of this._compilations) {\n    if (sameSchemaEnv(sch, schEnv)) return sch;\n  }\n}\n\nexports.getCompilingSchema = getCompilingSchema;\n\nfunction sameSchemaEnv(s1, s2) {\n  return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;\n} // resolve and compile the references ($ref)\n// TODO returns AnySchemaObject (if the schema can be inlined) or validation function\n\n\nfunction resolve(root, // information about the root schema for the current schema\nref // reference to resolve\n) {\n  let sch;\n\n  while (typeof (sch = this.refs[ref]) == \"string\") ref = sch;\n\n  return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);\n} // Resolve schema, its root and baseId\n\n\nfunction resolveSchema(root, // root object with properties schema, refs TODO below SchemaEnv is assigned to it\nref // reference to resolve\n) {\n  const p = this.opts.uriResolver.parse(ref);\n  const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);\n  let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, undefined); // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests\n\n  if (Object.keys(root.schema).length > 0 && refPath === baseId) {\n    return getJsonPointer.call(this, p, root);\n  }\n\n  const id = (0, resolve_1.normalizeId)(refPath);\n  const schOrRef = this.refs[id] || this.schemas[id];\n\n  if (typeof schOrRef == \"string\") {\n    const sch = resolveSchema.call(this, root, schOrRef);\n    if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== \"object\") return;\n    return getJsonPointer.call(this, p, sch);\n  }\n\n  if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== \"object\") return;\n  if (!schOrRef.validate) compileSchema.call(this, schOrRef);\n\n  if (id === (0, resolve_1.normalizeId)(ref)) {\n    const {\n      schema\n    } = schOrRef;\n    const {\n      schemaId\n    } = this.opts;\n    const schId = schema[schemaId];\n    if (schId) baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);\n    return new SchemaEnv({\n      schema,\n      schemaId,\n      root,\n      baseId\n    });\n  }\n\n  return getJsonPointer.call(this, p, schOrRef);\n}\n\nexports.resolveSchema = resolveSchema;\nconst PREVENT_SCOPE_CHANGE = new Set([\"properties\", \"patternProperties\", \"enum\", \"dependencies\", \"definitions\"]);\n\nfunction getJsonPointer(parsedRef, _ref) {\n  let {\n    baseId,\n    schema,\n    root\n  } = _ref;\n\n  var _a;\n\n  if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== \"/\") return;\n\n  for (const part of parsedRef.fragment.slice(1).split(\"/\")) {\n    if (typeof schema === \"boolean\") return;\n    const partSchema = schema[(0, util_1.unescapeFragment)(part)];\n    if (partSchema === undefined) return;\n    schema = partSchema; // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?\n\n    const schId = typeof schema === \"object\" && schema[this.opts.schemaId];\n\n    if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {\n      baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);\n    }\n  }\n\n  let env;\n\n  if (typeof schema != \"boolean\" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {\n    const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);\n    env = resolveSchema.call(this, root, $ref);\n  } // even though resolution failed we need to return SchemaEnv to throw exception\n  // so that compileAsync loads missing schema.\n\n\n  const {\n    schemaId\n  } = this.opts;\n  env = env || new SchemaEnv({\n    schema,\n    schemaId,\n    root,\n    baseId\n  });\n  if (env.schema !== env.root.schema) return env;\n  return undefined;\n}","map":{"version":3,"sources":["../../lib/compile/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = void 0;\nconst codegen_1 = require(\"./codegen\");\nconst validation_error_1 = require(\"../runtime/validation_error\");\nconst names_1 = require(\"./names\");\nconst resolve_1 = require(\"./resolve\");\nconst util_1 = require(\"./util\");\nconst validate_1 = require(\"./validate\");\nclass SchemaEnv {\n    constructor(env) {\n        var _a;\n        this.refs = {};\n        this.dynamicAnchors = {};\n        let schema;\n        if (typeof env.schema == \"object\")\n            schema = env.schema;\n        this.schema = env.schema;\n        this.schemaId = env.schemaId;\n        this.root = env.root || this;\n        this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || \"$id\"]);\n        this.schemaPath = env.schemaPath;\n        this.localRefs = env.localRefs;\n        this.meta = env.meta;\n        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;\n        this.refs = {};\n    }\n}\nexports.SchemaEnv = SchemaEnv;\n// let codeSize = 0\n// let nodeCount = 0\n// Compiles schema in SchemaEnv\nfunction compileSchema(sch) {\n    // TODO refactor - remove compilations\n    const _sch = getCompilingSchema.call(this, sch);\n    if (_sch)\n        return _sch;\n    const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId); // TODO if getFullPath removed 1 tests fails\n    const { es5, lines } = this.opts.code;\n    const { ownProperties } = this.opts;\n    const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });\n    let _ValidationError;\n    if (sch.$async) {\n        _ValidationError = gen.scopeValue(\"Error\", {\n            ref: validation_error_1.default,\n            code: (0, codegen_1._) `require(\"ajv/dist/runtime/validation_error\").default`,\n        });\n    }\n    const validateName = gen.scopeName(\"validate\");\n    sch.validateName = validateName;\n    const schemaCxt = {\n        gen,\n        allErrors: this.opts.allErrors,\n        data: names_1.default.data,\n        parentData: names_1.default.parentData,\n        parentDataProperty: names_1.default.parentDataProperty,\n        dataNames: [names_1.default.data],\n        dataPathArr: [codegen_1.nil],\n        dataLevel: 0,\n        dataTypes: [],\n        definedProperties: new Set(),\n        topSchemaRef: gen.scopeValue(\"schema\", this.opts.code.source === true\n            ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) }\n            : { ref: sch.schema }),\n        validateName,\n        ValidationError: _ValidationError,\n        schema: sch.schema,\n        schemaEnv: sch,\n        rootId,\n        baseId: sch.baseId || rootId,\n        schemaPath: codegen_1.nil,\n        errSchemaPath: sch.schemaPath || (this.opts.jtd ? \"\" : \"#\"),\n        errorPath: (0, codegen_1._) `\"\"`,\n        opts: this.opts,\n        self: this,\n    };\n    let sourceCode;\n    try {\n        this._compilations.add(sch);\n        (0, validate_1.validateFunctionCode)(schemaCxt);\n        gen.optimize(this.opts.code.optimize);\n        // gen.optimize(1)\n        const validateCode = gen.toString();\n        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;\n        // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))\n        if (this.opts.code.process)\n            sourceCode = this.opts.code.process(sourceCode, sch);\n        // console.log(\"\\n\\n\\n *** \\n\", sourceCode)\n        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);\n        const validate = makeValidate(this, this.scope.get());\n        this.scope.value(validateName, { ref: validate });\n        validate.errors = null;\n        validate.schema = sch.schema;\n        validate.schemaEnv = sch;\n        if (sch.$async)\n            validate.$async = true;\n        if (this.opts.code.source === true) {\n            validate.source = { validateName, validateCode, scopeValues: gen._values };\n        }\n        if (this.opts.unevaluated) {\n            const { props, items } = schemaCxt;\n            validate.evaluated = {\n                props: props instanceof codegen_1.Name ? undefined : props,\n                items: items instanceof codegen_1.Name ? undefined : items,\n                dynamicProps: props instanceof codegen_1.Name,\n                dynamicItems: items instanceof codegen_1.Name,\n            };\n            if (validate.source)\n                validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);\n        }\n        sch.validate = validate;\n        return sch;\n    }\n    catch (e) {\n        delete sch.validate;\n        delete sch.validateName;\n        if (sourceCode)\n            this.logger.error(\"Error compiling schema, function code:\", sourceCode);\n        // console.log(\"\\n\\n\\n *** \\n\", sourceCode, this.opts)\n        throw e;\n    }\n    finally {\n        this._compilations.delete(sch);\n    }\n}\nexports.compileSchema = compileSchema;\nfunction resolveRef(root, baseId, ref) {\n    var _a;\n    ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);\n    const schOrFunc = root.refs[ref];\n    if (schOrFunc)\n        return schOrFunc;\n    let _sch = resolve.call(this, root, ref);\n    if (_sch === undefined) {\n        const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref]; // TODO maybe localRefs should hold SchemaEnv\n        const { schemaId } = this.opts;\n        if (schema)\n            _sch = new SchemaEnv({ schema, schemaId, root, baseId });\n    }\n    if (_sch === undefined)\n        return;\n    return (root.refs[ref] = inlineOrCompile.call(this, _sch));\n}\nexports.resolveRef = resolveRef;\nfunction inlineOrCompile(sch) {\n    if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))\n        return sch.schema;\n    return sch.validate ? sch : compileSchema.call(this, sch);\n}\n// Index of schema compilation in the currently compiled list\nfunction getCompilingSchema(schEnv) {\n    for (const sch of this._compilations) {\n        if (sameSchemaEnv(sch, schEnv))\n            return sch;\n    }\n}\nexports.getCompilingSchema = getCompilingSchema;\nfunction sameSchemaEnv(s1, s2) {\n    return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;\n}\n// resolve and compile the references ($ref)\n// TODO returns AnySchemaObject (if the schema can be inlined) or validation function\nfunction resolve(root, // information about the root schema for the current schema\nref // reference to resolve\n) {\n    let sch;\n    while (typeof (sch = this.refs[ref]) == \"string\")\n        ref = sch;\n    return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);\n}\n// Resolve schema, its root and baseId\nfunction resolveSchema(root, // root object with properties schema, refs TODO below SchemaEnv is assigned to it\nref // reference to resolve\n) {\n    const p = this.opts.uriResolver.parse(ref);\n    const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);\n    let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, undefined);\n    // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests\n    if (Object.keys(root.schema).length > 0 && refPath === baseId) {\n        return getJsonPointer.call(this, p, root);\n    }\n    const id = (0, resolve_1.normalizeId)(refPath);\n    const schOrRef = this.refs[id] || this.schemas[id];\n    if (typeof schOrRef == \"string\") {\n        const sch = resolveSchema.call(this, root, schOrRef);\n        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== \"object\")\n            return;\n        return getJsonPointer.call(this, p, sch);\n    }\n    if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== \"object\")\n        return;\n    if (!schOrRef.validate)\n        compileSchema.call(this, schOrRef);\n    if (id === (0, resolve_1.normalizeId)(ref)) {\n        const { schema } = schOrRef;\n        const { schemaId } = this.opts;\n        const schId = schema[schemaId];\n        if (schId)\n            baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);\n        return new SchemaEnv({ schema, schemaId, root, baseId });\n    }\n    return getJsonPointer.call(this, p, schOrRef);\n}\nexports.resolveSchema = resolveSchema;\nconst PREVENT_SCOPE_CHANGE = new Set([\n    \"properties\",\n    \"patternProperties\",\n    \"enum\",\n    \"dependencies\",\n    \"definitions\",\n]);\nfunction getJsonPointer(parsedRef, { baseId, schema, root }) {\n    var _a;\n    if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== \"/\")\n        return;\n    for (const part of parsedRef.fragment.slice(1).split(\"/\")) {\n        if (typeof schema === \"boolean\")\n            return;\n        const partSchema = schema[(0, util_1.unescapeFragment)(part)];\n        if (partSchema === undefined)\n            return;\n        schema = partSchema;\n        // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?\n        const schId = typeof schema === \"object\" && schema[this.opts.schemaId];\n        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {\n            baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);\n        }\n    }\n    let env;\n    if (typeof schema != \"boolean\" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {\n        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);\n        env = resolveSchema.call(this, root, $ref);\n    }\n    // even though resolution failed we need to return SchemaEnv to throw exception\n    // so that compileAsync loads missing schema.\n    const { schemaId } = this.opts;\n    env = env || new SchemaEnv({ schema, schemaId, root, baseId });\n    if (env.schema !== env.root.schema)\n        return env;\n    return undefined;\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}