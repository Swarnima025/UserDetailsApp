{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;\n\nconst code_1 = require(\"./code\");\n\nconst scope_1 = require(\"./scope\");\n\nvar code_2 = require(\"./code\");\n\nObject.defineProperty(exports, \"_\", {\n  enumerable: true,\n  get: function () {\n    return code_2._;\n  }\n});\nObject.defineProperty(exports, \"str\", {\n  enumerable: true,\n  get: function () {\n    return code_2.str;\n  }\n});\nObject.defineProperty(exports, \"strConcat\", {\n  enumerable: true,\n  get: function () {\n    return code_2.strConcat;\n  }\n});\nObject.defineProperty(exports, \"nil\", {\n  enumerable: true,\n  get: function () {\n    return code_2.nil;\n  }\n});\nObject.defineProperty(exports, \"getProperty\", {\n  enumerable: true,\n  get: function () {\n    return code_2.getProperty;\n  }\n});\nObject.defineProperty(exports, \"stringify\", {\n  enumerable: true,\n  get: function () {\n    return code_2.stringify;\n  }\n});\nObject.defineProperty(exports, \"regexpCode\", {\n  enumerable: true,\n  get: function () {\n    return code_2.regexpCode;\n  }\n});\nObject.defineProperty(exports, \"Name\", {\n  enumerable: true,\n  get: function () {\n    return code_2.Name;\n  }\n});\n\nvar scope_2 = require(\"./scope\");\n\nObject.defineProperty(exports, \"Scope\", {\n  enumerable: true,\n  get: function () {\n    return scope_2.Scope;\n  }\n});\nObject.defineProperty(exports, \"ValueScope\", {\n  enumerable: true,\n  get: function () {\n    return scope_2.ValueScope;\n  }\n});\nObject.defineProperty(exports, \"ValueScopeName\", {\n  enumerable: true,\n  get: function () {\n    return scope_2.ValueScopeName;\n  }\n});\nObject.defineProperty(exports, \"varKinds\", {\n  enumerable: true,\n  get: function () {\n    return scope_2.varKinds;\n  }\n});\nexports.operators = {\n  GT: new code_1._Code(\">\"),\n  GTE: new code_1._Code(\">=\"),\n  LT: new code_1._Code(\"<\"),\n  LTE: new code_1._Code(\"<=\"),\n  EQ: new code_1._Code(\"===\"),\n  NEQ: new code_1._Code(\"!==\"),\n  NOT: new code_1._Code(\"!\"),\n  OR: new code_1._Code(\"||\"),\n  AND: new code_1._Code(\"&&\"),\n  ADD: new code_1._Code(\"+\")\n};\n\nclass Node {\n  optimizeNodes() {\n    return this;\n  }\n\n  optimizeNames(_names, _constants) {\n    return this;\n  }\n\n}\n\nclass Def extends Node {\n  constructor(varKind, name, rhs) {\n    super();\n    this.varKind = varKind;\n    this.name = name;\n    this.rhs = rhs;\n  }\n\n  render(_ref) {\n    let {\n      es5,\n      _n\n    } = _ref;\n    const varKind = es5 ? scope_1.varKinds.var : this.varKind;\n    const rhs = this.rhs === undefined ? \"\" : ` = ${this.rhs}`;\n    return `${varKind} ${this.name}${rhs};` + _n;\n  }\n\n  optimizeNames(names, constants) {\n    if (!names[this.name.str]) return;\n    if (this.rhs) this.rhs = optimizeExpr(this.rhs, names, constants);\n    return this;\n  }\n\n  get names() {\n    return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};\n  }\n\n}\n\nclass Assign extends Node {\n  constructor(lhs, rhs, sideEffects) {\n    super();\n    this.lhs = lhs;\n    this.rhs = rhs;\n    this.sideEffects = sideEffects;\n  }\n\n  render(_ref2) {\n    let {\n      _n\n    } = _ref2;\n    return `${this.lhs} = ${this.rhs};` + _n;\n  }\n\n  optimizeNames(names, constants) {\n    if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects) return;\n    this.rhs = optimizeExpr(this.rhs, names, constants);\n    return this;\n  }\n\n  get names() {\n    const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names\n    };\n    return addExprNames(names, this.rhs);\n  }\n\n}\n\nclass AssignOp extends Assign {\n  constructor(lhs, op, rhs, sideEffects) {\n    super(lhs, rhs, sideEffects);\n    this.op = op;\n  }\n\n  render(_ref3) {\n    let {\n      _n\n    } = _ref3;\n    return `${this.lhs} ${this.op}= ${this.rhs};` + _n;\n  }\n\n}\n\nclass Label extends Node {\n  constructor(label) {\n    super();\n    this.label = label;\n    this.names = {};\n  }\n\n  render(_ref4) {\n    let {\n      _n\n    } = _ref4;\n    return `${this.label}:` + _n;\n  }\n\n}\n\nclass Break extends Node {\n  constructor(label) {\n    super();\n    this.label = label;\n    this.names = {};\n  }\n\n  render(_ref5) {\n    let {\n      _n\n    } = _ref5;\n    const label = this.label ? ` ${this.label}` : \"\";\n    return `break${label};` + _n;\n  }\n\n}\n\nclass Throw extends Node {\n  constructor(error) {\n    super();\n    this.error = error;\n  }\n\n  render(_ref6) {\n    let {\n      _n\n    } = _ref6;\n    return `throw ${this.error};` + _n;\n  }\n\n  get names() {\n    return this.error.names;\n  }\n\n}\n\nclass AnyCode extends Node {\n  constructor(code) {\n    super();\n    this.code = code;\n  }\n\n  render(_ref7) {\n    let {\n      _n\n    } = _ref7;\n    return `${this.code};` + _n;\n  }\n\n  optimizeNodes() {\n    return `${this.code}` ? this : undefined;\n  }\n\n  optimizeNames(names, constants) {\n    this.code = optimizeExpr(this.code, names, constants);\n    return this;\n  }\n\n  get names() {\n    return this.code instanceof code_1._CodeOrName ? this.code.names : {};\n  }\n\n}\n\nclass ParentNode extends Node {\n  constructor() {\n    let nodes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    super();\n    this.nodes = nodes;\n  }\n\n  render(opts) {\n    return this.nodes.reduce((code, n) => code + n.render(opts), \"\");\n  }\n\n  optimizeNodes() {\n    const {\n      nodes\n    } = this;\n    let i = nodes.length;\n\n    while (i--) {\n      const n = nodes[i].optimizeNodes();\n      if (Array.isArray(n)) nodes.splice(i, 1, ...n);else if (n) nodes[i] = n;else nodes.splice(i, 1);\n    }\n\n    return nodes.length > 0 ? this : undefined;\n  }\n\n  optimizeNames(names, constants) {\n    const {\n      nodes\n    } = this;\n    let i = nodes.length;\n\n    while (i--) {\n      // iterating backwards improves 1-pass optimization\n      const n = nodes[i];\n      if (n.optimizeNames(names, constants)) continue;\n      subtractNames(names, n.names);\n      nodes.splice(i, 1);\n    }\n\n    return nodes.length > 0 ? this : undefined;\n  }\n\n  get names() {\n    return this.nodes.reduce((names, n) => addNames(names, n.names), {});\n  }\n\n}\n\nclass BlockNode extends ParentNode {\n  render(opts) {\n    return \"{\" + opts._n + super.render(opts) + \"}\" + opts._n;\n  }\n\n}\n\nclass Root extends ParentNode {}\n\nclass Else extends BlockNode {}\n\nElse.kind = \"else\";\n\nclass If extends BlockNode {\n  constructor(condition, nodes) {\n    super(nodes);\n    this.condition = condition;\n  }\n\n  render(opts) {\n    let code = `if(${this.condition})` + super.render(opts);\n    if (this.else) code += \"else \" + this.else.render(opts);\n    return code;\n  }\n\n  optimizeNodes() {\n    super.optimizeNodes();\n    const cond = this.condition;\n    if (cond === true) return this.nodes; // else is ignored here\n\n    let e = this.else;\n\n    if (e) {\n      const ns = e.optimizeNodes();\n      e = this.else = Array.isArray(ns) ? new Else(ns) : ns;\n    }\n\n    if (e) {\n      if (cond === false) return e instanceof If ? e : e.nodes;\n      if (this.nodes.length) return this;\n      return new If(not(cond), e instanceof If ? [e] : e.nodes);\n    }\n\n    if (cond === false || !this.nodes.length) return undefined;\n    return this;\n  }\n\n  optimizeNames(names, constants) {\n    var _a;\n\n    this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);\n    if (!(super.optimizeNames(names, constants) || this.else)) return;\n    this.condition = optimizeExpr(this.condition, names, constants);\n    return this;\n  }\n\n  get names() {\n    const names = super.names;\n    addExprNames(names, this.condition);\n    if (this.else) addNames(names, this.else.names);\n    return names;\n  }\n\n}\n\nIf.kind = \"if\";\n\nclass For extends BlockNode {}\n\nFor.kind = \"for\";\n\nclass ForLoop extends For {\n  constructor(iteration) {\n    super();\n    this.iteration = iteration;\n  }\n\n  render(opts) {\n    return `for(${this.iteration})` + super.render(opts);\n  }\n\n  optimizeNames(names, constants) {\n    if (!super.optimizeNames(names, constants)) return;\n    this.iteration = optimizeExpr(this.iteration, names, constants);\n    return this;\n  }\n\n  get names() {\n    return addNames(super.names, this.iteration.names);\n  }\n\n}\n\nclass ForRange extends For {\n  constructor(varKind, name, from, to) {\n    super();\n    this.varKind = varKind;\n    this.name = name;\n    this.from = from;\n    this.to = to;\n  }\n\n  render(opts) {\n    const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;\n    const {\n      name,\n      from,\n      to\n    } = this;\n    return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);\n  }\n\n  get names() {\n    const names = addExprNames(super.names, this.from);\n    return addExprNames(names, this.to);\n  }\n\n}\n\nclass ForIter extends For {\n  constructor(loop, varKind, name, iterable) {\n    super();\n    this.loop = loop;\n    this.varKind = varKind;\n    this.name = name;\n    this.iterable = iterable;\n  }\n\n  render(opts) {\n    return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);\n  }\n\n  optimizeNames(names, constants) {\n    if (!super.optimizeNames(names, constants)) return;\n    this.iterable = optimizeExpr(this.iterable, names, constants);\n    return this;\n  }\n\n  get names() {\n    return addNames(super.names, this.iterable.names);\n  }\n\n}\n\nclass Func extends BlockNode {\n  constructor(name, args, async) {\n    super();\n    this.name = name;\n    this.args = args;\n    this.async = async;\n  }\n\n  render(opts) {\n    const _async = this.async ? \"async \" : \"\";\n\n    return `${_async}function ${this.name}(${this.args})` + super.render(opts);\n  }\n\n}\n\nFunc.kind = \"func\";\n\nclass Return extends ParentNode {\n  render(opts) {\n    return \"return \" + super.render(opts);\n  }\n\n}\n\nReturn.kind = \"return\";\n\nclass Try extends BlockNode {\n  render(opts) {\n    let code = \"try\" + super.render(opts);\n    if (this.catch) code += this.catch.render(opts);\n    if (this.finally) code += this.finally.render(opts);\n    return code;\n  }\n\n  optimizeNodes() {\n    var _a, _b;\n\n    super.optimizeNodes();\n    (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();\n    (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();\n    return this;\n  }\n\n  optimizeNames(names, constants) {\n    var _a, _b;\n\n    super.optimizeNames(names, constants);\n    (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);\n    (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);\n    return this;\n  }\n\n  get names() {\n    const names = super.names;\n    if (this.catch) addNames(names, this.catch.names);\n    if (this.finally) addNames(names, this.finally.names);\n    return names;\n  }\n\n}\n\nclass Catch extends BlockNode {\n  constructor(error) {\n    super();\n    this.error = error;\n  }\n\n  render(opts) {\n    return `catch(${this.error})` + super.render(opts);\n  }\n\n}\n\nCatch.kind = \"catch\";\n\nclass Finally extends BlockNode {\n  render(opts) {\n    return \"finally\" + super.render(opts);\n  }\n\n}\n\nFinally.kind = \"finally\";\n\nclass CodeGen {\n  constructor(extScope) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this._values = {};\n    this._blockStarts = [];\n    this._constants = {};\n    this.opts = { ...opts,\n      _n: opts.lines ? \"\\n\" : \"\"\n    };\n    this._extScope = extScope;\n    this._scope = new scope_1.Scope({\n      parent: extScope\n    });\n    this._nodes = [new Root()];\n  }\n\n  toString() {\n    return this._root.render(this.opts);\n  } // returns unique name in the internal scope\n\n\n  name(prefix) {\n    return this._scope.name(prefix);\n  } // reserves unique name in the external scope\n\n\n  scopeName(prefix) {\n    return this._extScope.name(prefix);\n  } // reserves unique name in the external scope and assigns value to it\n\n\n  scopeValue(prefixOrName, value) {\n    const name = this._extScope.value(prefixOrName, value);\n\n    const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set());\n    vs.add(name);\n    return name;\n  }\n\n  getScopeValue(prefix, keyOrRef) {\n    return this._extScope.getValue(prefix, keyOrRef);\n  } // return code that assigns values in the external scope to the names that are used internally\n  // (same names that were returned by gen.scopeName or gen.scopeValue)\n\n\n  scopeRefs(scopeName) {\n    return this._extScope.scopeRefs(scopeName, this._values);\n  }\n\n  scopeCode() {\n    return this._extScope.scopeCode(this._values);\n  }\n\n  _def(varKind, nameOrPrefix, rhs, constant) {\n    const name = this._scope.toName(nameOrPrefix);\n\n    if (rhs !== undefined && constant) this._constants[name.str] = rhs;\n\n    this._leafNode(new Def(varKind, name, rhs));\n\n    return name;\n  } // `const` declaration (`var` in es5 mode)\n\n\n  const(nameOrPrefix, rhs, _constant) {\n    return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);\n  } // `let` declaration with optional assignment (`var` in es5 mode)\n\n\n  let(nameOrPrefix, rhs, _constant) {\n    return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);\n  } // `var` declaration with optional assignment\n\n\n  var(nameOrPrefix, rhs, _constant) {\n    return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);\n  } // assignment code\n\n\n  assign(lhs, rhs, sideEffects) {\n    return this._leafNode(new Assign(lhs, rhs, sideEffects));\n  } // `+=` code\n\n\n  add(lhs, rhs) {\n    return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));\n  } // appends passed SafeExpr to code or executes Block\n\n\n  code(c) {\n    if (typeof c == \"function\") c();else if (c !== code_1.nil) this._leafNode(new AnyCode(c));\n    return this;\n  } // returns code for object literal for the passed argument list of key-value pairs\n\n\n  object() {\n    const code = [\"{\"];\n\n    for (var _len = arguments.length, keyValues = new Array(_len), _key = 0; _key < _len; _key++) {\n      keyValues[_key] = arguments[_key];\n    }\n\n    for (const [key, value] of keyValues) {\n      if (code.length > 1) code.push(\",\");\n      code.push(key);\n\n      if (key !== value || this.opts.es5) {\n        code.push(\":\");\n        (0, code_1.addCodeArg)(code, value);\n      }\n    }\n\n    code.push(\"}\");\n    return new code_1._Code(code);\n  } // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)\n\n\n  if(condition, thenBody, elseBody) {\n    this._blockNode(new If(condition));\n\n    if (thenBody && elseBody) {\n      this.code(thenBody).else().code(elseBody).endIf();\n    } else if (thenBody) {\n      this.code(thenBody).endIf();\n    } else if (elseBody) {\n      throw new Error('CodeGen: \"else\" body without \"then\" body');\n    }\n\n    return this;\n  } // `else if` clause - invalid without `if` or after `else` clauses\n\n\n  elseIf(condition) {\n    return this._elseNode(new If(condition));\n  } // `else` clause - only valid after `if` or `else if` clauses\n\n\n  else() {\n    return this._elseNode(new Else());\n  } // end `if` statement (needed if gen.if was used only with condition)\n\n\n  endIf() {\n    return this._endBlockNode(If, Else);\n  }\n\n  _for(node, forBody) {\n    this._blockNode(node);\n\n    if (forBody) this.code(forBody).endFor();\n    return this;\n  } // a generic `for` clause (or statement if `forBody` is passed)\n\n\n  for(iteration, forBody) {\n    return this._for(new ForLoop(iteration), forBody);\n  } // `for` statement for a range of values\n\n\n  forRange(nameOrPrefix, from, to, forBody) {\n    let varKind = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let;\n\n    const name = this._scope.toName(nameOrPrefix);\n\n    return this._for(new ForRange(varKind, name, from, to), () => forBody(name));\n  } // `for-of` statement (in es5 mode replace with a normal for loop)\n\n\n  forOf(nameOrPrefix, iterable, forBody) {\n    let varKind = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : scope_1.varKinds.const;\n\n    const name = this._scope.toName(nameOrPrefix);\n\n    if (this.opts.es5) {\n      const arr = iterable instanceof code_1.Name ? iterable : this.var(\"_arr\", iterable);\n      return this.forRange(\"_i\", 0, (0, code_1._)`${arr}.length`, i => {\n        this.var(name, (0, code_1._)`${arr}[${i}]`);\n        forBody(name);\n      });\n    }\n\n    return this._for(new ForIter(\"of\", varKind, name, iterable), () => forBody(name));\n  } // `for-in` statement.\n  // With option `ownProperties` replaced with a `for-of` loop for object keys\n\n\n  forIn(nameOrPrefix, obj, forBody) {\n    let varKind = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const;\n\n    if (this.opts.ownProperties) {\n      return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);\n    }\n\n    const name = this._scope.toName(nameOrPrefix);\n\n    return this._for(new ForIter(\"in\", varKind, name, obj), () => forBody(name));\n  } // end `for` loop\n\n\n  endFor() {\n    return this._endBlockNode(For);\n  } // `label` statement\n\n\n  label(label) {\n    return this._leafNode(new Label(label));\n  } // `break` statement\n\n\n  break(label) {\n    return this._leafNode(new Break(label));\n  } // `return` statement\n\n\n  return(value) {\n    const node = new Return();\n\n    this._blockNode(node);\n\n    this.code(value);\n    if (node.nodes.length !== 1) throw new Error('CodeGen: \"return\" should have one node');\n    return this._endBlockNode(Return);\n  } // `try` statement\n\n\n  try(tryBody, catchCode, finallyCode) {\n    if (!catchCode && !finallyCode) throw new Error('CodeGen: \"try\" without \"catch\" and \"finally\"');\n    const node = new Try();\n\n    this._blockNode(node);\n\n    this.code(tryBody);\n\n    if (catchCode) {\n      const error = this.name(\"e\");\n      this._currNode = node.catch = new Catch(error);\n      catchCode(error);\n    }\n\n    if (finallyCode) {\n      this._currNode = node.finally = new Finally();\n      this.code(finallyCode);\n    }\n\n    return this._endBlockNode(Catch, Finally);\n  } // `throw` statement\n\n\n  throw(error) {\n    return this._leafNode(new Throw(error));\n  } // start self-balancing block\n\n\n  block(body, nodeCount) {\n    this._blockStarts.push(this._nodes.length);\n\n    if (body) this.code(body).endBlock(nodeCount);\n    return this;\n  } // end the current self-balancing block\n\n\n  endBlock(nodeCount) {\n    const len = this._blockStarts.pop();\n\n    if (len === undefined) throw new Error(\"CodeGen: not in self-balancing block\");\n    const toClose = this._nodes.length - len;\n\n    if (toClose < 0 || nodeCount !== undefined && toClose !== nodeCount) {\n      throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);\n    }\n\n    this._nodes.length = len;\n    return this;\n  } // `function` heading (or definition if funcBody is passed)\n\n\n  func(name) {\n    let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : code_1.nil;\n    let async = arguments.length > 2 ? arguments[2] : undefined;\n    let funcBody = arguments.length > 3 ? arguments[3] : undefined;\n\n    this._blockNode(new Func(name, args, async));\n\n    if (funcBody) this.code(funcBody).endFunc();\n    return this;\n  } // end function definition\n\n\n  endFunc() {\n    return this._endBlockNode(Func);\n  }\n\n  optimize() {\n    let n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\n    while (n-- > 0) {\n      this._root.optimizeNodes();\n\n      this._root.optimizeNames(this._root.names, this._constants);\n    }\n  }\n\n  _leafNode(node) {\n    this._currNode.nodes.push(node);\n\n    return this;\n  }\n\n  _blockNode(node) {\n    this._currNode.nodes.push(node);\n\n    this._nodes.push(node);\n  }\n\n  _endBlockNode(N1, N2) {\n    const n = this._currNode;\n\n    if (n instanceof N1 || N2 && n instanceof N2) {\n      this._nodes.pop();\n\n      return this;\n    }\n\n    throw new Error(`CodeGen: not in block \"${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}\"`);\n  }\n\n  _elseNode(node) {\n    const n = this._currNode;\n\n    if (!(n instanceof If)) {\n      throw new Error('CodeGen: \"else\" without \"if\"');\n    }\n\n    this._currNode = n.else = node;\n    return this;\n  }\n\n  get _root() {\n    return this._nodes[0];\n  }\n\n  get _currNode() {\n    const ns = this._nodes;\n    return ns[ns.length - 1];\n  }\n\n  set _currNode(node) {\n    const ns = this._nodes;\n    ns[ns.length - 1] = node;\n  }\n\n}\n\nexports.CodeGen = CodeGen;\n\nfunction addNames(names, from) {\n  for (const n in from) names[n] = (names[n] || 0) + (from[n] || 0);\n\n  return names;\n}\n\nfunction addExprNames(names, from) {\n  return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;\n}\n\nfunction optimizeExpr(expr, names, constants) {\n  if (expr instanceof code_1.Name) return replaceName(expr);\n  if (!canOptimize(expr)) return expr;\n  return new code_1._Code(expr._items.reduce((items, c) => {\n    if (c instanceof code_1.Name) c = replaceName(c);\n    if (c instanceof code_1._Code) items.push(...c._items);else items.push(c);\n    return items;\n  }, []));\n\n  function replaceName(n) {\n    const c = constants[n.str];\n    if (c === undefined || names[n.str] !== 1) return n;\n    delete names[n.str];\n    return c;\n  }\n\n  function canOptimize(e) {\n    return e instanceof code_1._Code && e._items.some(c => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== undefined);\n  }\n}\n\nfunction subtractNames(names, from) {\n  for (const n in from) names[n] = (names[n] || 0) - (from[n] || 0);\n}\n\nfunction not(x) {\n  return typeof x == \"boolean\" || typeof x == \"number\" || x === null ? !x : (0, code_1._)`!${par(x)}`;\n}\n\nexports.not = not;\nconst andCode = mappend(exports.operators.AND); // boolean AND (&&) expression with the passed arguments\n\nfunction and() {\n  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n\n  return args.reduce(andCode);\n}\n\nexports.and = and;\nconst orCode = mappend(exports.operators.OR); // boolean OR (||) expression with the passed arguments\n\nfunction or() {\n  for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    args[_key3] = arguments[_key3];\n  }\n\n  return args.reduce(orCode);\n}\n\nexports.or = or;\n\nfunction mappend(op) {\n  return (x, y) => x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._)`${par(x)} ${op} ${par(y)}`;\n}\n\nfunction par(x) {\n  return x instanceof code_1.Name ? x : (0, code_1._)`(${x})`;\n}","map":{"version":3,"sources":["../../../lib/compile/codegen/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;\nconst code_1 = require(\"./code\");\nconst scope_1 = require(\"./scope\");\nvar code_2 = require(\"./code\");\nObject.defineProperty(exports, \"_\", { enumerable: true, get: function () { return code_2._; } });\nObject.defineProperty(exports, \"str\", { enumerable: true, get: function () { return code_2.str; } });\nObject.defineProperty(exports, \"strConcat\", { enumerable: true, get: function () { return code_2.strConcat; } });\nObject.defineProperty(exports, \"nil\", { enumerable: true, get: function () { return code_2.nil; } });\nObject.defineProperty(exports, \"getProperty\", { enumerable: true, get: function () { return code_2.getProperty; } });\nObject.defineProperty(exports, \"stringify\", { enumerable: true, get: function () { return code_2.stringify; } });\nObject.defineProperty(exports, \"regexpCode\", { enumerable: true, get: function () { return code_2.regexpCode; } });\nObject.defineProperty(exports, \"Name\", { enumerable: true, get: function () { return code_2.Name; } });\nvar scope_2 = require(\"./scope\");\nObject.defineProperty(exports, \"Scope\", { enumerable: true, get: function () { return scope_2.Scope; } });\nObject.defineProperty(exports, \"ValueScope\", { enumerable: true, get: function () { return scope_2.ValueScope; } });\nObject.defineProperty(exports, \"ValueScopeName\", { enumerable: true, get: function () { return scope_2.ValueScopeName; } });\nObject.defineProperty(exports, \"varKinds\", { enumerable: true, get: function () { return scope_2.varKinds; } });\nexports.operators = {\n    GT: new code_1._Code(\">\"),\n    GTE: new code_1._Code(\">=\"),\n    LT: new code_1._Code(\"<\"),\n    LTE: new code_1._Code(\"<=\"),\n    EQ: new code_1._Code(\"===\"),\n    NEQ: new code_1._Code(\"!==\"),\n    NOT: new code_1._Code(\"!\"),\n    OR: new code_1._Code(\"||\"),\n    AND: new code_1._Code(\"&&\"),\n    ADD: new code_1._Code(\"+\"),\n};\nclass Node {\n    optimizeNodes() {\n        return this;\n    }\n    optimizeNames(_names, _constants) {\n        return this;\n    }\n}\nclass Def extends Node {\n    constructor(varKind, name, rhs) {\n        super();\n        this.varKind = varKind;\n        this.name = name;\n        this.rhs = rhs;\n    }\n    render({ es5, _n }) {\n        const varKind = es5 ? scope_1.varKinds.var : this.varKind;\n        const rhs = this.rhs === undefined ? \"\" : ` = ${this.rhs}`;\n        return `${varKind} ${this.name}${rhs};` + _n;\n    }\n    optimizeNames(names, constants) {\n        if (!names[this.name.str])\n            return;\n        if (this.rhs)\n            this.rhs = optimizeExpr(this.rhs, names, constants);\n        return this;\n    }\n    get names() {\n        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};\n    }\n}\nclass Assign extends Node {\n    constructor(lhs, rhs, sideEffects) {\n        super();\n        this.lhs = lhs;\n        this.rhs = rhs;\n        this.sideEffects = sideEffects;\n    }\n    render({ _n }) {\n        return `${this.lhs} = ${this.rhs};` + _n;\n    }\n    optimizeNames(names, constants) {\n        if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)\n            return;\n        this.rhs = optimizeExpr(this.rhs, names, constants);\n        return this;\n    }\n    get names() {\n        const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };\n        return addExprNames(names, this.rhs);\n    }\n}\nclass AssignOp extends Assign {\n    constructor(lhs, op, rhs, sideEffects) {\n        super(lhs, rhs, sideEffects);\n        this.op = op;\n    }\n    render({ _n }) {\n        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;\n    }\n}\nclass Label extends Node {\n    constructor(label) {\n        super();\n        this.label = label;\n        this.names = {};\n    }\n    render({ _n }) {\n        return `${this.label}:` + _n;\n    }\n}\nclass Break extends Node {\n    constructor(label) {\n        super();\n        this.label = label;\n        this.names = {};\n    }\n    render({ _n }) {\n        const label = this.label ? ` ${this.label}` : \"\";\n        return `break${label};` + _n;\n    }\n}\nclass Throw extends Node {\n    constructor(error) {\n        super();\n        this.error = error;\n    }\n    render({ _n }) {\n        return `throw ${this.error};` + _n;\n    }\n    get names() {\n        return this.error.names;\n    }\n}\nclass AnyCode extends Node {\n    constructor(code) {\n        super();\n        this.code = code;\n    }\n    render({ _n }) {\n        return `${this.code};` + _n;\n    }\n    optimizeNodes() {\n        return `${this.code}` ? this : undefined;\n    }\n    optimizeNames(names, constants) {\n        this.code = optimizeExpr(this.code, names, constants);\n        return this;\n    }\n    get names() {\n        return this.code instanceof code_1._CodeOrName ? this.code.names : {};\n    }\n}\nclass ParentNode extends Node {\n    constructor(nodes = []) {\n        super();\n        this.nodes = nodes;\n    }\n    render(opts) {\n        return this.nodes.reduce((code, n) => code + n.render(opts), \"\");\n    }\n    optimizeNodes() {\n        const { nodes } = this;\n        let i = nodes.length;\n        while (i--) {\n            const n = nodes[i].optimizeNodes();\n            if (Array.isArray(n))\n                nodes.splice(i, 1, ...n);\n            else if (n)\n                nodes[i] = n;\n            else\n                nodes.splice(i, 1);\n        }\n        return nodes.length > 0 ? this : undefined;\n    }\n    optimizeNames(names, constants) {\n        const { nodes } = this;\n        let i = nodes.length;\n        while (i--) {\n            // iterating backwards improves 1-pass optimization\n            const n = nodes[i];\n            if (n.optimizeNames(names, constants))\n                continue;\n            subtractNames(names, n.names);\n            nodes.splice(i, 1);\n        }\n        return nodes.length > 0 ? this : undefined;\n    }\n    get names() {\n        return this.nodes.reduce((names, n) => addNames(names, n.names), {});\n    }\n}\nclass BlockNode extends ParentNode {\n    render(opts) {\n        return \"{\" + opts._n + super.render(opts) + \"}\" + opts._n;\n    }\n}\nclass Root extends ParentNode {\n}\nclass Else extends BlockNode {\n}\nElse.kind = \"else\";\nclass If extends BlockNode {\n    constructor(condition, nodes) {\n        super(nodes);\n        this.condition = condition;\n    }\n    render(opts) {\n        let code = `if(${this.condition})` + super.render(opts);\n        if (this.else)\n            code += \"else \" + this.else.render(opts);\n        return code;\n    }\n    optimizeNodes() {\n        super.optimizeNodes();\n        const cond = this.condition;\n        if (cond === true)\n            return this.nodes; // else is ignored here\n        let e = this.else;\n        if (e) {\n            const ns = e.optimizeNodes();\n            e = this.else = Array.isArray(ns) ? new Else(ns) : ns;\n        }\n        if (e) {\n            if (cond === false)\n                return e instanceof If ? e : e.nodes;\n            if (this.nodes.length)\n                return this;\n            return new If(not(cond), e instanceof If ? [e] : e.nodes);\n        }\n        if (cond === false || !this.nodes.length)\n            return undefined;\n        return this;\n    }\n    optimizeNames(names, constants) {\n        var _a;\n        this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);\n        if (!(super.optimizeNames(names, constants) || this.else))\n            return;\n        this.condition = optimizeExpr(this.condition, names, constants);\n        return this;\n    }\n    get names() {\n        const names = super.names;\n        addExprNames(names, this.condition);\n        if (this.else)\n            addNames(names, this.else.names);\n        return names;\n    }\n}\nIf.kind = \"if\";\nclass For extends BlockNode {\n}\nFor.kind = \"for\";\nclass ForLoop extends For {\n    constructor(iteration) {\n        super();\n        this.iteration = iteration;\n    }\n    render(opts) {\n        return `for(${this.iteration})` + super.render(opts);\n    }\n    optimizeNames(names, constants) {\n        if (!super.optimizeNames(names, constants))\n            return;\n        this.iteration = optimizeExpr(this.iteration, names, constants);\n        return this;\n    }\n    get names() {\n        return addNames(super.names, this.iteration.names);\n    }\n}\nclass ForRange extends For {\n    constructor(varKind, name, from, to) {\n        super();\n        this.varKind = varKind;\n        this.name = name;\n        this.from = from;\n        this.to = to;\n    }\n    render(opts) {\n        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;\n        const { name, from, to } = this;\n        return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);\n    }\n    get names() {\n        const names = addExprNames(super.names, this.from);\n        return addExprNames(names, this.to);\n    }\n}\nclass ForIter extends For {\n    constructor(loop, varKind, name, iterable) {\n        super();\n        this.loop = loop;\n        this.varKind = varKind;\n        this.name = name;\n        this.iterable = iterable;\n    }\n    render(opts) {\n        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);\n    }\n    optimizeNames(names, constants) {\n        if (!super.optimizeNames(names, constants))\n            return;\n        this.iterable = optimizeExpr(this.iterable, names, constants);\n        return this;\n    }\n    get names() {\n        return addNames(super.names, this.iterable.names);\n    }\n}\nclass Func extends BlockNode {\n    constructor(name, args, async) {\n        super();\n        this.name = name;\n        this.args = args;\n        this.async = async;\n    }\n    render(opts) {\n        const _async = this.async ? \"async \" : \"\";\n        return `${_async}function ${this.name}(${this.args})` + super.render(opts);\n    }\n}\nFunc.kind = \"func\";\nclass Return extends ParentNode {\n    render(opts) {\n        return \"return \" + super.render(opts);\n    }\n}\nReturn.kind = \"return\";\nclass Try extends BlockNode {\n    render(opts) {\n        let code = \"try\" + super.render(opts);\n        if (this.catch)\n            code += this.catch.render(opts);\n        if (this.finally)\n            code += this.finally.render(opts);\n        return code;\n    }\n    optimizeNodes() {\n        var _a, _b;\n        super.optimizeNodes();\n        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();\n        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();\n        return this;\n    }\n    optimizeNames(names, constants) {\n        var _a, _b;\n        super.optimizeNames(names, constants);\n        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);\n        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);\n        return this;\n    }\n    get names() {\n        const names = super.names;\n        if (this.catch)\n            addNames(names, this.catch.names);\n        if (this.finally)\n            addNames(names, this.finally.names);\n        return names;\n    }\n}\nclass Catch extends BlockNode {\n    constructor(error) {\n        super();\n        this.error = error;\n    }\n    render(opts) {\n        return `catch(${this.error})` + super.render(opts);\n    }\n}\nCatch.kind = \"catch\";\nclass Finally extends BlockNode {\n    render(opts) {\n        return \"finally\" + super.render(opts);\n    }\n}\nFinally.kind = \"finally\";\nclass CodeGen {\n    constructor(extScope, opts = {}) {\n        this._values = {};\n        this._blockStarts = [];\n        this._constants = {};\n        this.opts = { ...opts, _n: opts.lines ? \"\\n\" : \"\" };\n        this._extScope = extScope;\n        this._scope = new scope_1.Scope({ parent: extScope });\n        this._nodes = [new Root()];\n    }\n    toString() {\n        return this._root.render(this.opts);\n    }\n    // returns unique name in the internal scope\n    name(prefix) {\n        return this._scope.name(prefix);\n    }\n    // reserves unique name in the external scope\n    scopeName(prefix) {\n        return this._extScope.name(prefix);\n    }\n    // reserves unique name in the external scope and assigns value to it\n    scopeValue(prefixOrName, value) {\n        const name = this._extScope.value(prefixOrName, value);\n        const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set());\n        vs.add(name);\n        return name;\n    }\n    getScopeValue(prefix, keyOrRef) {\n        return this._extScope.getValue(prefix, keyOrRef);\n    }\n    // return code that assigns values in the external scope to the names that are used internally\n    // (same names that were returned by gen.scopeName or gen.scopeValue)\n    scopeRefs(scopeName) {\n        return this._extScope.scopeRefs(scopeName, this._values);\n    }\n    scopeCode() {\n        return this._extScope.scopeCode(this._values);\n    }\n    _def(varKind, nameOrPrefix, rhs, constant) {\n        const name = this._scope.toName(nameOrPrefix);\n        if (rhs !== undefined && constant)\n            this._constants[name.str] = rhs;\n        this._leafNode(new Def(varKind, name, rhs));\n        return name;\n    }\n    // `const` declaration (`var` in es5 mode)\n    const(nameOrPrefix, rhs, _constant) {\n        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);\n    }\n    // `let` declaration with optional assignment (`var` in es5 mode)\n    let(nameOrPrefix, rhs, _constant) {\n        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);\n    }\n    // `var` declaration with optional assignment\n    var(nameOrPrefix, rhs, _constant) {\n        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);\n    }\n    // assignment code\n    assign(lhs, rhs, sideEffects) {\n        return this._leafNode(new Assign(lhs, rhs, sideEffects));\n    }\n    // `+=` code\n    add(lhs, rhs) {\n        return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));\n    }\n    // appends passed SafeExpr to code or executes Block\n    code(c) {\n        if (typeof c == \"function\")\n            c();\n        else if (c !== code_1.nil)\n            this._leafNode(new AnyCode(c));\n        return this;\n    }\n    // returns code for object literal for the passed argument list of key-value pairs\n    object(...keyValues) {\n        const code = [\"{\"];\n        for (const [key, value] of keyValues) {\n            if (code.length > 1)\n                code.push(\",\");\n            code.push(key);\n            if (key !== value || this.opts.es5) {\n                code.push(\":\");\n                (0, code_1.addCodeArg)(code, value);\n            }\n        }\n        code.push(\"}\");\n        return new code_1._Code(code);\n    }\n    // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)\n    if(condition, thenBody, elseBody) {\n        this._blockNode(new If(condition));\n        if (thenBody && elseBody) {\n            this.code(thenBody).else().code(elseBody).endIf();\n        }\n        else if (thenBody) {\n            this.code(thenBody).endIf();\n        }\n        else if (elseBody) {\n            throw new Error('CodeGen: \"else\" body without \"then\" body');\n        }\n        return this;\n    }\n    // `else if` clause - invalid without `if` or after `else` clauses\n    elseIf(condition) {\n        return this._elseNode(new If(condition));\n    }\n    // `else` clause - only valid after `if` or `else if` clauses\n    else() {\n        return this._elseNode(new Else());\n    }\n    // end `if` statement (needed if gen.if was used only with condition)\n    endIf() {\n        return this._endBlockNode(If, Else);\n    }\n    _for(node, forBody) {\n        this._blockNode(node);\n        if (forBody)\n            this.code(forBody).endFor();\n        return this;\n    }\n    // a generic `for` clause (or statement if `forBody` is passed)\n    for(iteration, forBody) {\n        return this._for(new ForLoop(iteration), forBody);\n    }\n    // `for` statement for a range of values\n    forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {\n        const name = this._scope.toName(nameOrPrefix);\n        return this._for(new ForRange(varKind, name, from, to), () => forBody(name));\n    }\n    // `for-of` statement (in es5 mode replace with a normal for loop)\n    forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {\n        const name = this._scope.toName(nameOrPrefix);\n        if (this.opts.es5) {\n            const arr = iterable instanceof code_1.Name ? iterable : this.var(\"_arr\", iterable);\n            return this.forRange(\"_i\", 0, (0, code_1._) `${arr}.length`, (i) => {\n                this.var(name, (0, code_1._) `${arr}[${i}]`);\n                forBody(name);\n            });\n        }\n        return this._for(new ForIter(\"of\", varKind, name, iterable), () => forBody(name));\n    }\n    // `for-in` statement.\n    // With option `ownProperties` replaced with a `for-of` loop for object keys\n    forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {\n        if (this.opts.ownProperties) {\n            return this.forOf(nameOrPrefix, (0, code_1._) `Object.keys(${obj})`, forBody);\n        }\n        const name = this._scope.toName(nameOrPrefix);\n        return this._for(new ForIter(\"in\", varKind, name, obj), () => forBody(name));\n    }\n    // end `for` loop\n    endFor() {\n        return this._endBlockNode(For);\n    }\n    // `label` statement\n    label(label) {\n        return this._leafNode(new Label(label));\n    }\n    // `break` statement\n    break(label) {\n        return this._leafNode(new Break(label));\n    }\n    // `return` statement\n    return(value) {\n        const node = new Return();\n        this._blockNode(node);\n        this.code(value);\n        if (node.nodes.length !== 1)\n            throw new Error('CodeGen: \"return\" should have one node');\n        return this._endBlockNode(Return);\n    }\n    // `try` statement\n    try(tryBody, catchCode, finallyCode) {\n        if (!catchCode && !finallyCode)\n            throw new Error('CodeGen: \"try\" without \"catch\" and \"finally\"');\n        const node = new Try();\n        this._blockNode(node);\n        this.code(tryBody);\n        if (catchCode) {\n            const error = this.name(\"e\");\n            this._currNode = node.catch = new Catch(error);\n            catchCode(error);\n        }\n        if (finallyCode) {\n            this._currNode = node.finally = new Finally();\n            this.code(finallyCode);\n        }\n        return this._endBlockNode(Catch, Finally);\n    }\n    // `throw` statement\n    throw(error) {\n        return this._leafNode(new Throw(error));\n    }\n    // start self-balancing block\n    block(body, nodeCount) {\n        this._blockStarts.push(this._nodes.length);\n        if (body)\n            this.code(body).endBlock(nodeCount);\n        return this;\n    }\n    // end the current self-balancing block\n    endBlock(nodeCount) {\n        const len = this._blockStarts.pop();\n        if (len === undefined)\n            throw new Error(\"CodeGen: not in self-balancing block\");\n        const toClose = this._nodes.length - len;\n        if (toClose < 0 || (nodeCount !== undefined && toClose !== nodeCount)) {\n            throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);\n        }\n        this._nodes.length = len;\n        return this;\n    }\n    // `function` heading (or definition if funcBody is passed)\n    func(name, args = code_1.nil, async, funcBody) {\n        this._blockNode(new Func(name, args, async));\n        if (funcBody)\n            this.code(funcBody).endFunc();\n        return this;\n    }\n    // end function definition\n    endFunc() {\n        return this._endBlockNode(Func);\n    }\n    optimize(n = 1) {\n        while (n-- > 0) {\n            this._root.optimizeNodes();\n            this._root.optimizeNames(this._root.names, this._constants);\n        }\n    }\n    _leafNode(node) {\n        this._currNode.nodes.push(node);\n        return this;\n    }\n    _blockNode(node) {\n        this._currNode.nodes.push(node);\n        this._nodes.push(node);\n    }\n    _endBlockNode(N1, N2) {\n        const n = this._currNode;\n        if (n instanceof N1 || (N2 && n instanceof N2)) {\n            this._nodes.pop();\n            return this;\n        }\n        throw new Error(`CodeGen: not in block \"${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}\"`);\n    }\n    _elseNode(node) {\n        const n = this._currNode;\n        if (!(n instanceof If)) {\n            throw new Error('CodeGen: \"else\" without \"if\"');\n        }\n        this._currNode = n.else = node;\n        return this;\n    }\n    get _root() {\n        return this._nodes[0];\n    }\n    get _currNode() {\n        const ns = this._nodes;\n        return ns[ns.length - 1];\n    }\n    set _currNode(node) {\n        const ns = this._nodes;\n        ns[ns.length - 1] = node;\n    }\n}\nexports.CodeGen = CodeGen;\nfunction addNames(names, from) {\n    for (const n in from)\n        names[n] = (names[n] || 0) + (from[n] || 0);\n    return names;\n}\nfunction addExprNames(names, from) {\n    return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;\n}\nfunction optimizeExpr(expr, names, constants) {\n    if (expr instanceof code_1.Name)\n        return replaceName(expr);\n    if (!canOptimize(expr))\n        return expr;\n    return new code_1._Code(expr._items.reduce((items, c) => {\n        if (c instanceof code_1.Name)\n            c = replaceName(c);\n        if (c instanceof code_1._Code)\n            items.push(...c._items);\n        else\n            items.push(c);\n        return items;\n    }, []));\n    function replaceName(n) {\n        const c = constants[n.str];\n        if (c === undefined || names[n.str] !== 1)\n            return n;\n        delete names[n.str];\n        return c;\n    }\n    function canOptimize(e) {\n        return (e instanceof code_1._Code &&\n            e._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== undefined));\n    }\n}\nfunction subtractNames(names, from) {\n    for (const n in from)\n        names[n] = (names[n] || 0) - (from[n] || 0);\n}\nfunction not(x) {\n    return typeof x == \"boolean\" || typeof x == \"number\" || x === null ? !x : (0, code_1._) `!${par(x)}`;\n}\nexports.not = not;\nconst andCode = mappend(exports.operators.AND);\n// boolean AND (&&) expression with the passed arguments\nfunction and(...args) {\n    return args.reduce(andCode);\n}\nexports.and = and;\nconst orCode = mappend(exports.operators.OR);\n// boolean OR (||) expression with the passed arguments\nfunction or(...args) {\n    return args.reduce(orCode);\n}\nexports.or = or;\nfunction mappend(op) {\n    return (x, y) => (x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._) `${par(x)} ${op} ${par(y)}`);\n}\nfunction par(x) {\n    return x instanceof code_1.Name ? x : (0, code_1._) `(${x})`;\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}