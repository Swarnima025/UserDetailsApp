{"ast":null,"code":"import isEqualWith from 'lodash-es/isEqualWith';\nimport get from 'lodash-es/get';\nimport isEmpty from 'lodash-es/isEmpty';\nimport jsonpointer from 'jsonpointer';\nimport omit from 'lodash-es/omit';\nimport has from 'lodash-es/has';\nimport isObject$1 from 'lodash-es/isObject';\nimport isString from 'lodash-es/isString';\nimport reduce from 'lodash-es/reduce';\nimport times from 'lodash-es/times';\nimport set from 'lodash-es/set';\nimport mergeAllOf from 'json-schema-merge-allof';\nimport union from 'lodash-es/union';\nimport isEqual from 'lodash-es/isEqual';\nimport cloneDeep from 'lodash-es/cloneDeep';\nimport { jsx } from 'react/jsx-runtime';\nimport { createElement } from 'react';\nimport ReactIs from 'react-is';\n/** Determines whether a `thing` is an object for the purposes of RSJF. In this case, `thing` is an object if it has\r\n * the type `object` but is NOT null, an array or a File.\r\n *\r\n * @param thing - The thing to check to see whether it is an object\r\n * @returns - True if it is a non-null, non-array, non-File object\r\n */\n\nfunction isObject(thing) {\n  if (typeof File !== 'undefined' && thing instanceof File) {\n    return false;\n  }\n\n  if (typeof Date !== 'undefined' && thing instanceof Date) {\n    return false;\n  }\n\n  return typeof thing === 'object' && thing !== null && !Array.isArray(thing);\n}\n/** Checks the schema to see if it is allowing additional items, by verifying that `schema.additionalItems` is an\r\n * object. The user is warned in the console if `schema.additionalItems` has the value `true`.\r\n *\r\n * @param schema - The schema object to check\r\n * @returns - True if additional items is allowed, otherwise false\r\n */\n\n\nfunction allowAdditionalItems(schema) {\n  if (schema.additionalItems === true) {\n    console.warn('additionalItems=true is currently not supported');\n  }\n\n  return isObject(schema.additionalItems);\n}\n/** Attempts to convert the string into a number. If an empty string is provided, then `undefined` is returned. If a\r\n * `null` is provided, it is returned. If the string ends in a `.` then the string is returned because the user may be\r\n * in the middle of typing a float number. If a number ends in a pattern like `.0`, `.20`, `.030`, string is returned\r\n * because the user may be typing number that will end in a non-zero digit. Otherwise, the string is wrapped by\r\n * `Number()` and if that result is not `NaN`, that number will be returned, otherwise the string `value` will be.\r\n *\r\n * @param value - The string or null value to convert to a number\r\n * @returns - The `value` converted to a number when appropriate, otherwise the `value`\r\n */\n\n\nfunction asNumber(value) {\n  if (value === '') {\n    return undefined;\n  }\n\n  if (value === null) {\n    return null;\n  }\n\n  if (/\\.$/.test(value)) {\n    // '3.' can't really be considered a number even if it parses in js. The\n    // user is most likely entering a float.\n    return value;\n  }\n\n  if (/\\.0$/.test(value)) {\n    // we need to return this as a string here, to allow for input like 3.07\n    return value;\n  }\n\n  if (/\\.\\d*0$/.test(value)) {\n    // It's a number, that's cool - but we need it as a string so it doesn't screw\n    // with the user when entering dollar amounts or other values (such as those with\n    // specific precision or number of significant digits)\n    return value;\n  }\n\n  var n = Number(value);\n  var valid = typeof n === 'number' && !Number.isNaN(n);\n  return valid ? n : value;\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectDestructuringEmpty(obj) {\n  if (obj == null) throw new TypeError(\"Cannot destructure \" + obj);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n\n  return (hint === \"string\" ? String : Number)(input);\n}\n\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n\n  return typeof key === \"symbol\" ? key : String(key);\n}\n/** Below are the list of all the keys into various elements of a RJSFSchema or UiSchema that are used by the various\r\n * utility functions. In addition to those keys, there are the special `ADDITIONAL_PROPERTY_FLAG` and\r\n * `RJSF_ADDITONAL_PROPERTIES_FLAG` flags that is added to a schema under certain conditions by the `retrieveSchema()`\r\n * utility.\r\n */\n\n\nvar ADDITIONAL_PROPERTY_FLAG = '__additional_property';\nvar ADDITIONAL_PROPERTIES_KEY = 'additionalProperties';\nvar ALL_OF_KEY = 'allOf';\nvar ANY_OF_KEY = 'anyOf';\nvar CONST_KEY = 'const';\nvar DEFAULT_KEY = 'default';\nvar DEFINITIONS_KEY = 'definitions';\nvar DEPENDENCIES_KEY = 'dependencies';\nvar ENUM_KEY = 'enum';\nvar ERRORS_KEY = '__errors';\nvar ID_KEY = '$id';\nvar ITEMS_KEY = 'items';\nvar NAME_KEY = '$name';\nvar ONE_OF_KEY = 'oneOf';\nvar PROPERTIES_KEY = 'properties';\nvar REQUIRED_KEY = 'required';\nvar SUBMIT_BTN_OPTIONS_KEY = 'submitButtonOptions';\nvar REF_KEY = '$ref';\nvar RJSF_ADDITONAL_PROPERTIES_FLAG = '__rjsf_additionalProperties';\nvar UI_FIELD_KEY = 'ui:field';\nvar UI_WIDGET_KEY = 'ui:widget';\nvar UI_OPTIONS_KEY = 'ui:options';\nvar UI_GLOBAL_OPTIONS_KEY = 'ui:globalOptions';\n/** Get all passed options from ui:options, and ui:<optionName>, returning them in an object with the `ui:`\r\n * stripped off. Any `globalOptions` will always be returned, unless they are overridden by options in the `uiSchema`.\r\n *\r\n * @param [uiSchema={}] - The UI Schema from which to get any `ui:xxx` options\r\n * @param [globalOptions={}] - The optional Global UI Schema from which to get any fallback `xxx` options\r\n * @returns - An object containing all the `ui:xxx` options with the `ui:` stripped off along with all `globalOptions`\r\n */\n\nfunction getUiOptions(uiSchema, globalOptions) {\n  if (uiSchema === void 0) {\n    uiSchema = {};\n  }\n\n  if (globalOptions === void 0) {\n    globalOptions = {};\n  }\n\n  return Object.keys(uiSchema).filter(function (key) {\n    return key.indexOf('ui:') === 0;\n  }).reduce(function (options, key) {\n    var _extends2;\n\n    var value = uiSchema[key];\n\n    if (key === UI_WIDGET_KEY && isObject(value)) {\n      console.error('Setting options via ui:widget object is no longer supported, use ui:options instead');\n      return options;\n    }\n\n    if (key === UI_OPTIONS_KEY && isObject(value)) {\n      return _extends({}, options, value);\n    }\n\n    return _extends({}, options, (_extends2 = {}, _extends2[key.substring(3)] = value, _extends2));\n  }, _extends({}, globalOptions));\n}\n/** Checks whether the field described by `schema`, having the `uiSchema` and `formData` supports expanding. The UI for\r\n * the field can expand if it has additional properties, is not forced as non-expandable by the `uiSchema` and the\r\n * `formData` object doesn't already have `schema.maxProperties` elements.\r\n *\r\n * @param schema - The schema for the field that is being checked\r\n * @param [uiSchema={}] - The uiSchema for the field\r\n * @param [formData] - The formData for the field\r\n * @returns - True if the schema element has additionalProperties, is expandable, and not at the maxProperties limit\r\n */\n\n\nfunction canExpand(schema, uiSchema, formData) {\n  if (uiSchema === void 0) {\n    uiSchema = {};\n  }\n\n  if (!schema.additionalProperties) {\n    return false;\n  }\n\n  var _getUiOptions = getUiOptions(uiSchema),\n      _getUiOptions$expanda = _getUiOptions.expandable,\n      expandable = _getUiOptions$expanda === void 0 ? true : _getUiOptions$expanda;\n\n  if (expandable === false) {\n    return expandable;\n  } // if ui:options.expandable was not explicitly set to false, we can add\n  // another property if we have not exceeded maxProperties yet\n\n\n  if (schema.maxProperties !== undefined && formData) {\n    return Object.keys(formData).length < schema.maxProperties;\n  }\n\n  return true;\n}\n/** Implements a deep equals using the `lodash.isEqualWith` function, that provides a customized comparator that\r\n * assumes all functions are equivalent.\r\n *\r\n * @param a - The first element to compare\r\n * @param b - The second element to compare\r\n * @returns - True if the `a` and `b` are deeply equal, false otherwise\r\n */\n\n\nfunction deepEquals(a, b) {\n  return isEqualWith(a, b, function (obj, other) {\n    if (typeof obj === 'function' && typeof other === 'function') {\n      // Assume all functions are equivalent\n      // see https://github.com/rjsf-team/react-jsonschema-form/issues/255\n      return true;\n    }\n\n    return undefined; // fallback to default isEquals behavior\n  });\n}\n/** Splits out the value at the `key` in `object` from the `object`, returning an array that contains in the first\r\n * location, the `object` minus the `key: value` and in the second location the `value`.\r\n *\r\n * @param key - The key from the object to extract\r\n * @param object - The object from which to extract the element\r\n * @returns - An array with the first value being the object minus the `key` element and the second element being the\r\n *      value from `object[key]`\r\n */\n\n\nfunction splitKeyElementFromObject(key, object) {\n  var value = object[key];\n  var remaining = omit(object, [key]);\n  return [remaining, value];\n}\n/** Given the name of a `$ref` from within a schema, using the `rootSchema`, look up and return the sub-schema using the\r\n * path provided by that reference. If `#` is not the first character of the reference, or the path does not exist in\r\n * the schema, then throw an Error. Otherwise return the sub-schema. Also deals with nested `$ref`s in the sub-schema.\r\n *\r\n * @param $ref - The ref string for which the schema definition is desired\r\n * @param [rootSchema={}] - The root schema in which to search for the definition\r\n * @returns - The sub-schema within the `rootSchema` which matches the `$ref` if it exists\r\n * @throws - Error indicating that no schema for that reference exists\r\n */\n\n\nfunction findSchemaDefinition($ref, rootSchema) {\n  if (rootSchema === void 0) {\n    rootSchema = {};\n  }\n\n  var ref = $ref || '';\n\n  if (ref.startsWith('#')) {\n    // Decode URI fragment representation.\n    ref = decodeURIComponent(ref.substring(1));\n  } else {\n    throw new Error(\"Could not find a definition for \" + $ref + \".\");\n  }\n\n  var current = jsonpointer.get(rootSchema, ref);\n\n  if (current === undefined) {\n    throw new Error(\"Could not find a definition for \" + $ref + \".\");\n  }\n\n  if (current[REF_KEY]) {\n    var _splitKeyElementFromO = splitKeyElementFromObject(REF_KEY, current),\n        remaining = _splitKeyElementFromO[0],\n        theRef = _splitKeyElementFromO[1];\n\n    var subSchema = findSchemaDefinition(theRef, rootSchema);\n\n    if (Object.keys(remaining).length > 0) {\n      return _extends({}, remaining, subSchema);\n    }\n\n    return subSchema;\n  }\n\n  return current;\n}\n/** Given the `formData` and list of `options`, attempts to find the index of the option that best matches the data.\r\n * Deprecated, use `getFirstMatchingOption()` instead.\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param formData - The current formData, if any, used to figure out a match\r\n * @param options - The list of options to find a matching options from\r\n * @param rootSchema - The root schema, used to primarily to look up `$ref`s\r\n * @returns - The index of the matched option or 0 if none is available\r\n * @deprecated\r\n */\n\n\nfunction getMatchingOption(validator, formData, options, rootSchema) {\n  // For performance, skip validating subschemas if formData is undefined. We just\n  // want to get the first option in that case.\n  if (formData === undefined) {\n    return 0;\n  }\n\n  for (var i = 0; i < options.length; i++) {\n    var option = options[i]; // If the schema describes an object then we need to add slightly more\n    // strict matching to the schema, because unless the schema uses the\n    // \"requires\" keyword, an object will match the schema as long as it\n    // doesn't have matching keys with a conflicting type. To do this we use an\n    // \"anyOf\" with an array of requires. This augmentation expresses that the\n    // schema should match if any of the keys in the schema are present on the\n    // object and pass validation.\n\n    if (option.properties) {\n      // Create an \"anyOf\" schema that requires at least one of the keys in the\n      // \"properties\" object\n      var requiresAnyOf = {\n        anyOf: Object.keys(option.properties).map(function (key) {\n          return {\n            required: [key]\n          };\n        })\n      };\n      var augmentedSchema = void 0; // If the \"anyOf\" keyword already exists, wrap the augmentation in an \"allOf\"\n\n      if (option.anyOf) {\n        // Create a shallow clone of the option\n        var shallowClone = _extends({}, (_objectDestructuringEmpty(option), option));\n\n        if (!shallowClone.allOf) {\n          shallowClone.allOf = [];\n        } else {\n          // If \"allOf\" already exists, shallow clone the array\n          shallowClone.allOf = shallowClone.allOf.slice();\n        }\n\n        shallowClone.allOf.push(requiresAnyOf);\n        augmentedSchema = shallowClone;\n      } else {\n        augmentedSchema = Object.assign({}, option, requiresAnyOf);\n      } // Remove the \"required\" field as it's likely that not all fields have\n      // been filled in yet, which will mean that the schema is not valid\n\n\n      delete augmentedSchema.required;\n\n      if (validator.isValid(augmentedSchema, formData, rootSchema)) {\n        return i;\n      }\n    } else if (validator.isValid(option, formData, rootSchema)) {\n      return i;\n    }\n  }\n\n  return 0;\n}\n/** Given the `formData` and list of `options`, attempts to find the index of the first option that matches the data.\r\n * Always returns the first option if there is nothing that matches.\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param formData - The current formData, if any, used to figure out a match\r\n * @param options - The list of options to find a matching options from\r\n * @param rootSchema - The root schema, used to primarily to look up `$ref`s\r\n * @returns - The index of the first matched option or 0 if none is available\r\n */\n\n\nfunction getFirstMatchingOption(validator, formData, options, rootSchema) {\n  return getMatchingOption(validator, formData, options, rootSchema);\n}\n/** Given a specific `value` attempts to guess the type of a schema element. In the case where we have to implicitly\r\n *  create a schema, it is useful to know what type to use based on the data we are defining.\r\n *\r\n * @param value - The value from which to guess the type\r\n * @returns - The best guess for the object type\r\n */\n\n\nfunction guessType(value) {\n  if (Array.isArray(value)) {\n    return 'array';\n  }\n\n  if (typeof value === 'string') {\n    return 'string';\n  }\n\n  if (value == null) {\n    return 'null';\n  }\n\n  if (typeof value === 'boolean') {\n    return 'boolean';\n  }\n\n  if (!isNaN(value)) {\n    return 'number';\n  }\n\n  if (typeof value === 'object') {\n    return 'object';\n  } // Default to string if we can't figure it out\n\n\n  return 'string';\n}\n/** Gets the type of a given `schema`. If the type is not explicitly defined, then an attempt is made to infer it from\r\n * other elements of the schema as follows:\r\n * - schema.const: Returns the `guessType()` of that value\r\n * - schema.enum: Returns `string`\r\n * - schema.properties: Returns `object`\r\n * - schema.additionalProperties: Returns `object`\r\n * - type is an array with a length of 2 and one type is 'null': Returns the other type\r\n *\r\n * @param schema - The schema for which to get the type\r\n * @returns - The type of the schema\r\n */\n\n\nfunction getSchemaType(schema) {\n  var type = schema.type;\n\n  if (!type && schema[\"const\"]) {\n    return guessType(schema[\"const\"]);\n  }\n\n  if (!type && schema[\"enum\"]) {\n    return 'string';\n  }\n\n  if (!type && (schema.properties || schema.additionalProperties)) {\n    return 'object';\n  }\n\n  if (Array.isArray(type) && type.length === 2 && type.includes('null')) {\n    type = type.find(function (type) {\n      return type !== 'null';\n    });\n  }\n\n  return type;\n}\n/** Recursively merge deeply nested schemas. The difference between `mergeSchemas` and `mergeObjects` is that\r\n * `mergeSchemas` only concats arrays for values under the 'required' keyword, and when it does, it doesn't include\r\n * duplicate values.\r\n *\r\n * @param obj1 - The first schema object to merge\r\n * @param obj2 - The second schema object to merge\r\n * @returns - The merged schema object\r\n */\n\n\nfunction mergeSchemas(obj1, obj2) {\n  var acc = Object.assign({}, obj1); // Prevent mutation of source object.\n\n  return Object.keys(obj2).reduce(function (acc, key) {\n    var left = obj1 ? obj1[key] : {},\n        right = obj2[key];\n\n    if (obj1 && key in obj1 && isObject(right)) {\n      acc[key] = mergeSchemas(left, right);\n    } else if (obj1 && obj2 && (getSchemaType(obj1) === 'object' || getSchemaType(obj2) === 'object') && key === REQUIRED_KEY && Array.isArray(left) && Array.isArray(right)) {\n      // Don't include duplicate values when merging 'required' fields.\n      acc[key] = union(left, right);\n    } else {\n      acc[key] = right;\n    }\n\n    return acc;\n  }, acc);\n}\n\nvar _excluded$1 = [\"if\", \"then\", \"else\"],\n    _excluded2 = [\"$ref\"],\n    _excluded3 = [\"allOf\"],\n    _excluded4 = [\"dependencies\"],\n    _excluded5 = [\"oneOf\"];\n/** Resolves a conditional block (if/else/then) by removing the condition and merging the appropriate conditional branch\r\n * with the rest of the schema\r\n *\r\n * @param validator - An implementation of the `ValidatorType<T, S>` interface that is used to detect valid schema conditions\r\n * @param schema - The schema for which resolving a condition is desired\r\n * @param rootSchema - The root schema that will be forwarded to all the APIs\r\n * @param [formData] - The current formData to assist retrieving a schema\r\n * @returns - A schema with the appropriate condition resolved\r\n */\n\nfunction resolveCondition(validator, schema, rootSchema, formData) {\n  var expression = schema[\"if\"],\n      then = schema.then,\n      otherwise = schema[\"else\"],\n      resolvedSchemaLessConditional = _objectWithoutPropertiesLoose(schema, _excluded$1);\n\n  var conditionalSchema = validator.isValid(expression, formData, rootSchema) ? then : otherwise;\n\n  if (conditionalSchema && typeof conditionalSchema !== 'boolean') {\n    return retrieveSchema(validator, mergeSchemas(resolvedSchemaLessConditional, retrieveSchema(validator, conditionalSchema, rootSchema, formData)), rootSchema, formData);\n  }\n\n  return retrieveSchema(validator, resolvedSchemaLessConditional, rootSchema, formData);\n}\n/** Resolves references and dependencies within a schema and its 'allOf' children.\r\n * Called internally by retrieveSchema.\r\n *\r\n * @param validator - An implementation of the `ValidatorType<T, S>` interface that will be forwarded to all the APIs\r\n * @param schema - The schema for which resolving a schema is desired\r\n * @param [rootSchema={}] - The root schema that will be forwarded to all the APIs\r\n * @param [formData] - The current formData, if any, to assist retrieving a schema\r\n * @returns - The schema having its references and dependencies resolved\r\n */\n\n\nfunction resolveSchema(validator, schema, rootSchema, formData) {\n  if (rootSchema === void 0) {\n    rootSchema = {};\n  }\n\n  if (REF_KEY in schema) {\n    return resolveReference(validator, schema, rootSchema, formData);\n  }\n\n  if (DEPENDENCIES_KEY in schema) {\n    var resolvedSchema = resolveDependencies(validator, schema, rootSchema, formData);\n    return retrieveSchema(validator, resolvedSchema, rootSchema, formData);\n  }\n\n  if (ALL_OF_KEY in schema) {\n    return _extends({}, schema, {\n      allOf: schema.allOf.map(function (allOfSubschema) {\n        return retrieveSchema(validator, allOfSubschema, rootSchema, formData);\n      })\n    });\n  } // No $ref or dependencies attribute found, returning the original schema.\n\n\n  return schema;\n}\n/** Resolves references within a schema and its 'allOf' children.\r\n *\r\n * @param validator - An implementation of the `ValidatorType<T, S>` interface that will be forwarded to all the APIs\r\n * @param schema - The schema for which resolving a reference is desired\r\n * @param rootSchema - The root schema that will be forwarded to all the APIs\r\n * @param [formData] - The current formData, if any, to assist retrieving a schema\r\n * @returns - The schema having its references resolved\r\n */\n\n\nfunction resolveReference(validator, schema, rootSchema, formData) {\n  // Retrieve the referenced schema definition.\n  var $refSchema = findSchemaDefinition(schema.$ref, rootSchema); // Drop the $ref property of the source schema.\n\n  var localSchema = _objectWithoutPropertiesLoose(schema, _excluded2); // Update referenced schema definition with local schema properties.\n\n\n  return retrieveSchema(validator, _extends({}, $refSchema, localSchema), rootSchema, formData);\n}\n/** Creates new 'properties' items for each key in the `formData`\r\n *\r\n * @param validator - An implementation of the `ValidatorType<T, S>` interface that will be used when necessary\r\n * @param theSchema - The schema for which the existing additional properties is desired\r\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s * @param validator\r\n * @param [aFormData] - The current formData, if any, to assist retrieving a schema\r\n * @returns - The updated schema with additional properties stubbed\r\n */\n\n\nfunction stubExistingAdditionalProperties(validator, theSchema, rootSchema, aFormData) {\n  // Clone the schema so we don't ruin the consumer's original\n  var schema = _extends({}, theSchema, {\n    properties: _extends({}, theSchema.properties)\n  }); // make sure formData is an object\n\n\n  var formData = aFormData && isObject(aFormData) ? aFormData : {};\n  Object.keys(formData).forEach(function (key) {\n    if (key in schema.properties) {\n      // No need to stub, our schema already has the property\n      return;\n    }\n\n    var additionalProperties = {};\n\n    if (typeof schema.additionalProperties !== 'boolean') {\n      if (REF_KEY in schema.additionalProperties) {\n        additionalProperties = retrieveSchema(validator, {\n          $ref: get(schema.additionalProperties, [REF_KEY])\n        }, rootSchema, formData);\n      } else if ('type' in schema.additionalProperties) {\n        additionalProperties = _extends({}, schema.additionalProperties);\n      } else if (ANY_OF_KEY in schema.additionalProperties || ONE_OF_KEY in schema.additionalProperties) {\n        additionalProperties = _extends({\n          type: 'object'\n        }, schema.additionalProperties);\n      } else {\n        additionalProperties = {\n          type: guessType(get(formData, [key]))\n        };\n      }\n    } else {\n      additionalProperties = {\n        type: guessType(get(formData, [key]))\n      };\n    } // The type of our new key should match the additionalProperties value;\n\n\n    schema.properties[key] = additionalProperties; // Set our additional property flag so we know it was dynamically added\n\n    set(schema.properties, [key, ADDITIONAL_PROPERTY_FLAG], true);\n  });\n  return schema;\n}\n/** Retrieves an expanded schema that has had all of its conditions, additional properties, references and dependencies\r\n * resolved and merged into the `schema` given a `validator`, `rootSchema` and `rawFormData` that is used to do the\r\n * potentially recursive resolution.\r\n *\r\n * @param validator - An implementation of the `ValidatorType<T, S>` interface that will be forwarded to all the APIs\r\n * @param schema - The schema for which retrieving a schema is desired\r\n * @param [rootSchema={}] - The root schema that will be forwarded to all the APIs\r\n * @param [rawFormData] - The current formData, if any, to assist retrieving a schema\r\n * @returns - The schema having its conditions, additional properties, references and dependencies resolved\r\n */\n\n\nfunction retrieveSchema(validator, schema, rootSchema, rawFormData) {\n  if (rootSchema === void 0) {\n    rootSchema = {};\n  }\n\n  if (!isObject(schema)) {\n    return {};\n  }\n\n  var resolvedSchema = resolveSchema(validator, schema, rootSchema, rawFormData);\n\n  if ('if' in schema) {\n    return resolveCondition(validator, schema, rootSchema, rawFormData);\n  }\n\n  var formData = rawFormData || {};\n\n  if (ALL_OF_KEY in schema) {\n    try {\n      resolvedSchema = mergeAllOf(resolvedSchema, {\n        deep: false\n      });\n    } catch (e) {\n      console.warn('could not merge subschemas in allOf:\\n' + e);\n\n      var _resolvedSchema = resolvedSchema,\n          resolvedSchemaWithoutAllOf = _objectWithoutPropertiesLoose(_resolvedSchema, _excluded3);\n\n      return resolvedSchemaWithoutAllOf;\n    }\n  }\n\n  var hasAdditionalProperties = ADDITIONAL_PROPERTIES_KEY in resolvedSchema && resolvedSchema.additionalProperties !== false;\n\n  if (hasAdditionalProperties) {\n    return stubExistingAdditionalProperties(validator, resolvedSchema, rootSchema, formData);\n  }\n\n  return resolvedSchema;\n}\n/** Resolves dependencies within a schema and its 'allOf' children.\r\n *\r\n * @param validator - An implementation of the `ValidatorType<T, S>` interface that will be forwarded to all the APIs\r\n * @param schema - The schema for which resolving a dependency is desired\r\n * @param rootSchema - The root schema that will be forwarded to all the APIs\r\n * @param [formData] - The current formData, if any, to assist retrieving a schema\r\n * @returns - The schema with its dependencies resolved\r\n */\n\n\nfunction resolveDependencies(validator, schema, rootSchema, formData) {\n  // Drop the dependencies from the source schema.\n  var dependencies = schema.dependencies,\n      remainingSchema = _objectWithoutPropertiesLoose(schema, _excluded4);\n\n  var resolvedSchema = remainingSchema;\n\n  if (Array.isArray(resolvedSchema.oneOf)) {\n    resolvedSchema = resolvedSchema.oneOf[getFirstMatchingOption(validator, formData, resolvedSchema.oneOf, rootSchema)];\n  } else if (Array.isArray(resolvedSchema.anyOf)) {\n    resolvedSchema = resolvedSchema.anyOf[getFirstMatchingOption(validator, formData, resolvedSchema.anyOf, rootSchema)];\n  }\n\n  return processDependencies(validator, dependencies, resolvedSchema, rootSchema, formData);\n}\n/** Processes all the `dependencies` recursively into the `resolvedSchema` as needed\r\n *\r\n * @param validator - An implementation of the `ValidatorType<T, S>` interface that will be forwarded to all the APIs\r\n * @param dependencies - The set of dependencies that needs to be processed\r\n * @param resolvedSchema - The schema for which processing dependencies is desired\r\n * @param rootSchema - The root schema that will be forwarded to all the APIs\r\n * @param [formData] - The current formData, if any, to assist retrieving a schema\r\n * @returns - The schema with the `dependencies` resolved into it\r\n */\n\n\nfunction processDependencies(validator, dependencies, resolvedSchema, rootSchema, formData) {\n  var schema = resolvedSchema; // Process dependencies updating the local schema properties as appropriate.\n\n  for (var dependencyKey in dependencies) {\n    // Skip this dependency if its trigger property is not present.\n    if (get(formData, [dependencyKey]) === undefined) {\n      continue;\n    } // Skip this dependency if it is not included in the schema (such as when dependencyKey is itself a hidden dependency.)\n\n\n    if (schema.properties && !(dependencyKey in schema.properties)) {\n      continue;\n    }\n\n    var _splitKeyElementFromO = splitKeyElementFromObject(dependencyKey, dependencies),\n        remainingDependencies = _splitKeyElementFromO[0],\n        dependencyValue = _splitKeyElementFromO[1];\n\n    if (Array.isArray(dependencyValue)) {\n      schema = withDependentProperties(schema, dependencyValue);\n    } else if (isObject(dependencyValue)) {\n      schema = withDependentSchema(validator, schema, rootSchema, dependencyKey, dependencyValue, formData);\n    }\n\n    return processDependencies(validator, remainingDependencies, schema, rootSchema, formData);\n  }\n\n  return schema;\n}\n/** Updates a schema with additionally required properties added\r\n *\r\n * @param schema - The schema for which resolving a dependent properties is desired\r\n * @param [additionallyRequired] - An optional array of additionally required names\r\n * @returns - The schema with the additional required values merged in\r\n */\n\n\nfunction withDependentProperties(schema, additionallyRequired) {\n  if (!additionallyRequired) {\n    return schema;\n  }\n\n  var required = Array.isArray(schema.required) ? Array.from(new Set([].concat(schema.required, additionallyRequired))) : additionallyRequired;\n  return _extends({}, schema, {\n    required: required\n  });\n}\n/** Merges a dependent schema into the `schema` dealing with oneOfs and references\r\n *\r\n * @param validator - An implementation of the `ValidatorType<T, S>` interface that will be forwarded to all the APIs\r\n * @param schema - The schema for which resolving a dependent schema is desired\r\n * @param rootSchema - The root schema that will be forwarded to all the APIs\r\n * @param dependencyKey - The key name of the dependency\r\n * @param dependencyValue - The potentially dependent schema\r\n * @param formData- The current formData to assist retrieving a schema\r\n * @returns - The schema with the dependent schema resolved into it\r\n */\n\n\nfunction withDependentSchema(validator, schema, rootSchema, dependencyKey, dependencyValue, formData) {\n  var _retrieveSchema = retrieveSchema(validator, dependencyValue, rootSchema, formData),\n      oneOf = _retrieveSchema.oneOf,\n      dependentSchema = _objectWithoutPropertiesLoose(_retrieveSchema, _excluded5);\n\n  schema = mergeSchemas(schema, dependentSchema); // Since it does not contain oneOf, we return the original schema.\n\n  if (oneOf === undefined) {\n    return schema;\n  } // Resolve $refs inside oneOf.\n\n\n  var resolvedOneOf = oneOf.map(function (subschema) {\n    if (typeof subschema === 'boolean' || !(REF_KEY in subschema)) {\n      return subschema;\n    }\n\n    return resolveReference(validator, subschema, rootSchema, formData);\n  });\n  return withExactlyOneSubschema(validator, schema, rootSchema, dependencyKey, resolvedOneOf, formData);\n}\n/** Returns a `schema` with the best choice from the `oneOf` options merged into it\r\n *\r\n * @param validator - An implementation of the `ValidatorType<T, S>` interface that will be used to validate oneOf options\r\n * @param schema - The schema for which resolving a oneOf subschema is desired\r\n * @param rootSchema - The root schema that will be forwarded to all the APIs\r\n * @param dependencyKey - The key name of the oneOf dependency\r\n * @param oneOf - The list of schemas representing the oneOf options\r\n * @param [formData] - The current formData to assist retrieving a schema\r\n * @returns  The schema with the best choice of oneOf schemas merged into\r\n */\n\n\nfunction withExactlyOneSubschema(validator, schema, rootSchema, dependencyKey, oneOf, formData) {\n  var validSubschemas = oneOf.filter(function (subschema) {\n    if (typeof subschema === 'boolean' || !subschema || !subschema.properties) {\n      return false;\n    }\n\n    var conditionPropertySchema = subschema.properties[dependencyKey];\n\n    if (conditionPropertySchema) {\n      var _properties;\n\n      var conditionSchema = {\n        type: 'object',\n        properties: (_properties = {}, _properties[dependencyKey] = conditionPropertySchema, _properties)\n      };\n\n      var _validator$validateFo = validator.validateFormData(formData, conditionSchema),\n          errors = _validator$validateFo.errors;\n\n      return errors.length === 0;\n    }\n\n    return false;\n  });\n\n  if (validSubschemas.length !== 1) {\n    console.warn(\"ignoring oneOf in dependencies because there isn't exactly one subschema that is valid\");\n    return schema;\n  }\n\n  var subschema = validSubschemas[0];\n\n  var _splitKeyElementFromO2 = splitKeyElementFromObject(dependencyKey, subschema.properties),\n      dependentSubschema = _splitKeyElementFromO2[0];\n\n  var dependentSchema = _extends({}, subschema, {\n    properties: dependentSubschema\n  });\n\n  return mergeSchemas(schema, retrieveSchema(validator, dependentSchema, rootSchema, formData));\n}\n/** A junk option used to determine when the getFirstMatchingOption call really matches an option rather than returning\r\n * the first item\r\n */\n\n\nvar JUNK_OPTION = {\n  type: 'object',\n  properties: {\n    __not_really_there__: {\n      type: 'number'\n    }\n  }\n};\n/** Recursive function that calculates the score of a `formData` against the given `schema`. The computation is fairly\r\n * simple. Initially the total score is 0. When `schema.properties` object exists, then all the `key/value` pairs within\r\n * the object are processed as follows after obtaining the formValue from `formData` using the `key`:\r\n * - If the `value` contains a `$ref`, `calculateIndexScore()` is called recursively with the formValue and the new\r\n *   schema that is the result of the ref in the schema being resolved and that sub-schema's resulting score is added to\r\n *   the total.\r\n * - If the `value` contains a `oneOf` and there is a formValue, then score based on the index returned from calling\r\n *   `getClosestMatchingOption()` of that oneOf.\r\n * - If the type of the `value` is 'object', `calculateIndexScore()` is called recursively with the formValue and the\r\n *   `value` itself as the sub-schema, and the score is added to the total.\r\n * - If the type of the `value` matches the guessed-type of the `formValue`, the score is incremented by 1, UNLESS the\r\n *   value has a `default` or `const`. In those case, if the `default` or `const` and the `formValue` match, the score\r\n *   is incremented by another 1 otherwise it is decremented by 1.\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param rootSchema - The root JSON schema of the entire form\r\n * @param schema - The schema for which the score is being calculated\r\n * @param formData - The form data associated with the schema, used to calculate the score\r\n * @returns - The score a schema against the formData\r\n */\n\nfunction calculateIndexScore(validator, rootSchema, schema, formData) {\n  if (formData === void 0) {\n    formData = {};\n  }\n\n  var totalScore = 0;\n\n  if (schema) {\n    if (isObject$1(schema.properties)) {\n      totalScore += reduce(schema.properties, function (score, value, key) {\n        var formValue = get(formData, key);\n\n        if (typeof value === 'boolean') {\n          return score;\n        }\n\n        if (has(value, REF_KEY)) {\n          var newSchema = retrieveSchema(validator, value, rootSchema, formValue);\n          return score + calculateIndexScore(validator, rootSchema, newSchema, formValue || {});\n        }\n\n        if (has(value, ONE_OF_KEY) && formValue) {\n          return score + getClosestMatchingOption(validator, rootSchema, formValue, get(value, ONE_OF_KEY));\n        }\n\n        if (value.type === 'object') {\n          return score + calculateIndexScore(validator, rootSchema, value, formValue || {});\n        }\n\n        if (value.type === guessType(formValue)) {\n          // If the types match, then we bump the score by one\n          var newScore = score + 1;\n\n          if (value[\"default\"]) {\n            // If the schema contains a readonly default value score the value that matches the default higher and\n            // any non-matching value lower\n            newScore += formValue === value[\"default\"] ? 1 : -1;\n          } else if (value[\"const\"]) {\n            // If the schema contains a const value score the value that matches the default higher and\n            // any non-matching value lower\n            newScore += formValue === value[\"const\"] ? 1 : -1;\n          } // TODO eventually, deal with enums/arrays\n\n\n          return newScore;\n        }\n\n        return score;\n      }, 0);\n    } else if (isString(schema.type) && schema.type === guessType(formData)) {\n      totalScore += 1;\n    }\n  }\n\n  return totalScore;\n}\n/** Determines which of the given `options` provided most closely matches the `formData`. Using\r\n * `getFirstMatchingOption()` to match two schemas that differ only by the readOnly, default or const value of a field\r\n * based on the `formData` and returns 0 when there is no match. Rather than passing in all the `options` at once to\r\n * this utility, instead an array of valid option indexes is created by iterating over the list of options, call\r\n * `getFirstMatchingOptions` with a list of one junk option and one good option, seeing if the good option is considered\r\n * matched.\r\n *\r\n * Once the list of valid indexes is created, if there is only one valid index, just return it. Otherwise, if there are\r\n * no valid indexes, then fill the valid indexes array with the indexes of all the options. Next, the index of the\r\n * option with the highest score is determined by iterating over the list of valid options, calling\r\n * `calculateIndexScore()` on each, comparing it against the current best score, and returning the index of the one that\r\n * eventually has the best score.\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param rootSchema - The root JSON schema of the entire form\r\n * @param formData - The form data associated with the schema\r\n * @param options - The list of options that can be selected from\r\n * @param [selectedOption=-1] - The index of the currently selected option, defaulted to -1 if not specified\r\n * @returns - The index of the option that is the closest match to the `formData` or the `selectedOption` if no match\r\n */\n\n\nfunction getClosestMatchingOption(validator, rootSchema, formData, options, selectedOption) {\n  if (selectedOption === void 0) {\n    selectedOption = -1;\n  } // Reduce the array of options down to a list of the indexes that are considered matching options\n\n\n  var allValidIndexes = options.reduce(function (validList, option, index) {\n    var testOptions = [JUNK_OPTION, option];\n    var match = getFirstMatchingOption(validator, formData, testOptions, rootSchema); // The match is the real option, so add its index to list of valid indexes\n\n    if (match === 1) {\n      validList.push(index);\n    }\n\n    return validList;\n  }, []); // There is only one valid index, so return it!\n\n  if (allValidIndexes.length === 1) {\n    return allValidIndexes[0];\n  }\n\n  if (!allValidIndexes.length) {\n    // No indexes were valid, so we'll score all the options, add all the indexes\n    times(options.length, function (i) {\n      return allValidIndexes.push(i);\n    });\n  } // Score all the options in the list of valid indexes and return the index with the best score\n\n\n  var _allValidIndexes$redu = allValidIndexes.reduce(function (scoreData, index) {\n    var bestScore = scoreData.bestScore;\n    var option = options[index];\n\n    if (has(option, REF_KEY)) {\n      option = retrieveSchema(validator, option, rootSchema, formData);\n    }\n\n    var score = calculateIndexScore(validator, rootSchema, option, formData);\n\n    if (score > bestScore) {\n      return {\n        bestIndex: index,\n        bestScore: score\n      };\n    }\n\n    return scoreData;\n  }, {\n    bestIndex: selectedOption,\n    bestScore: 0\n  }),\n      bestIndex = _allValidIndexes$redu.bestIndex;\n\n  return bestIndex;\n}\n/** Detects whether the given `schema` contains fixed items. This is the case when `schema.items` is a non-empty array\r\n * that only contains objects.\r\n *\r\n * @param schema - The schema in which to check for fixed items\r\n * @returns - True if there are fixed items in the schema, false otherwise\r\n */\n\n\nfunction isFixedItems(schema) {\n  return Array.isArray(schema.items) && schema.items.length > 0 && schema.items.every(function (item) {\n    return isObject(item);\n  });\n}\n/** Merges the `defaults` object of type `T` into the `formData` of type `T`\r\n *\r\n * When merging defaults and form data, we want to merge in this specific way:\r\n * - objects are deeply merged\r\n * - arrays are merged in such a way that:\r\n *   - when the array is set in form data, only array entries set in form data\r\n *     are deeply merged; additional entries from the defaults are ignored\r\n *   - when the array is not set in form data, the default is copied over\r\n * - scalars are overwritten/set by form data\r\n *\r\n * @param [defaults] - The defaults to merge\r\n * @param [formData] - The form data into which the defaults will be merged\r\n * @returns - The resulting merged form data with defaults\r\n */\n\n\nfunction mergeDefaultsWithFormData(defaults, formData) {\n  if (Array.isArray(formData)) {\n    var defaultsArray = Array.isArray(defaults) ? defaults : [];\n    var mapped = formData.map(function (value, idx) {\n      if (defaultsArray[idx]) {\n        return mergeDefaultsWithFormData(defaultsArray[idx], value);\n      }\n\n      return value;\n    });\n    return mapped;\n  }\n\n  if (isObject(formData)) {\n    var acc = Object.assign({}, defaults); // Prevent mutation of source object.\n\n    return Object.keys(formData).reduce(function (acc, key) {\n      acc[key] = mergeDefaultsWithFormData(defaults ? get(defaults, key) : {}, get(formData, key));\n      return acc;\n    }, acc);\n  }\n\n  return formData;\n}\n/** Recursively merge deeply nested objects.\r\n *\r\n * @param obj1 - The first object to merge\r\n * @param obj2 - The second object to merge\r\n * @param [concatArrays=false] - Optional flag that, when true, will cause arrays to be concatenated. Use\r\n *          \"preventDuplicates\" to merge arrays in a manner that prevents any duplicate entries from being merged.\r\n *          NOTE: Uses shallow comparison for the duplicate checking.\r\n * @returns - A new object that is the merge of the two given objects\r\n */\n\n\nfunction mergeObjects(obj1, obj2, concatArrays) {\n  if (concatArrays === void 0) {\n    concatArrays = false;\n  }\n\n  return Object.keys(obj2).reduce(function (acc, key) {\n    var left = obj1 ? obj1[key] : {},\n        right = obj2[key];\n\n    if (obj1 && key in obj1 && isObject(right)) {\n      acc[key] = mergeObjects(left, right, concatArrays);\n    } else if (concatArrays && Array.isArray(left) && Array.isArray(right)) {\n      var toMerge = right;\n\n      if (concatArrays === 'preventDuplicates') {\n        toMerge = right.reduce(function (result, value) {\n          if (!left.includes(value)) {\n            result.push(value);\n          }\n\n          return result;\n        }, []);\n      }\n\n      acc[key] = left.concat(toMerge);\n    } else {\n      acc[key] = right;\n    }\n\n    return acc;\n  }, Object.assign({}, obj1)); // Prevent mutation of source object.\n}\n/** This function checks if the given `schema` matches a single constant value. This happens when either the schema has\r\n * an `enum` array with a single value or there is a `const` defined.\r\n *\r\n * @param schema - The schema for a field\r\n * @returns - True if the `schema` has a single constant value, false otherwise\r\n */\n\n\nfunction isConstant(schema) {\n  return Array.isArray(schema[\"enum\"]) && schema[\"enum\"].length === 1 || CONST_KEY in schema;\n}\n/** Checks to see if the `schema` combination represents a select\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param theSchema - The schema for which check for a select flag is desired\r\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\r\n * @returns - True if schema contains a select, otherwise false\r\n */\n\n\nfunction isSelect(validator, theSchema, rootSchema) {\n  if (rootSchema === void 0) {\n    rootSchema = {};\n  }\n\n  var schema = retrieveSchema(validator, theSchema, rootSchema, undefined);\n  var altSchemas = schema.oneOf || schema.anyOf;\n\n  if (Array.isArray(schema[\"enum\"])) {\n    return true;\n  }\n\n  if (Array.isArray(altSchemas)) {\n    return altSchemas.every(function (altSchemas) {\n      return typeof altSchemas !== 'boolean' && isConstant(altSchemas);\n    });\n  }\n\n  return false;\n}\n/** Checks to see if the `schema` combination represents a multi-select\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param schema - The schema for which check for a multi-select flag is desired\r\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\r\n * @returns - True if schema contains a multi-select, otherwise false\r\n */\n\n\nfunction isMultiSelect(validator, schema, rootSchema) {\n  if (!schema.uniqueItems || !schema.items || typeof schema.items === 'boolean') {\n    return false;\n  }\n\n  return isSelect(validator, schema.items, rootSchema);\n}\n/** Enum that indicates how `schema.additionalItems` should be handled by the `getInnerSchemaForArrayItem()` function.\r\n */\n\n\nvar AdditionalItemsHandling;\n\n(function (AdditionalItemsHandling) {\n  AdditionalItemsHandling[AdditionalItemsHandling[\"Ignore\"] = 0] = \"Ignore\";\n  AdditionalItemsHandling[AdditionalItemsHandling[\"Invert\"] = 1] = \"Invert\";\n  AdditionalItemsHandling[AdditionalItemsHandling[\"Fallback\"] = 2] = \"Fallback\";\n})(AdditionalItemsHandling || (AdditionalItemsHandling = {}));\n/** Given a `schema` will return an inner schema that for an array item. This is computed differently based on the\r\n * `additionalItems` enum and the value of `idx`. There are four possible returns:\r\n * 1. If `idx` is >= 0, then if `schema.items` is an array the `idx`th element of the array is returned if it is a valid\r\n *    index and not a boolean, otherwise it falls through to 3.\r\n * 2. If `schema.items` is not an array AND truthy and not a boolean, then `schema.items` is returned since it actually\r\n *    is a schema, otherwise it falls through to 3.\r\n * 3. If `additionalItems` is not `AdditionalItemsHandling.Ignore` and `schema.additionalItems` is an object, then\r\n *    `schema.additionalItems` is returned since it actually is a schema, otherwise it falls through to 4.\r\n * 4. {} is returned representing an empty schema\r\n *\r\n * @param schema - The schema from which to get the particular item\r\n * @param [additionalItems=AdditionalItemsHandling.Ignore] - How do we want to handle additional items?\r\n * @param [idx=-1] - Index, if non-negative, will be used to return the idx-th element in a `schema.items` array\r\n * @returns - The best fit schema object from the `schema` given the `additionalItems` and `idx` modifiers\r\n */\n\n\nfunction getInnerSchemaForArrayItem(schema, additionalItems, idx) {\n  if (additionalItems === void 0) {\n    additionalItems = AdditionalItemsHandling.Ignore;\n  }\n\n  if (idx === void 0) {\n    idx = -1;\n  }\n\n  if (idx >= 0) {\n    if (Array.isArray(schema.items) && idx < schema.items.length) {\n      var item = schema.items[idx];\n\n      if (typeof item !== 'boolean') {\n        return item;\n      }\n    }\n  } else if (schema.items && !Array.isArray(schema.items) && typeof schema.items !== 'boolean') {\n    return schema.items;\n  }\n\n  if (additionalItems !== AdditionalItemsHandling.Ignore && isObject(schema.additionalItems)) {\n    return schema.additionalItems;\n  }\n\n  return {};\n}\n/** Either add `computedDefault` at `key` into `obj` or not add it based on its value and the value of\r\n * `includeUndefinedValues`. Generally undefined `computedDefault` values are added only when `includeUndefinedValues`\r\n * is either true or \"excludeObjectChildren\". If `includeUndefinedValues` is false, then non-undefined and\r\n * non-empty-object values will be added.\r\n *\r\n * @param obj - The object into which the computed default may be added\r\n * @param key - The key into the object at which the computed default may be added\r\n * @param computedDefault - The computed default value that maybe should be added to the obj\r\n * @param includeUndefinedValues - Optional flag, if true, cause undefined values to be added as defaults.\r\n *          If \"excludeObjectChildren\", cause undefined values for this object and pass `includeUndefinedValues` as\r\n *          false when computing defaults for any nested object properties. If \"allowEmptyObject\", prevents undefined\r\n *          values in this object while allow the object itself to be empty and passing `includeUndefinedValues` as\r\n *          false when computing defaults for any nested object properties.\r\n * @param requiredFields - The list of fields that are required\r\n */\n\n\nfunction maybeAddDefaultToObject(obj, key, computedDefault, includeUndefinedValues, requiredFields) {\n  if (requiredFields === void 0) {\n    requiredFields = [];\n  }\n\n  if (includeUndefinedValues) {\n    obj[key] = computedDefault;\n  } else if (isObject(computedDefault)) {\n    // Store computedDefault if it's a non-empty object (e.g. not {})\n    if (!isEmpty(computedDefault) || requiredFields.includes(key)) {\n      obj[key] = computedDefault;\n    }\n  } else if (computedDefault !== undefined) {\n    // Store computedDefault if it's a defined primitive (e.g. true)\n    obj[key] = computedDefault;\n  }\n}\n/** Computes the defaults for the current `schema` given the `rawFormData` and `parentDefaults` if any. This drills into\r\n * each level of the schema, recursively, to fill out every level of defaults provided by the schema.\r\n *\r\n * @param validator - an implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param rawSchema - The schema for which the default state is desired\r\n * @param [parentDefaults] - Any defaults provided by the parent field in the schema\r\n * @param [rootSchema] - The options root schema, used to primarily to look up `$ref`s\r\n * @param [rawFormData] - The current formData, if any, onto which to provide any missing defaults\r\n * @param [includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.\r\n *          If \"excludeObjectChildren\", cause undefined values for this object and pass `includeUndefinedValues` as\r\n *          false when computing defaults for any nested object properties.\r\n * @returns - The resulting `formData` with all the defaults provided\r\n */\n\n\nfunction computeDefaults(validator, rawSchema, parentDefaults, rootSchema, rawFormData, includeUndefinedValues) {\n  if (rootSchema === void 0) {\n    rootSchema = {};\n  }\n\n  if (includeUndefinedValues === void 0) {\n    includeUndefinedValues = false;\n  }\n\n  var formData = isObject(rawFormData) ? rawFormData : {};\n  var schema = isObject(rawSchema) ? rawSchema : {}; // Compute the defaults recursively: give highest priority to deepest nodes.\n\n  var defaults = parentDefaults;\n\n  if (isObject(defaults) && isObject(schema[\"default\"])) {\n    // For object defaults, only override parent defaults that are defined in\n    // schema.default.\n    defaults = mergeObjects(defaults, schema[\"default\"]);\n  } else if (DEFAULT_KEY in schema) {\n    defaults = schema[\"default\"];\n  } else if (REF_KEY in schema) {\n    // Use referenced schema defaults for this node.\n    var refSchema = findSchemaDefinition(schema[REF_KEY], rootSchema);\n    return computeDefaults(validator, refSchema, defaults, rootSchema, formData, includeUndefinedValues);\n  } else if (DEPENDENCIES_KEY in schema) {\n    var resolvedSchema = resolveDependencies(validator, schema, rootSchema, formData);\n    return computeDefaults(validator, resolvedSchema, defaults, rootSchema, formData, includeUndefinedValues);\n  } else if (isFixedItems(schema)) {\n    defaults = schema.items.map(function (itemSchema, idx) {\n      return computeDefaults(validator, itemSchema, Array.isArray(parentDefaults) ? parentDefaults[idx] : undefined, rootSchema, formData, includeUndefinedValues);\n    });\n  } else if (ONE_OF_KEY in schema) {\n    if (schema.oneOf.length === 0) {\n      return undefined;\n    }\n\n    schema = schema.oneOf[getClosestMatchingOption(validator, rootSchema, isEmpty(formData) ? undefined : formData, schema.oneOf, 0)];\n  } else if (ANY_OF_KEY in schema) {\n    if (schema.anyOf.length === 0) {\n      return undefined;\n    }\n\n    schema = schema.anyOf[getClosestMatchingOption(validator, rootSchema, isEmpty(formData) ? undefined : formData, schema.anyOf, 0)];\n  } // Not defaults defined for this node, fallback to generic typed ones.\n\n\n  if (typeof defaults === 'undefined') {\n    defaults = schema[\"default\"];\n  }\n\n  switch (getSchemaType(schema)) {\n    // We need to recur for object schema inner default values.\n    case 'object':\n      {\n        var objectDefaults = Object.keys(schema.properties || {}).reduce(function (acc, key) {\n          // Compute the defaults for this node, with the parent defaults we might\n          // have from a previous run: defaults[key].\n          var computedDefault = computeDefaults(validator, get(schema, [PROPERTIES_KEY, key]), get(defaults, [key]), rootSchema, get(formData, [key]), includeUndefinedValues === true);\n          maybeAddDefaultToObject(acc, key, computedDefault, includeUndefinedValues, schema.required);\n          return acc;\n        }, {});\n\n        if (schema.additionalProperties && isObject(defaults)) {\n          var additionalPropertiesSchema = isObject(schema.additionalProperties) ? schema.additionalProperties : {}; // as per spec additionalProperties may be either schema or boolean\n\n          Object.keys(defaults).filter(function (key) {\n            return !schema.properties || !schema.properties[key];\n          }).forEach(function (key) {\n            var computedDefault = computeDefaults(validator, additionalPropertiesSchema, get(defaults, [key]), rootSchema, get(formData, [key]), includeUndefinedValues === true);\n            maybeAddDefaultToObject(objectDefaults, key, computedDefault, includeUndefinedValues);\n          });\n        }\n\n        return objectDefaults;\n      }\n\n    case 'array':\n      // Inject defaults into existing array defaults\n      if (Array.isArray(defaults)) {\n        defaults = defaults.map(function (item, idx) {\n          var schemaItem = getInnerSchemaForArrayItem(schema, AdditionalItemsHandling.Fallback, idx);\n          return computeDefaults(validator, schemaItem, item, rootSchema);\n        });\n      } // Deeply inject defaults into already existing form data\n\n\n      if (Array.isArray(rawFormData)) {\n        var schemaItem = getInnerSchemaForArrayItem(schema);\n        defaults = rawFormData.map(function (item, idx) {\n          return computeDefaults(validator, schemaItem, get(defaults, [idx]), rootSchema, item);\n        });\n      }\n\n      if (schema.minItems) {\n        if (!isMultiSelect(validator, schema, rootSchema)) {\n          var defaultsLength = Array.isArray(defaults) ? defaults.length : 0;\n\n          if (schema.minItems > defaultsLength) {\n            var defaultEntries = defaults || []; // populate the array with the defaults\n\n            var fillerSchema = getInnerSchemaForArrayItem(schema, AdditionalItemsHandling.Invert);\n            var fillerDefault = fillerSchema[\"default\"];\n            var fillerEntries = new Array(schema.minItems - defaultsLength).fill(computeDefaults(validator, fillerSchema, fillerDefault, rootSchema)); // then fill up the rest with either the item default or empty, up to minItems\n\n            return defaultEntries.concat(fillerEntries);\n          }\n        }\n\n        return defaults ? defaults : [];\n      }\n\n  }\n\n  return defaults;\n}\n/** Returns the superset of `formData` that includes the given set updated to include any missing fields that have\r\n * computed to have defaults provided in the `schema`.\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param theSchema - The schema for which the default state is desired\r\n * @param [formData] - The current formData, if any, onto which to provide any missing defaults\r\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\r\n * @param [includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.\r\n *          If \"excludeObjectChildren\", cause undefined values for this object and pass `includeUndefinedValues` as\r\n *          false when computing defaults for any nested object properties.\r\n * @returns - The resulting `formData` with all the defaults provided\r\n */\n\n\nfunction getDefaultFormState(validator, theSchema, formData, rootSchema, includeUndefinedValues) {\n  if (includeUndefinedValues === void 0) {\n    includeUndefinedValues = false;\n  }\n\n  if (!isObject(theSchema)) {\n    throw new Error('Invalid schema: ' + theSchema);\n  }\n\n  var schema = retrieveSchema(validator, theSchema, rootSchema, formData);\n  var defaults = computeDefaults(validator, schema, undefined, rootSchema, formData, includeUndefinedValues);\n\n  if (typeof formData === 'undefined' || formData === null || typeof formData === 'number' && isNaN(formData)) {\n    // No form data? Use schema defaults.\n    return defaults;\n  }\n\n  if (isObject(formData)) {\n    return mergeDefaultsWithFormData(defaults, formData);\n  }\n\n  if (Array.isArray(formData)) {\n    return mergeDefaultsWithFormData(defaults, formData);\n  }\n\n  return formData;\n}\n/** Checks to see if the `uiSchema` contains the `widget` field and that the widget is not `hidden`\r\n *\r\n * @param uiSchema - The UI Schema from which to detect if it is customized\r\n * @returns - True if the `uiSchema` describes a custom widget, false otherwise\r\n */\n\n\nfunction isCustomWidget(uiSchema) {\n  if (uiSchema === void 0) {\n    uiSchema = {};\n  }\n\n  return (// TODO: Remove the `&& uiSchema['ui:widget'] !== 'hidden'` once we support hidden widgets for arrays.\n    // https://rjsf-team.github.io/react-jsonschema-form/docs/usage/widgets/#hidden-widgets\n    'widget' in getUiOptions(uiSchema) && getUiOptions(uiSchema)['widget'] !== 'hidden'\n  );\n}\n/** Checks to see if the `schema` and `uiSchema` combination represents an array of files\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param schema - The schema for which check for array of files flag is desired\r\n * @param [uiSchema={}] - The UI schema from which to check the widget\r\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\r\n * @returns - True if schema/uiSchema contains an array of files, otherwise false\r\n */\n\n\nfunction isFilesArray(validator, schema, uiSchema, rootSchema) {\n  if (uiSchema === void 0) {\n    uiSchema = {};\n  }\n\n  if (uiSchema[UI_WIDGET_KEY] === 'files') {\n    return true;\n  }\n\n  if (schema.items) {\n    var itemsSchema = retrieveSchema(validator, schema.items, rootSchema);\n    return itemsSchema.type === 'string' && itemsSchema.format === 'data-url';\n  }\n\n  return false;\n}\n/** Determines whether the combination of `schema` and `uiSchema` properties indicates that the label for the `schema`\r\n * should be displayed in a UI.\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param schema - The schema for which the display label flag is desired\r\n * @param [uiSchema={}] - The UI schema from which to derive potentially displayable information\r\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\r\n * @param [globalOptions={}] - The optional Global UI Schema from which to get any fallback `xxx` options\r\n * @returns - True if the label should be displayed or false if it should not\r\n */\n\n\nfunction getDisplayLabel(validator, schema, uiSchema, rootSchema, globalOptions) {\n  if (uiSchema === void 0) {\n    uiSchema = {};\n  }\n\n  var uiOptions = getUiOptions(uiSchema, globalOptions);\n  var _uiOptions$label = uiOptions.label,\n      label = _uiOptions$label === void 0 ? true : _uiOptions$label;\n  var displayLabel = !!label;\n  var schemaType = getSchemaType(schema);\n\n  if (schemaType === 'array') {\n    displayLabel = isMultiSelect(validator, schema, rootSchema) || isFilesArray(validator, schema, uiSchema, rootSchema) || isCustomWidget(uiSchema);\n  }\n\n  if (schemaType === 'object') {\n    displayLabel = false;\n  }\n\n  if (schemaType === 'boolean' && !uiSchema[UI_WIDGET_KEY]) {\n    displayLabel = false;\n  }\n\n  if (uiSchema[UI_FIELD_KEY]) {\n    displayLabel = false;\n  }\n\n  return displayLabel;\n}\n/** Merges the errors in `additionalErrorSchema` into the existing `validationData` by combining the hierarchies in the\r\n * two `ErrorSchema`s and then appending the error list from the `additionalErrorSchema` obtained by calling\r\n * `validator.toErrorList()` onto the `errors` in the `validationData`. If no `additionalErrorSchema` is passed, then\r\n * `validationData` is returned.\r\n *\r\n * @param validator - The validator used to convert an ErrorSchema to a list of errors\r\n * @param validationData - The current `ValidationData` into which to merge the additional errors\r\n * @param [additionalErrorSchema] - The additional set of errors in an `ErrorSchema`\r\n * @returns - The `validationData` with the additional errors from `additionalErrorSchema` merged into it, if provided.\r\n */\n\n\nfunction mergeValidationData(validator, validationData, additionalErrorSchema) {\n  if (!additionalErrorSchema) {\n    return validationData;\n  }\n\n  var oldErrors = validationData.errors,\n      oldErrorSchema = validationData.errorSchema;\n  var errors = validator.toErrorList(additionalErrorSchema);\n  var errorSchema = additionalErrorSchema;\n\n  if (!isEmpty(oldErrorSchema)) {\n    errorSchema = mergeObjects(oldErrorSchema, additionalErrorSchema, true);\n    errors = [].concat(oldErrors).concat(errors);\n  }\n\n  return {\n    errorSchema: errorSchema,\n    errors: errors\n  };\n}\n\nvar NO_VALUE = /*#__PURE__*/Symbol('no Value');\n/** Sanitize the `data` associated with the `oldSchema` so it is considered appropriate for the `newSchema`. If the new\r\n * schema does not contain any properties, then `undefined` is returned to clear all the form data. Due to the nature\r\n * of schemas, this sanitization happens recursively for nested objects of data. Also, any properties in the old schema\r\n * that are non-existent in the new schema are set to `undefined`. The data sanitization process has the following flow:\r\n *\r\n * - If the new schema is an object that contains a `properties` object then:\r\n *   - Create a `removeOldSchemaData` object, setting each key in the `oldSchema.properties` having `data` to undefined\r\n *   - Create an empty `nestedData` object for use in the key filtering below:\r\n *   - Iterate over each key in the `newSchema.properties` as follows:\r\n *     - Get the `formValue` of the key from the `data`\r\n *     - Get the `oldKeySchema` and `newKeyedSchema` for the key, defaulting to `{}` when it doesn't exist\r\n *     - Retrieve the schema for any refs within each `oldKeySchema` and/or `newKeySchema`\r\n *     - Get the types of the old and new keyed schemas and if the old doesn't exist or the old & new are the same then:\r\n *       - If `removeOldSchemaData` has an entry for the key, delete it since the new schema has the same property\r\n *       - If type of the key in the new schema is `object`:\r\n *         - Store the value from the recursive `sanitizeDataForNewSchema` call in `nestedData[key]`\r\n *       - Otherwise, check for default or const values:\r\n *         - Get the old and new `default` values from the schema and check:\r\n *           - If the new `default` value does not match the form value:\r\n *             - If the old `default` value DOES match the form value, then:\r\n *               - Replace `removeOldSchemaData[key]` with the new `default`\r\n *               - Otherwise, if the new schema is `readOnly` then replace `removeOldSchemaData[key]` with undefined\r\n *         - Get the old and new `const` values from the schema and check:\r\n *           - If the new `const` value does not match the form value:\r\n *           - If the old `const` value DOES match the form value, then:\r\n *             - Replace `removeOldSchemaData[key]` with the new `const`\r\n *             - Otherwise, replace `removeOldSchemaData[key]` with undefined\r\n *   - Once all keys have been processed, return an object built as follows:\r\n *     - `{ ...removeOldSchemaData, ...nestedData, ...pick(data, keysToKeep) }`\r\n * - If the new and old schema types are array and the `data` is an array then:\r\n *   - If the type of the old and new schema `items` are a non-array objects:\r\n *     - Retrieve the schema for any refs within each `oldKeySchema.items` and/or `newKeySchema.items`\r\n *     - If the `type`s of both items are the same (or the old does not have a type):\r\n *       - If the type is \"object\", then:\r\n *         - For each element in the `data` recursively sanitize the data, stopping at `maxItems` if specified\r\n *       - Otherwise, just return the `data` removing any values after `maxItems` if it is set\r\n *   - If the type of the old and new schema `items` are booleans of the same value, return `data` as is\r\n * - Otherwise return `undefined`\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param rootSchema - The root JSON schema of the entire form\r\n * @param [newSchema] - The new schema for which the data is being sanitized\r\n * @param [oldSchema] - The old schema from which the data originated\r\n * @param [data={}] - The form data associated with the schema, defaulting to an empty object when undefined\r\n * @returns - The new form data, with all the fields uniquely associated with the old schema set\r\n *      to `undefined`. Will return `undefined` if the new schema is not an object containing properties.\r\n */\n\nfunction sanitizeDataForNewSchema(validator, rootSchema, newSchema, oldSchema, data) {\n  if (data === void 0) {\n    data = {};\n  } // By default, we will clear the form data\n\n\n  var newFormData; // If the new schema is of type object and that object contains a list of properties\n\n  if (has(newSchema, PROPERTIES_KEY)) {\n    // Create an object containing root-level keys in the old schema, setting each key to undefined to remove the data\n    var removeOldSchemaData = {};\n\n    if (has(oldSchema, PROPERTIES_KEY)) {\n      var properties = get(oldSchema, PROPERTIES_KEY, {});\n      Object.keys(properties).forEach(function (key) {\n        if (has(data, key)) {\n          removeOldSchemaData[key] = undefined;\n        }\n      });\n    }\n\n    var keys = Object.keys(get(newSchema, PROPERTIES_KEY, {})); // Create a place to store nested data that will be a side-effect of the filter\n\n    var nestedData = {};\n    keys.forEach(function (key) {\n      var formValue = get(data, key);\n      var oldKeyedSchema = get(oldSchema, [PROPERTIES_KEY, key], {});\n      var newKeyedSchema = get(newSchema, [PROPERTIES_KEY, key], {}); // Resolve the refs if they exist\n\n      if (has(oldKeyedSchema, REF_KEY)) {\n        oldKeyedSchema = retrieveSchema(validator, oldKeyedSchema, rootSchema, formValue);\n      }\n\n      if (has(newKeyedSchema, REF_KEY)) {\n        newKeyedSchema = retrieveSchema(validator, newKeyedSchema, rootSchema, formValue);\n      } // Now get types and see if they are the same\n\n\n      var oldSchemaTypeForKey = get(oldKeyedSchema, 'type');\n      var newSchemaTypeForKey = get(newKeyedSchema, 'type'); // Check if the old option has the same key with the same type\n\n      if (!oldSchemaTypeForKey || oldSchemaTypeForKey === newSchemaTypeForKey) {\n        if (has(removeOldSchemaData, key)) {\n          // SIDE-EFFECT: remove the undefined value for a key that has the same type between the old and new schemas\n          delete removeOldSchemaData[key];\n        } // If it is an object, we'll recurse and store the resulting sanitized data for the key\n\n\n        if (newSchemaTypeForKey === 'object' || newSchemaTypeForKey === 'array' && Array.isArray(formValue)) {\n          // SIDE-EFFECT: process the new schema type of object recursively to save iterations\n          var itemData = sanitizeDataForNewSchema(validator, rootSchema, newKeyedSchema, oldKeyedSchema, formValue);\n\n          if (itemData !== undefined || newSchemaTypeForKey === 'array') {\n            // only put undefined values for the array type and not the object type\n            nestedData[key] = itemData;\n          }\n        } else {\n          // Ok, the non-object types match, let's make sure that a default or a const of a different value is replaced\n          // with the new default or const. This allows the case where two schemas differ that only by the default/const\n          // value to be properly selected\n          var newOptionDefault = get(newKeyedSchema, 'default', NO_VALUE);\n          var oldOptionDefault = get(oldKeyedSchema, 'default', NO_VALUE);\n\n          if (newOptionDefault !== NO_VALUE && newOptionDefault !== formValue) {\n            if (oldOptionDefault === formValue) {\n              // If the old default matches the formValue, we'll update the new value to match the new default\n              removeOldSchemaData[key] = newOptionDefault;\n            } else if (get(newKeyedSchema, 'readOnly') === true) {\n              // If the new schema has the default set to read-only, treat it like a const and remove the value\n              removeOldSchemaData[key] = undefined;\n            }\n          }\n\n          var newOptionConst = get(newKeyedSchema, 'const', NO_VALUE);\n          var oldOptionConst = get(oldKeyedSchema, 'const', NO_VALUE);\n\n          if (newOptionConst !== NO_VALUE && newOptionConst !== formValue) {\n            // Since this is a const, if the old value matches, replace the value with the new const otherwise clear it\n            removeOldSchemaData[key] = oldOptionConst === formValue ? newOptionConst : undefined;\n          }\n        }\n      }\n    });\n    newFormData = _extends({}, data, removeOldSchemaData, nestedData); // First apply removing the old schema data, then apply the nested data, then apply the old data keys to keep\n  } else if (get(oldSchema, 'type') === 'array' && get(newSchema, 'type') === 'array' && Array.isArray(data)) {\n    var oldSchemaItems = get(oldSchema, 'items');\n    var newSchemaItems = get(newSchema, 'items'); // If any of the array types `items` are arrays (remember arrays are objects) then we'll just drop the data\n    // Eventually, we may want to deal with when either of the `items` are arrays since those tuple validations\n\n    if (typeof oldSchemaItems === 'object' && typeof newSchemaItems === 'object' && !Array.isArray(oldSchemaItems) && !Array.isArray(newSchemaItems)) {\n      if (has(oldSchemaItems, REF_KEY)) {\n        oldSchemaItems = retrieveSchema(validator, oldSchemaItems, rootSchema, data);\n      }\n\n      if (has(newSchemaItems, REF_KEY)) {\n        newSchemaItems = retrieveSchema(validator, newSchemaItems, rootSchema, data);\n      } // Now get types and see if they are the same\n\n\n      var oldSchemaType = get(oldSchemaItems, 'type');\n      var newSchemaType = get(newSchemaItems, 'type'); // Check if the old option has the same key with the same type\n\n      if (!oldSchemaType || oldSchemaType === newSchemaType) {\n        var maxItems = get(newSchema, 'maxItems', -1);\n\n        if (newSchemaType === 'object') {\n          newFormData = data.reduce(function (newValue, aValue) {\n            var itemValue = sanitizeDataForNewSchema(validator, rootSchema, newSchemaItems, oldSchemaItems, aValue);\n\n            if (itemValue !== undefined && (maxItems < 0 || newValue.length < maxItems)) {\n              newValue.push(itemValue);\n            }\n\n            return newValue;\n          }, []);\n        } else {\n          newFormData = maxItems > 0 && data.length > maxItems ? data.slice(0, maxItems) : data;\n        }\n      }\n    } else if (typeof oldSchemaItems === 'boolean' && typeof newSchemaItems === 'boolean' && oldSchemaItems === newSchemaItems) {\n      // If they are both booleans and have the same value just return the data as is otherwise fall-thru to undefined\n      newFormData = data;\n    } // Also probably want to deal with `prefixItems` as tuples with the latest 2020 draft\n\n  }\n\n  return newFormData;\n}\n/** Generates an `IdSchema` object for the `schema`, recursively\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param schema - The schema for which the `IdSchema` is desired\r\n * @param [id] - The base id for the schema\r\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\r\n * @param [formData] - The current formData, if any, to assist retrieving a schema\r\n * @param [idPrefix='root'] - The prefix to use for the id\r\n * @param [idSeparator='_'] - The separator to use for the path segments in the id\r\n * @returns - The `IdSchema` object for the `schema`\r\n */\n\n\nfunction toIdSchema(validator, schema, id, rootSchema, formData, idPrefix, idSeparator) {\n  if (idPrefix === void 0) {\n    idPrefix = 'root';\n  }\n\n  if (idSeparator === void 0) {\n    idSeparator = '_';\n  }\n\n  if (REF_KEY in schema || DEPENDENCIES_KEY in schema || ALL_OF_KEY in schema) {\n    var _schema = retrieveSchema(validator, schema, rootSchema, formData);\n\n    return toIdSchema(validator, _schema, id, rootSchema, formData, idPrefix, idSeparator);\n  }\n\n  if (ITEMS_KEY in schema && !get(schema, [ITEMS_KEY, REF_KEY])) {\n    return toIdSchema(validator, get(schema, ITEMS_KEY), id, rootSchema, formData, idPrefix, idSeparator);\n  }\n\n  var $id = id || idPrefix;\n  var idSchema = {\n    $id: $id\n  };\n\n  if (schema.type === 'object' && PROPERTIES_KEY in schema) {\n    for (var name in schema.properties) {\n      var field = get(schema, [PROPERTIES_KEY, name]);\n      var fieldId = idSchema[ID_KEY] + idSeparator + name;\n      idSchema[name] = toIdSchema(validator, isObject(field) ? field : {}, fieldId, rootSchema, // It's possible that formData is not an object -- this can happen if an\n      // array item has just been added, but not populated with data yet\n      get(formData, [name]), idPrefix, idSeparator);\n    }\n  }\n\n  return idSchema;\n}\n/** Generates an `PathSchema` object for the `schema`, recursively\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param schema - The schema for which the `PathSchema` is desired\r\n * @param [name=''] - The base name for the schema\r\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\r\n * @param [formData] - The current formData, if any, to assist retrieving a schema\r\n * @returns - The `PathSchema` object for the `schema`\r\n */\n\n\nfunction toPathSchema(validator, schema, name, rootSchema, formData) {\n  var _pathSchema;\n\n  if (name === void 0) {\n    name = '';\n  }\n\n  if (REF_KEY in schema || DEPENDENCIES_KEY in schema || ALL_OF_KEY in schema) {\n    var _schema = retrieveSchema(validator, schema, rootSchema, formData);\n\n    return toPathSchema(validator, _schema, name, rootSchema, formData);\n  }\n\n  var pathSchema = (_pathSchema = {}, _pathSchema[NAME_KEY] = name.replace(/^\\./, ''), _pathSchema);\n\n  if (ONE_OF_KEY in schema) {\n    var index = getClosestMatchingOption(validator, rootSchema, formData, schema.oneOf, 0);\n    var _schema2 = schema.oneOf[index];\n    return toPathSchema(validator, _schema2, name, rootSchema, formData);\n  }\n\n  if (ANY_OF_KEY in schema) {\n    var _index = getClosestMatchingOption(validator, rootSchema, formData, schema.anyOf, 0);\n\n    var _schema3 = schema.anyOf[_index];\n    return toPathSchema(validator, _schema3, name, rootSchema, formData);\n  }\n\n  if (ADDITIONAL_PROPERTIES_KEY in schema && schema[ADDITIONAL_PROPERTIES_KEY] !== false) {\n    set(pathSchema, RJSF_ADDITONAL_PROPERTIES_FLAG, true);\n  }\n\n  if (ITEMS_KEY in schema && Array.isArray(formData)) {\n    formData.forEach(function (element, i) {\n      pathSchema[i] = toPathSchema(validator, schema.items, name + \".\" + i, rootSchema, element);\n    });\n  } else if (PROPERTIES_KEY in schema) {\n    for (var property in schema.properties) {\n      var field = get(schema, [PROPERTIES_KEY, property]);\n      pathSchema[property] = toPathSchema(validator, field, name + \".\" + property, rootSchema, // It's possible that formData is not an object -- this can happen if an\n      // array item has just been added, but not populated with data yet\n      get(formData, [property]));\n    }\n  }\n\n  return pathSchema;\n}\n/** The `SchemaUtils` class provides a wrapper around the publicly exported APIs in the `utils/schema` directory such\r\n * that one does not have to explicitly pass the `validator` or `rootSchema` to each method. Since both the `validator`\r\n * and `rootSchema` generally does not change across a `Form`, this allows for providing a simplified set of APIs to the\r\n * `@rjsf/core` components and the various themes as well. This class implements the `SchemaUtilsType` interface.\r\n */\n\n\nvar SchemaUtils = /*#__PURE__*/function () {\n  /** Constructs the `SchemaUtils` instance with the given `validator` and `rootSchema` stored as instance variables\r\n   *\r\n   * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\r\n   * @param rootSchema - The root schema that will be forwarded to all the APIs\r\n   */\n  function SchemaUtils(validator, rootSchema) {\n    this.rootSchema = void 0;\n    this.validator = void 0;\n    this.rootSchema = rootSchema;\n    this.validator = validator;\n  }\n  /** Returns the `ValidatorType` in the `SchemaUtilsType`\r\n   *\r\n   * @returns - The `ValidatorType`\r\n   */\n\n\n  var _proto = SchemaUtils.prototype;\n\n  _proto.getValidator = function getValidator() {\n    return this.validator;\n  }\n  /** Determines whether either the `validator` and `rootSchema` differ from the ones associated with this instance of\r\n   * the `SchemaUtilsType`. If either `validator` or `rootSchema` are falsy, then return false to prevent the creation\r\n   * of a new `SchemaUtilsType` with incomplete properties.\r\n   *\r\n   * @param validator - An implementation of the `ValidatorType` interface that will be compared against the current one\r\n   * @param rootSchema - The root schema that will be compared against the current one\r\n   * @returns - True if the `SchemaUtilsType` differs from the given `validator` or `rootSchema`\r\n   */\n  ;\n\n  _proto.doesSchemaUtilsDiffer = function doesSchemaUtilsDiffer(validator, rootSchema) {\n    if (!validator || !rootSchema) {\n      return false;\n    }\n\n    return this.validator !== validator || !deepEquals(this.rootSchema, rootSchema);\n  }\n  /** Returns the superset of `formData` that includes the given set updated to include any missing fields that have\r\n   * computed to have defaults provided in the `schema`.\r\n   *\r\n   * @param schema - The schema for which the default state is desired\r\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\r\n   * @param [includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.\r\n   *          If \"excludeObjectChildren\", pass `includeUndefinedValues` as false when computing defaults for any nested\r\n   *          object properties.\r\n   * @returns - The resulting `formData` with all the defaults provided\r\n   */\n  ;\n\n  _proto.getDefaultFormState = function getDefaultFormState$1(schema, formData, includeUndefinedValues) {\n    if (includeUndefinedValues === void 0) {\n      includeUndefinedValues = false;\n    }\n\n    return getDefaultFormState(this.validator, schema, formData, this.rootSchema, includeUndefinedValues);\n  }\n  /** Determines whether the combination of `schema` and `uiSchema` properties indicates that the label for the `schema`\r\n   * should be displayed in a UI.\r\n   *\r\n   * @param schema - The schema for which the display label flag is desired\r\n   * @param [uiSchema] - The UI schema from which to derive potentially displayable information\r\n   * @param [globalOptions={}] - The optional Global UI Schema from which to get any fallback `xxx` options\r\n   * @returns - True if the label should be displayed or false if it should not\r\n   */\n  ;\n\n  _proto.getDisplayLabel = function getDisplayLabel$1(schema, uiSchema, globalOptions) {\n    return getDisplayLabel(this.validator, schema, uiSchema, this.rootSchema, globalOptions);\n  }\n  /** Determines which of the given `options` provided most closely matches the `formData`.\r\n   * Returns the index of the option that is valid and is the closest match, or 0 if there is no match.\r\n   *\r\n   * The closest match is determined using the number of matching properties, and more heavily favors options with\r\n   * matching readOnly, default, or const values.\r\n   *\r\n   * @param formData - The form data associated with the schema\r\n   * @param options - The list of options that can be selected from\r\n   * @param [selectedOption] - The index of the currently selected option, defaulted to -1 if not specified\r\n   * @returns - The index of the option that is the closest match to the `formData` or the `selectedOption` if no match\r\n   */\n  ;\n\n  _proto.getClosestMatchingOption = function getClosestMatchingOption$1(formData, options, selectedOption) {\n    return getClosestMatchingOption(this.validator, this.rootSchema, formData, options, selectedOption);\n  }\n  /** Given the `formData` and list of `options`, attempts to find the index of the first option that matches the data.\r\n   * Always returns the first option if there is nothing that matches.\r\n   *\r\n   * @param formData - The current formData, if any, used to figure out a match\r\n   * @param options - The list of options to find a matching options from\r\n   * @returns - The firstindex of the matched option or 0 if none is available\r\n   */\n  ;\n\n  _proto.getFirstMatchingOption = function getFirstMatchingOption$1(formData, options) {\n    return getFirstMatchingOption(this.validator, formData, options, this.rootSchema);\n  }\n  /** Given the `formData` and list of `options`, attempts to find the index of the option that best matches the data.\r\n   * Deprecated, use `getFirstMatchingOption()` instead.\r\n   *\r\n   * @param formData - The current formData, if any, onto which to provide any missing defaults\r\n   * @param options - The list of options to find a matching options from\r\n   * @returns - The index of the matched option or 0 if none is available\r\n   * @deprecated\r\n   */\n  ;\n\n  _proto.getMatchingOption = function getMatchingOption$1(formData, options) {\n    return getMatchingOption(this.validator, formData, options, this.rootSchema);\n  }\n  /** Checks to see if the `schema` and `uiSchema` combination represents an array of files\r\n   *\r\n   * @param schema - The schema for which check for array of files flag is desired\r\n   * @param [uiSchema] - The UI schema from which to check the widget\r\n   * @returns - True if schema/uiSchema contains an array of files, otherwise false\r\n   */\n  ;\n\n  _proto.isFilesArray = function isFilesArray$1(schema, uiSchema) {\n    return isFilesArray(this.validator, schema, uiSchema, this.rootSchema);\n  }\n  /** Checks to see if the `schema` combination represents a multi-select\r\n   *\r\n   * @param schema - The schema for which check for a multi-select flag is desired\r\n   * @returns - True if schema contains a multi-select, otherwise false\r\n   */\n  ;\n\n  _proto.isMultiSelect = function isMultiSelect$1(schema) {\n    return isMultiSelect(this.validator, schema, this.rootSchema);\n  }\n  /** Checks to see if the `schema` combination represents a select\r\n   *\r\n   * @param schema - The schema for which check for a select flag is desired\r\n   * @returns - True if schema contains a select, otherwise false\r\n   */\n  ;\n\n  _proto.isSelect = function isSelect$1(schema) {\n    return isSelect(this.validator, schema, this.rootSchema);\n  }\n  /** Merges the errors in `additionalErrorSchema` into the existing `validationData` by combining the hierarchies in\r\n   * the two `ErrorSchema`s and then appending the error list from the `additionalErrorSchema` obtained by calling\r\n   * `getValidator().toErrorList()` onto the `errors` in the `validationData`. If no `additionalErrorSchema` is passed,\r\n   * then `validationData` is returned.\r\n   *\r\n   * @param validationData - The current `ValidationData` into which to merge the additional errors\r\n   * @param [additionalErrorSchema] - The additional set of errors\r\n   * @returns - The `validationData` with the additional errors from `additionalErrorSchema` merged into it, if provided.\r\n   */\n  ;\n\n  _proto.mergeValidationData = function mergeValidationData$1(validationData, additionalErrorSchema) {\n    return mergeValidationData(this.validator, validationData, additionalErrorSchema);\n  }\n  /** Retrieves an expanded schema that has had all of its conditions, additional properties, references and\r\n   * dependencies resolved and merged into the `schema` given a `rawFormData` that is used to do the potentially\r\n   * recursive resolution.\r\n   *\r\n   * @param schema - The schema for which retrieving a schema is desired\r\n   * @param [rawFormData] - The current formData, if any, to assist retrieving a schema\r\n   * @returns - The schema having its conditions, additional properties, references and dependencies resolved\r\n   */\n  ;\n\n  _proto.retrieveSchema = function retrieveSchema$1(schema, rawFormData) {\n    return retrieveSchema(this.validator, schema, this.rootSchema, rawFormData);\n  }\n  /** Sanitize the `data` associated with the `oldSchema` so it is considered appropriate for the `newSchema`. If the\r\n   * new schema does not contain any properties, then `undefined` is returned to clear all the form data. Due to the\r\n   * nature of schemas, this sanitization happens recursively for nested objects of data. Also, any properties in the\r\n   * old schemas that are non-existent in the new schema are set to `undefined`.\r\n   *\r\n   * @param [newSchema] - The new schema for which the data is being sanitized\r\n   * @param [oldSchema] - The old schema from which the data originated\r\n   * @param [data={}] - The form data associated with the schema, defaulting to an empty object when undefined\r\n   * @returns - The new form data, with all the fields uniquely associated with the old schema set\r\n   *      to `undefined`. Will return `undefined` if the new schema is not an object containing properties.\r\n   */\n  ;\n\n  _proto.sanitizeDataForNewSchema = function sanitizeDataForNewSchema$1(newSchema, oldSchema, data) {\n    return sanitizeDataForNewSchema(this.validator, this.rootSchema, newSchema, oldSchema, data);\n  }\n  /** Generates an `IdSchema` object for the `schema`, recursively\r\n   *\r\n   * @param schema - The schema for which the display label flag is desired\r\n   * @param [id] - The base id for the schema\r\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\r\n   * @param [idPrefix='root'] - The prefix to use for the id\r\n   * @param [idSeparator='_'] - The separator to use for the path segments in the id\r\n   * @returns - The `IdSchema` object for the `schema`\r\n   */\n  ;\n\n  _proto.toIdSchema = function toIdSchema$1(schema, id, formData, idPrefix, idSeparator) {\n    if (idPrefix === void 0) {\n      idPrefix = 'root';\n    }\n\n    if (idSeparator === void 0) {\n      idSeparator = '_';\n    }\n\n    return toIdSchema(this.validator, schema, id, this.rootSchema, formData, idPrefix, idSeparator);\n  }\n  /** Generates an `PathSchema` object for the `schema`, recursively\r\n   *\r\n   * @param schema - The schema for which the display label flag is desired\r\n   * @param [name] - The base name for the schema\r\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\r\n   * @returns - The `PathSchema` object for the `schema`\r\n   */\n  ;\n\n  _proto.toPathSchema = function toPathSchema$1(schema, name, formData) {\n    return toPathSchema(this.validator, schema, name, this.rootSchema, formData);\n  };\n\n  return SchemaUtils;\n}();\n/** Creates a `SchemaUtilsType` interface that is based around the given `validator` and `rootSchema` parameters. The\r\n * resulting interface implementation will forward the `validator` and `rootSchema` to all the wrapped APIs.\r\n *\r\n * @param validator - an implementation of the `ValidatorType` interface that will be forwarded to all the APIs\r\n * @param rootSchema - The root schema that will be forwarded to all the APIs\r\n * @returns - An implementation of a `SchemaUtilsType` interface\r\n */\n\n\nfunction createSchemaUtils(validator, rootSchema) {\n  return new SchemaUtils(validator, rootSchema);\n}\n/** Given the `FileReader.readAsDataURL()` based `dataURI` extracts that data into an actual Blob along with the name\r\n * of that Blob if provided in the URL. If no name is provided, then the name falls back to `unknown`.\r\n *\r\n * @param dataURI - The `DataUrl` potentially containing name and raw data to be converted to a Blob\r\n * @returns - an object containing a Blob and its name, extracted from the URI\r\n */\n\n\nfunction dataURItoBlob(dataURI) {\n  // Split metadata from data\n  var splitted = dataURI.split(','); // Split params\n\n  var params = splitted[0].split(';'); // Get mime-type from params\n\n  var type = params[0].replace('data:', ''); // Filter the name property from params\n\n  var properties = params.filter(function (param) {\n    return param.split('=')[0] === 'name';\n  }); // Look for the name and use unknown if no name property.\n\n  var name;\n\n  if (properties.length !== 1) {\n    name = 'unknown';\n  } else {\n    // Because we filtered out the other property,\n    // we only have the name case here, which we decode to make it human-readable\n    name = decodeURI(properties[0].split('=')[1]);\n  } // Built the Uint8Array Blob parameter from the base64 string.\n\n\n  try {\n    var binary = atob(splitted[1]);\n    var array = [];\n\n    for (var i = 0; i < binary.length; i++) {\n      array.push(binary.charCodeAt(i));\n    } // Create the blob object\n\n\n    var blob = new window.Blob([new Uint8Array(array)], {\n      type: type\n    });\n    return {\n      blob: blob,\n      name: name\n    };\n  } catch (error) {\n    return {\n      blob: {\n        size: 0,\n        type: error.message\n      },\n      name: dataURI\n    };\n  }\n}\n/** Potentially substitutes all replaceable parameters with the associated value(s) from the `params` if available. When\r\n * a `params` array is provided, each value in the array is used to replace any of the replaceable parameters in the\r\n * `inputString` using the `%1`, `%2`, etc. replacement specifiers.\r\n *\r\n * @param inputString - The string which will be potentially updated with replacement parameters\r\n * @param params - The optional list of replaceable parameter values to substitute into the english string\r\n * @returns - The updated string with any replacement specifiers replaced\r\n */\n\n\nfunction replaceStringParameters(inputString, params) {\n  var output = inputString;\n\n  if (Array.isArray(params)) {\n    var parts = output.split(/(%\\d)/);\n    params.forEach(function (param, index) {\n      var partIndex = parts.findIndex(function (part) {\n        return part === \"%\" + (index + 1);\n      });\n\n      if (partIndex >= 0) {\n        parts[partIndex] = param;\n      }\n    });\n    output = parts.join('');\n  }\n\n  return output;\n}\n/** Translates a `TranslatableString` value `stringToTranslate` into english. When a `params` array is provided, each\r\n * value in the array is used to replace any of the replaceable parameters in the `stringToTranslate` using the `%1`,\r\n * `%2`, etc. replacement specifiers.\r\n *\r\n * @param stringToTranslate - The `TranslatableString` value to convert to english\r\n * @param params - The optional list of replaceable parameter values to substitute into the english string\r\n * @returns - The `stringToTranslate` itself with any replaceable parameter values substituted\r\n */\n\n\nfunction englishStringTranslator(stringToTranslate, params) {\n  return replaceStringParameters(stringToTranslate, params);\n}\n/** Returns the value(s) from `allEnumOptions` at the index(es) provided by `valueIndex`. If `valueIndex` is not an\r\n * array AND the index is not valid for `allEnumOptions`, `emptyValue` is returned. If `valueIndex` is an array, AND it\r\n * contains an invalid index, the returned array will have the resulting undefined values filtered out, leaving only\r\n * valid values or in the worst case, an empty array.\r\n *\r\n * @param valueIndex - The index(es) of the value(s) that should be returned\r\n * @param [allEnumOptions=[]] - The list of all the known enumOptions\r\n * @param [emptyValue] - The value to return when the non-array `valueIndex` does not refer to a real option\r\n * @returns - The single or list of values specified by the single or list of indexes if they are valid. Otherwise,\r\n *        `emptyValue` or an empty list.\r\n */\n\n\nfunction enumOptionsValueForIndex(valueIndex, allEnumOptions, emptyValue) {\n  if (allEnumOptions === void 0) {\n    allEnumOptions = [];\n  }\n\n  if (Array.isArray(valueIndex)) {\n    return valueIndex.map(function (index) {\n      return enumOptionsValueForIndex(index, allEnumOptions);\n    }).filter(function (val) {\n      return val;\n    });\n  } // So Number(null) and Number('') both return 0, so use emptyValue for those two values\n\n\n  var index = valueIndex === '' || valueIndex === null ? -1 : Number(valueIndex);\n  var option = allEnumOptions[index];\n  return option ? option.value : emptyValue;\n}\n/** Removes the enum option value at the `valueIndex` from the currently `selected` (list of) value(s). If `selected` is\r\n * a list, then that list is updated to remove the enum option value with the `valueIndex` in `allEnumOptions`. If it is\r\n * a single value, then if the enum option value with the `valueIndex` in `allEnumOptions` matches `selected`, undefined\r\n * is returned, otherwise the `selected` value is returned.\r\n *\r\n * @param valueIndex - The index of the value to be removed from the selected list or single value\r\n * @param selected - The current (list of) selected value(s)\r\n * @param [allEnumOptions=[]] - The list of all the known enumOptions\r\n * @returns - The updated `selected` with the enum option value at `valueIndex` in `allEnumOptions` removed from it,\r\n *        unless `selected` is a single value. In that case, if the `valueIndex` value matches `selected`, returns\r\n *        undefined, otherwise `selected`.\r\n */\n\n\nfunction enumOptionsDeselectValue(valueIndex, selected, allEnumOptions) {\n  if (allEnumOptions === void 0) {\n    allEnumOptions = [];\n  }\n\n  var value = enumOptionsValueForIndex(valueIndex, allEnumOptions);\n\n  if (Array.isArray(selected)) {\n    return selected.filter(function (v) {\n      return !isEqual(v, value);\n    });\n  }\n\n  return isEqual(value, selected) ? undefined : selected;\n}\n/** Determines whether the given `value` is (one of) the `selected` value(s).\r\n *\r\n * @param value - The value being checked to see if it is selected\r\n * @param selected - The current selected value or list of values\r\n * @returns - true if the `value` is one of the `selected` ones, false otherwise\r\n */\n\n\nfunction enumOptionsIsSelected(value, selected) {\n  if (Array.isArray(selected)) {\n    return selected.some(function (sel) {\n      return isEqual(sel, value);\n    });\n  }\n\n  return isEqual(selected, value);\n}\n/** Returns the index(es) of the options in `allEnumOptions` whose value(s) match the ones in `value`. All the\r\n * `enumOptions` are filtered based on whether they are a \"selected\" `value` and the index of each selected one is then\r\n * stored in an array. If `multiple` is true, that array is returned, otherwise the first element in the array is\r\n * returned.\r\n *\r\n * @param value - The single value or list of values for which indexes are desired\r\n * @param [allEnumOptions=[]] - The list of all the known enumOptions\r\n * @param [multiple=false] - Optional flag, if true will return a list of index, otherwise a single one\r\n * @returns - A single string index for the first `value` in `allEnumOptions`, if not `multiple`. Otherwise, the list\r\n *        of indexes for (each of) the value(s) in `value`.\r\n */\n\n\nfunction enumOptionsIndexForValue(value, allEnumOptions, multiple) {\n  if (allEnumOptions === void 0) {\n    allEnumOptions = [];\n  }\n\n  if (multiple === void 0) {\n    multiple = false;\n  }\n\n  var selectedIndexes = allEnumOptions.map(function (opt, index) {\n    return enumOptionsIsSelected(opt.value, value) ? String(index) : undefined;\n  }).filter(function (opt) {\n    return typeof opt !== 'undefined';\n  });\n\n  if (!multiple) {\n    return selectedIndexes[0];\n  }\n\n  return selectedIndexes;\n}\n/** Add the enum option value at the `valueIndex` to the list of `selected` values in the proper order as defined by\r\n * `allEnumOptions`\r\n *\r\n * @param valueIndex - The index of the value that should be selected\r\n * @param selected - The current list of selected values\r\n * @param [allEnumOptions=[]] - The list of all the known enumOptions\r\n * @returns - The updated list of selected enum values with enum value at the `valueIndex` added to it\r\n */\n\n\nfunction enumOptionsSelectValue(valueIndex, selected, allEnumOptions) {\n  if (allEnumOptions === void 0) {\n    allEnumOptions = [];\n  }\n\n  var value = enumOptionsValueForIndex(valueIndex, allEnumOptions);\n\n  if (value) {\n    var index = allEnumOptions.findIndex(function (opt) {\n      return value === opt.value;\n    });\n    var all = allEnumOptions.map(function (_ref) {\n      var val = _ref.value;\n      return val;\n    });\n    var updated = selected.slice(0, index).concat(value, selected.slice(index)); // As inserting values at predefined index positions doesn't work with empty\n    // arrays, we need to reorder the updated selection to match the initial order\n\n    return updated.sort(function (a, b) {\n      return Number(all.indexOf(a) > all.indexOf(b));\n    });\n  }\n\n  return selected;\n}\n/** The `ErrorSchemaBuilder<T>` is used to build an `ErrorSchema<T>` since the definition of the `ErrorSchema` type is\r\n * designed for reading information rather than writing it. Use this class to add, replace or clear errors in an error\r\n * schema by using either dotted path or an array of path names. Once you are done building the `ErrorSchema`, you can\r\n * get the result and/or reset all the errors back to an initial set and start again.\r\n */\n\n\nvar ErrorSchemaBuilder = /*#__PURE__*/function () {\n  /** The error schema being built\r\n   *\r\n   * @private\r\n   */\n\n  /** Construct an `ErrorSchemaBuilder` with an optional initial set of errors in an `ErrorSchema`.\r\n   *\r\n   * @param [initialSchema] - The optional set of initial errors, that will be cloned into the class\r\n   */\n  function ErrorSchemaBuilder(initialSchema) {\n    this.errorSchema = {};\n    this.resetAllErrors(initialSchema);\n  }\n  /** Returns the `ErrorSchema` that has been updated by the methods of the `ErrorSchemaBuilder`\r\n   */\n\n\n  var _proto = ErrorSchemaBuilder.prototype;\n  /** Will get an existing `ErrorSchema` at the specified `pathOfError` or create and return one.\r\n   *\r\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to add the error(s)\r\n   * @returns - The error block for the given `pathOfError` or the root if not provided\r\n   * @private\r\n   */\n\n  _proto.getOrCreateErrorBlock = function getOrCreateErrorBlock(pathOfError) {\n    var hasPath = Array.isArray(pathOfError) && pathOfError.length > 0 || typeof pathOfError === 'string';\n    var errorBlock = hasPath ? get(this.errorSchema, pathOfError) : this.errorSchema;\n\n    if (!errorBlock && pathOfError) {\n      errorBlock = {};\n      set(this.errorSchema, pathOfError, errorBlock);\n    }\n\n    return errorBlock;\n  }\n  /** Resets all errors in the `ErrorSchemaBuilder` back to the `initialSchema` if provided, otherwise an empty set.\r\n   *\r\n   * @param [initialSchema] - The optional set of initial errors, that will be cloned into the class\r\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\r\n   */\n  ;\n\n  _proto.resetAllErrors = function resetAllErrors(initialSchema) {\n    this.errorSchema = initialSchema ? cloneDeep(initialSchema) : {};\n    return this;\n  }\n  /** Adds the `errorOrList` to the list of errors in the `ErrorSchema` at either the root level or the location within\r\n   * the schema described by the `pathOfError`. For more information about how to specify the path see the\r\n   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).\r\n   *\r\n   * @param errorOrList - The error or list of errors to add into the `ErrorSchema`\r\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to add the error(s)\r\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\r\n   */\n  ;\n\n  _proto.addErrors = function addErrors(errorOrList, pathOfError) {\n    var errorBlock = this.getOrCreateErrorBlock(pathOfError);\n    var errorsList = get(errorBlock, ERRORS_KEY);\n\n    if (!Array.isArray(errorsList)) {\n      errorsList = [];\n      errorBlock[ERRORS_KEY] = errorsList;\n    }\n\n    if (Array.isArray(errorOrList)) {\n      var _errorsList;\n\n      (_errorsList = errorsList).push.apply(_errorsList, errorOrList);\n    } else {\n      errorsList.push(errorOrList);\n    }\n\n    return this;\n  }\n  /** Sets/replaces the `errorOrList` as the error(s) in the `ErrorSchema` at either the root level or the location\r\n   * within the schema described by the `pathOfError`. For more information about how to specify the path see the\r\n   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).\r\n   *\r\n   * @param errorOrList - The error or list of errors to set into the `ErrorSchema`\r\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to set the error(s)\r\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\r\n   */\n  ;\n\n  _proto.setErrors = function setErrors(errorOrList, pathOfError) {\n    var errorBlock = this.getOrCreateErrorBlock(pathOfError); // Effectively clone the array being given to prevent accidental outside manipulation of the given list\n\n    var listToAdd = Array.isArray(errorOrList) ? [].concat(errorOrList) : [errorOrList];\n    set(errorBlock, ERRORS_KEY, listToAdd);\n    return this;\n  }\n  /** Clears the error(s) in the `ErrorSchema` at either the root level or the location within the schema described by\r\n   * the `pathOfError`. For more information about how to specify the path see the\r\n   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).\r\n   *\r\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to clear the error(s)\r\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\r\n   */\n  ;\n\n  _proto.clearErrors = function clearErrors(pathOfError) {\n    var errorBlock = this.getOrCreateErrorBlock(pathOfError);\n    set(errorBlock, ERRORS_KEY, []);\n    return this;\n  };\n\n  _createClass(ErrorSchemaBuilder, [{\n    key: \"ErrorSchema\",\n    get: function get() {\n      return this.errorSchema;\n    }\n  }]);\n\n  return ErrorSchemaBuilder;\n}();\n/** Extracts the range spec information `{ step?: number, min?: number, max?: number }` that can be spread onto an HTML\r\n * input from the range analog in the schema `{ multipleOf?: number, minimum?: number, maximum?: number }`.\r\n *\r\n * @param schema - The schema from which to extract the range spec\r\n * @returns - A range specification from the schema\r\n */\n\n\nfunction rangeSpec(schema) {\n  var spec = {};\n\n  if (schema.multipleOf) {\n    spec.step = schema.multipleOf;\n  }\n\n  if (schema.minimum || schema.minimum === 0) {\n    spec.min = schema.minimum;\n  }\n\n  if (schema.maximum || schema.maximum === 0) {\n    spec.max = schema.maximum;\n  }\n\n  return spec;\n}\n/** Using the `schema`, `defaultType` and `options`, extract out the props for the <input> element that make sense.\r\n *\r\n * @param schema - The schema for the field provided by the widget\r\n * @param [defaultType] - The default type, if any, for the field provided by the widget\r\n * @param [options={}] - The UI Options for the field provided by the widget\r\n * @param [autoDefaultStepAny=true] - Determines whether to auto-default step=any when the type is number and no step\r\n * @returns - The extracted `InputPropsType` object\r\n */\n\n\nfunction getInputProps(schema, defaultType, options, autoDefaultStepAny) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  if (autoDefaultStepAny === void 0) {\n    autoDefaultStepAny = true;\n  }\n\n  var inputProps = _extends({\n    type: defaultType || 'text'\n  }, rangeSpec(schema)); // If options.inputType is set use that as the input type\n\n\n  if (options.inputType) {\n    inputProps.type = options.inputType;\n  } else if (!defaultType) {\n    // If the schema is of type number or integer, set the input type to number\n    if (schema.type === 'number') {\n      inputProps.type = 'number'; // Only add step if one isn't already defined and we are auto-defaulting the \"any\" step\n\n      if (autoDefaultStepAny && inputProps.step === undefined) {\n        // Setting step to 'any' fixes a bug in Safari where decimals are not\n        // allowed in number inputs\n        inputProps.step = 'any';\n      }\n    } else if (schema.type === 'integer') {\n      inputProps.type = 'number'; // Only add step if one isn't already defined\n\n      if (inputProps.step === undefined) {\n        // Since this is integer, you always want to step up or down in multiples of 1\n        inputProps.step = 1;\n      }\n    }\n  }\n\n  if (options.autocomplete) {\n    inputProps.autoComplete = options.autocomplete;\n  }\n\n  return inputProps;\n}\n/** The default submit button options, exported for testing purposes\r\n */\n\n\nvar DEFAULT_OPTIONS = {\n  props: {\n    disabled: false\n  },\n  submitText: 'Submit',\n  norender: false\n};\n/** Extracts any `ui:submitButtonOptions` from the `uiSchema` and merges them onto the `DEFAULT_OPTIONS`\r\n *\r\n * @param [uiSchema={}] - the UI Schema from which to extract submit button props\r\n * @returns - The merging of the `DEFAULT_OPTIONS` with any custom ones\r\n */\n\nfunction getSubmitButtonOptions(uiSchema) {\n  if (uiSchema === void 0) {\n    uiSchema = {};\n  }\n\n  var uiOptions = getUiOptions(uiSchema);\n\n  if (uiOptions && uiOptions[SUBMIT_BTN_OPTIONS_KEY]) {\n    var options = uiOptions[SUBMIT_BTN_OPTIONS_KEY];\n    return _extends({}, DEFAULT_OPTIONS, options);\n  }\n\n  return DEFAULT_OPTIONS;\n}\n/** Returns the template with the given `name` from either the `uiSchema` if it is defined or from the `registry`\r\n * otherwise. NOTE, since `ButtonTemplates` are not overridden in `uiSchema` only those in the `registry` are returned.\r\n *\r\n * @param name - The name of the template to fetch, restricted to the keys of `TemplatesType`\r\n * @param registry - The `Registry` from which to read the template\r\n * @param [uiOptions={}] - The `UIOptionsType` from which to read an alternate template\r\n * @returns - The template from either the `uiSchema` or `registry` for the `name`\r\n */\n\n\nfunction getTemplate(name, registry, uiOptions) {\n  if (uiOptions === void 0) {\n    uiOptions = {};\n  }\n\n  var templates = registry.templates;\n\n  if (name === 'ButtonTemplates') {\n    return templates[name];\n  }\n\n  return (// Evaluating uiOptions[name] results in TS2590: Expression produces a union type that is too complex to represent\n    // To avoid that, we cast uiOptions to `any` before accessing the name field\n    uiOptions[name] || templates[name]\n  );\n}\n\nvar _excluded = [\"options\"];\n/** The map of schema types to widget type to widget name\r\n */\n\nvar widgetMap = {\n  \"boolean\": {\n    checkbox: 'CheckboxWidget',\n    radio: 'RadioWidget',\n    select: 'SelectWidget',\n    hidden: 'HiddenWidget'\n  },\n  string: {\n    text: 'TextWidget',\n    password: 'PasswordWidget',\n    email: 'EmailWidget',\n    hostname: 'TextWidget',\n    ipv4: 'TextWidget',\n    ipv6: 'TextWidget',\n    uri: 'URLWidget',\n    'data-url': 'FileWidget',\n    radio: 'RadioWidget',\n    select: 'SelectWidget',\n    textarea: 'TextareaWidget',\n    hidden: 'HiddenWidget',\n    date: 'DateWidget',\n    datetime: 'DateTimeWidget',\n    'date-time': 'DateTimeWidget',\n    'alt-date': 'AltDateWidget',\n    'alt-datetime': 'AltDateTimeWidget',\n    time: 'TimeWidget',\n    color: 'ColorWidget',\n    file: 'FileWidget'\n  },\n  number: {\n    text: 'TextWidget',\n    select: 'SelectWidget',\n    updown: 'UpDownWidget',\n    range: 'RangeWidget',\n    radio: 'RadioWidget',\n    hidden: 'HiddenWidget'\n  },\n  integer: {\n    text: 'TextWidget',\n    select: 'SelectWidget',\n    updown: 'UpDownWidget',\n    range: 'RangeWidget',\n    radio: 'RadioWidget',\n    hidden: 'HiddenWidget'\n  },\n  array: {\n    select: 'SelectWidget',\n    checkboxes: 'CheckboxesWidget',\n    files: 'FileWidget',\n    hidden: 'HiddenWidget'\n  }\n};\n/** Wraps the given widget with stateless functional component that will merge any `defaultProps.options` with the\r\n * `options` that are provided in the props. It will add the wrapper component as a `MergedWidget` property onto the\r\n * `Widget` so that future attempts to wrap `AWidget` will return the already existing wrapper.\r\n *\r\n * @param AWidget - A widget that will be wrapped or one that is already wrapped\r\n * @returns - The wrapper widget\r\n */\n\nfunction mergeWidgetOptions(AWidget) {\n  var MergedWidget = get(AWidget, 'MergedWidget'); // cache return value as property of widget for proper react reconciliation\n\n  if (!MergedWidget) {\n    var defaultOptions = AWidget.defaultProps && AWidget.defaultProps.options || {};\n\n    MergedWidget = function MergedWidget(_ref) {\n      var options = _ref.options,\n          props = _objectWithoutPropertiesLoose(_ref, _excluded);\n\n      return jsx(AWidget, _extends({\n        options: _extends({}, defaultOptions, options)\n      }, props));\n    };\n\n    set(AWidget, 'MergedWidget', MergedWidget);\n  }\n\n  return MergedWidget;\n}\n/** Given a schema representing a field to render and either the name or actual `Widget` implementation, returns the\r\n * React component that is used to render the widget. If the `widget` is already a React component, then it is wrapped\r\n * with a `MergedWidget`. Otherwise an attempt is made to look up the widget inside of the `registeredWidgets` map based\r\n * on the schema type and `widget` name. If no widget component can be found an `Error` is thrown.\r\n *\r\n * @param schema - The schema for the field\r\n * @param [widget] - Either the name of the widget OR a `Widget` implementation to use\r\n * @param [registeredWidgets={}] - A registry of widget name to `Widget` implementation\r\n * @returns - The `Widget` component to use\r\n * @throws - An error if there is no `Widget` component that can be returned\r\n */\n\n\nfunction getWidget(schema, widget, registeredWidgets) {\n  if (registeredWidgets === void 0) {\n    registeredWidgets = {};\n  }\n\n  var type = getSchemaType(schema);\n\n  if (typeof widget === 'function' || widget && ReactIs.isForwardRef( /*#__PURE__*/createElement(widget)) || ReactIs.isMemo(widget)) {\n    return mergeWidgetOptions(widget);\n  }\n\n  if (typeof widget !== 'string') {\n    throw new Error(\"Unsupported widget definition: \" + typeof widget);\n  }\n\n  if (widget in registeredWidgets) {\n    var registeredWidget = registeredWidgets[widget];\n    return getWidget(schema, registeredWidget, registeredWidgets);\n  }\n\n  if (typeof type === 'string') {\n    if (!(type in widgetMap)) {\n      throw new Error(\"No widget for type '\" + type + \"'\");\n    }\n\n    if (widget in widgetMap[type]) {\n      var _registeredWidget = registeredWidgets[widgetMap[type][widget]];\n      return getWidget(schema, _registeredWidget, registeredWidgets);\n    }\n  }\n\n  throw new Error(\"No widget '\" + widget + \"' for type '\" + type + \"'\");\n}\n/** Detects whether the `widget` exists for the `schema` with the associated `registryWidgets` and returns true if it\r\n * does, or false if it doesn't.\r\n *\r\n * @param schema - The schema for the field\r\n * @param widget - Either the name of the widget OR a `Widget` implementation to use\r\n * @param [registeredWidgets={}] - A registry of widget name to `Widget` implementation\r\n * @returns - True if the widget exists, false otherwise\r\n */\n\n\nfunction hasWidget(schema, widget, registeredWidgets) {\n  if (registeredWidgets === void 0) {\n    registeredWidgets = {};\n  }\n\n  try {\n    getWidget(schema, widget, registeredWidgets);\n    return true;\n  } catch (e) {\n    var err = e;\n\n    if (err.message && (err.message.startsWith('No widget') || err.message.startsWith('Unsupported widget'))) {\n      return false;\n    }\n\n    throw e;\n  }\n}\n/** Generates a consistent `id` pattern for a given `id` and a `suffix`\r\n *\r\n * @param id - Either simple string id or an IdSchema from which to extract it\r\n * @param suffix - The suffix to append to the id\r\n */\n\n\nfunction idGenerator(id, suffix) {\n  var theId = isString(id) ? id : id[ID_KEY];\n  return theId + \"__\" + suffix;\n}\n/** Return a consistent `id` for the field description element\r\n *\r\n * @param id - Either simple string id or an IdSchema from which to extract it\r\n * @returns - The consistent id for the field description element from the given `id`\r\n */\n\n\nfunction descriptionId(id) {\n  return idGenerator(id, 'description');\n}\n/** Return a consistent `id` for the field error element\r\n *\r\n * @param id - Either simple string id or an IdSchema from which to extract it\r\n * @returns - The consistent id for the field error element from the given `id`\r\n */\n\n\nfunction errorId(id) {\n  return idGenerator(id, 'error');\n}\n/** Return a consistent `id` for the field examples element\r\n *\r\n * @param id - Either simple string id or an IdSchema from which to extract it\r\n * @returns - The consistent id for the field examples element from the given `id`\r\n */\n\n\nfunction examplesId(id) {\n  return idGenerator(id, 'examples');\n}\n/** Return a consistent `id` for the field help element\r\n *\r\n * @param id - Either simple string id or an IdSchema from which to extract it\r\n * @returns - The consistent id for the field help element from the given `id`\r\n */\n\n\nfunction helpId(id) {\n  return idGenerator(id, 'help');\n}\n/** Return a consistent `id` for the field title element\r\n *\r\n * @param id - Either simple string id or an IdSchema from which to extract it\r\n * @returns - The consistent id for the field title element from the given `id`\r\n */\n\n\nfunction titleId(id) {\n  return idGenerator(id, 'title');\n}\n/** Return a list of element ids that contain additional information about the field that can be used to as the aria\r\n * description of the field. This is correctly omitting `titleId` which would be \"labeling\" rather than \"describing\" the\r\n * element.\r\n *\r\n * @param id - Either simple string id or an IdSchema from which to extract it\r\n * @param [includeExamples=false] - Optional flag, if true, will add the `examplesId` into the list\r\n * @returns - The string containing the list of ids for use in an `aria-describedBy` attribute\r\n */\n\n\nfunction ariaDescribedByIds(id, includeExamples) {\n  if (includeExamples === void 0) {\n    includeExamples = false;\n  }\n\n  var examples = includeExamples ? \" \" + examplesId(id) : '';\n  return errorId(id) + \" \" + descriptionId(id) + \" \" + helpId(id) + examples;\n}\n/** Return a consistent `id` for the `optionIndex`s of a `Radio` or `Checkboxes` widget\r\n *\r\n * @param id - The id of the parent component for the option\r\n * @param optionIndex - The index of the option for which the id is desired\r\n * @returns - An id for the option index based on the parent `id`\r\n */\n\n\nfunction optionId(id, optionIndex) {\n  return id + \"-\" + optionIndex;\n}\n/** Converts a local Date string into a UTC date string\r\n *\r\n * @param dateString - The string representation of a date as accepted by the `Date()` constructor\r\n * @returns - A UTC date string if `dateString` is truthy, otherwise undefined\r\n */\n\n\nfunction localToUTC(dateString) {\n  return dateString ? new Date(dateString).toJSON() : undefined;\n}\n/** Returns the constant value from the schema when it is either a single value enum or has a const key. Otherwise\r\n * throws an error.\r\n *\r\n * @param schema - The schema from which to obtain the constant value\r\n * @returns - The constant value for the schema\r\n * @throws - Error when the schema does not have a constant value\r\n */\n\n\nfunction toConstant(schema) {\n  if (ENUM_KEY in schema && Array.isArray(schema[\"enum\"]) && schema[\"enum\"].length === 1) {\n    return schema[\"enum\"][0];\n  }\n\n  if (CONST_KEY in schema) {\n    return schema[\"const\"];\n  }\n\n  throw new Error('schema cannot be inferred as a constant');\n}\n/** Gets the list of options from the schema. If the schema has an enum list, then those enum values are returned. The\r\n * labels for the options will be extracted from the non-standard, RJSF-deprecated `enumNames` if it exists, otherwise\r\n * the label will be the same as the `value`. If the schema has a `oneOf` or `anyOf`, then the value is the list of\r\n * `const` values from the schema and the label is either the `schema.title` or the value.\r\n *\r\n * @param schema - The schema from which to extract the options list\r\n * @returns - The list of options from the schema\r\n */\n\n\nfunction optionsList(schema) {\n  // enumNames was deprecated in v5 and is intentionally omitted from the RJSFSchema type.\n  // Cast the type to include enumNames so the feature still works.\n  var schemaWithEnumNames = schema;\n\n  if (schemaWithEnumNames.enumNames && process.env.NODE_ENV !== 'production') {\n    console.warn('The enumNames property is deprecated and may be removed in a future major release.');\n  }\n\n  if (schema[\"enum\"]) {\n    return schema[\"enum\"].map(function (value, i) {\n      var label = schemaWithEnumNames.enumNames && schemaWithEnumNames.enumNames[i] || String(value);\n      return {\n        label: label,\n        value: value\n      };\n    });\n  }\n\n  var altSchemas = schema.oneOf || schema.anyOf;\n  return altSchemas && altSchemas.map(function (aSchemaDef) {\n    var aSchema = aSchemaDef;\n    var value = toConstant(aSchema);\n    var label = aSchema.title || String(value);\n    return {\n      schema: aSchema,\n      label: label,\n      value: value\n    };\n  });\n}\n/** Given a list of `properties` and an `order` list, returns a list that contains the `properties` ordered correctly.\r\n * If `order` is not an array, then the untouched `properties` list is returned. Otherwise `properties` is ordered per\r\n * the `order` list. If `order` contains a '*' then any `properties` that are not mentioned explicity in `order` will be\r\n * places in the location of the `*`.\r\n *\r\n * @param properties - The list of property keys to be ordered\r\n * @param order - An array of property keys to be ordered first, with an optional '*' property\r\n * @returns - A list with the `properties` ordered\r\n * @throws - Error when the properties cannot be ordered correctly\r\n */\n\n\nfunction orderProperties(properties, order) {\n  if (!Array.isArray(order)) {\n    return properties;\n  }\n\n  var arrayToHash = function arrayToHash(arr) {\n    return arr.reduce(function (prev, curr) {\n      prev[curr] = true;\n      return prev;\n    }, {});\n  };\n\n  var errorPropList = function errorPropList(arr) {\n    return arr.length > 1 ? \"properties '\" + arr.join(\"', '\") + \"'\" : \"property '\" + arr[0] + \"'\";\n  };\n\n  var propertyHash = arrayToHash(properties);\n  var orderFiltered = order.filter(function (prop) {\n    return prop === '*' || propertyHash[prop];\n  });\n  var orderHash = arrayToHash(orderFiltered);\n  var rest = properties.filter(function (prop) {\n    return !orderHash[prop];\n  });\n  var restIndex = orderFiltered.indexOf('*');\n\n  if (restIndex === -1) {\n    if (rest.length) {\n      throw new Error(\"uiSchema order list does not contain \" + errorPropList(rest));\n    }\n\n    return orderFiltered;\n  }\n\n  if (restIndex !== orderFiltered.lastIndexOf('*')) {\n    throw new Error('uiSchema order list contains more than one wildcard item');\n  }\n\n  var complete = [].concat(orderFiltered);\n  complete.splice.apply(complete, [restIndex, 1].concat(rest));\n  return complete;\n}\n/** Returns a string representation of the `num` that is padded with leading \"0\"s if necessary\r\n *\r\n * @param num - The number to pad\r\n * @param width - The width of the string at which no lead padding is necessary\r\n * @returns - The number converted to a string with leading zero padding if the number of digits is less than `width`\r\n */\n\n\nfunction pad(num, width) {\n  var s = String(num);\n\n  while (s.length < width) {\n    s = '0' + s;\n  }\n\n  return s;\n}\n/** Parses the `dateString` into a `DateObject`, including the time information when `includeTime` is true\r\n *\r\n * @param dateString - The date string to parse into a DateObject\r\n * @param [includeTime=true] - Optional flag, if false, will not include the time data into the object\r\n * @returns - The date string converted to a `DateObject`\r\n * @throws - Error when the date cannot be parsed from the string\r\n */\n\n\nfunction parseDateString(dateString, includeTime) {\n  if (includeTime === void 0) {\n    includeTime = true;\n  }\n\n  if (!dateString) {\n    return {\n      year: -1,\n      month: -1,\n      day: -1,\n      hour: includeTime ? -1 : 0,\n      minute: includeTime ? -1 : 0,\n      second: includeTime ? -1 : 0\n    };\n  }\n\n  var date = new Date(dateString);\n\n  if (Number.isNaN(date.getTime())) {\n    throw new Error('Unable to parse date ' + dateString);\n  }\n\n  return {\n    year: date.getUTCFullYear(),\n    month: date.getUTCMonth() + 1,\n    day: date.getUTCDate(),\n    hour: includeTime ? date.getUTCHours() : 0,\n    minute: includeTime ? date.getUTCMinutes() : 0,\n    second: includeTime ? date.getUTCSeconds() : 0\n  };\n}\n/** Check to see if a `schema` specifies that a value must be true. This happens when:\r\n * - `schema.const` is truthy\r\n * - `schema.enum` == `[true]`\r\n * - `schema.anyOf` or `schema.oneOf` has a single value which recursively returns true\r\n * - `schema.allOf` has at least one value which recursively returns true\r\n *\r\n * @param schema - The schema to check\r\n * @returns - True if the schema specifies a value that must be true, false otherwise\r\n */\n\n\nfunction schemaRequiresTrueValue(schema) {\n  // Check if const is a truthy value\n  if (schema[\"const\"]) {\n    return true;\n  } // Check if an enum has a single value of true\n\n\n  if (schema[\"enum\"] && schema[\"enum\"].length === 1 && schema[\"enum\"][0] === true) {\n    return true;\n  } // If anyOf has a single value, evaluate the subschema\n\n\n  if (schema.anyOf && schema.anyOf.length === 1) {\n    return schemaRequiresTrueValue(schema.anyOf[0]);\n  } // If oneOf has a single value, evaluate the subschema\n\n\n  if (schema.oneOf && schema.oneOf.length === 1) {\n    return schemaRequiresTrueValue(schema.oneOf[0]);\n  } // Evaluate each subschema in allOf, to see if one of them requires a true value\n\n\n  if (schema.allOf) {\n    var schemaSome = function schemaSome(subSchema) {\n      return schemaRequiresTrueValue(subSchema);\n    };\n\n    return schema.allOf.some(schemaSome);\n  }\n\n  return false;\n}\n/** Determines whether the given `component` should be rerendered by comparing its current set of props and state\r\n * against the next set. If either of those two sets are not the same, then the component should be rerendered.\r\n *\r\n * @param component - A React component being checked\r\n * @param nextProps - The next set of props against which to check\r\n * @param nextState - The next set of state against which to check\r\n * @returns - True if the component should be re-rendered, false otherwise\r\n */\n\n\nfunction shouldRender(component, nextProps, nextState) {\n  var props = component.props,\n      state = component.state;\n  return !deepEquals(props, nextProps) || !deepEquals(state, nextState);\n}\n/** Returns a UTC date string for the given `dateObject`. If `time` is false, then the time portion of the string is\r\n * removed.\r\n *\r\n * @param dateObject - The `DateObject` to convert to a date string\r\n * @param [time=true] - Optional flag used to remove the time portion of the date string if false\r\n * @returns - The UTC date string\r\n */\n\n\nfunction toDateString(dateObject, time) {\n  if (time === void 0) {\n    time = true;\n  }\n\n  var year = dateObject.year,\n      month = dateObject.month,\n      day = dateObject.day,\n      _dateObject$hour = dateObject.hour,\n      hour = _dateObject$hour === void 0 ? 0 : _dateObject$hour,\n      _dateObject$minute = dateObject.minute,\n      minute = _dateObject$minute === void 0 ? 0 : _dateObject$minute,\n      _dateObject$second = dateObject.second,\n      second = _dateObject$second === void 0 ? 0 : _dateObject$second;\n  var utcTime = Date.UTC(year, month - 1, day, hour, minute, second);\n  var datetime = new Date(utcTime).toJSON();\n  return time ? datetime : datetime.slice(0, 10);\n}\n/** Converts a UTC date string into a local Date format\r\n *\r\n * @param jsonDate - A UTC date string\r\n * @returns - An empty string when `jsonDate` is falsey, otherwise a date string in local format\r\n */\n\n\nfunction utcToLocal(jsonDate) {\n  if (!jsonDate) {\n    return '';\n  } // required format of `'yyyy-MM-ddThh:mm' followed by optional ':ss' or ':ss.SSS'\n  // https://html.spec.whatwg.org/multipage/input.html#local-date-and-time-state-(type%3Ddatetime-local)\n  // > should be a _valid local date and time string_ (not GMT)\n  // Note - date constructor passed local ISO-8601 does not correctly\n  // change time to UTC in node pre-8\n\n\n  var date = new Date(jsonDate);\n  var yyyy = pad(date.getFullYear(), 4);\n  var MM = pad(date.getMonth() + 1, 2);\n  var dd = pad(date.getDate(), 2);\n  var hh = pad(date.getHours(), 2);\n  var mm = pad(date.getMinutes(), 2);\n  var ss = pad(date.getSeconds(), 2);\n  var SSS = pad(date.getMilliseconds(), 3);\n  return yyyy + \"-\" + MM + \"-\" + dd + \"T\" + hh + \":\" + mm + \":\" + ss + \".\" + SSS;\n}\n/** An enumeration of all the translatable strings used by `@rjsf/core` and its themes. The value of each of the\r\n * enumeration keys is expected to be the actual english string. Some strings contain replaceable parameter values\r\n * as indicated by `%1`, `%2`, etc. The number after the `%` indicates the order of the parameter. The ordering of\r\n * parameters is important because some languages may choose to put the second parameter before the first in its\r\n * translation. Also, some strings are rendered using `markdown-to-jsx` and thus support markdown and inline html.\r\n */\n\n\nvar TranslatableString;\n\n(function (TranslatableString) {\n  /** Fallback title of an array item, used by ArrayField */\n  TranslatableString[\"ArrayItemTitle\"] = \"Item\";\n  /** Missing items reason, used by ArrayField */\n\n  TranslatableString[\"MissingItems\"] = \"Missing items definition\";\n  /** Yes label, used by BooleanField */\n\n  TranslatableString[\"YesLabel\"] = \"Yes\";\n  /** No label, used by BooleanField */\n\n  TranslatableString[\"NoLabel\"] = \"No\";\n  /** Close label, used by ErrorList */\n\n  TranslatableString[\"CloseLabel\"] = \"Close\";\n  /** Errors label, used by ErrorList */\n\n  TranslatableString[\"ErrorsLabel\"] = \"Errors\";\n  /** New additionalProperties string default value, used by ObjectField */\n\n  TranslatableString[\"NewStringDefault\"] = \"New Value\";\n  /** Add button title, used by AddButton */\n\n  TranslatableString[\"AddButton\"] = \"Add\";\n  /** Add button title, used by AddButton */\n\n  TranslatableString[\"AddItemButton\"] = \"Add Item\";\n  /** Copy button title, used by IconButton */\n\n  TranslatableString[\"CopyButton\"] = \"Copy\";\n  /** Move down button title, used by IconButton */\n\n  TranslatableString[\"MoveDownButton\"] = \"Move down\";\n  /** Move up button title, used by IconButton */\n\n  TranslatableString[\"MoveUpButton\"] = \"Move up\";\n  /** Remove button title, used by IconButton */\n\n  TranslatableString[\"RemoveButton\"] = \"Remove\";\n  /** Now label, used by AltDateWidget */\n\n  TranslatableString[\"NowLabel\"] = \"Now\";\n  /** Clear label, used by AltDateWidget */\n\n  TranslatableString[\"ClearLabel\"] = \"Clear\";\n  /** Aria date label, used by DateWidget */\n\n  TranslatableString[\"AriaDateLabel\"] = \"Select a date\";\n  /** Decrement button aria label, used by UpDownWidget */\n\n  TranslatableString[\"DecrementAriaLabel\"] = \"Decrease value by 1\";\n  /** Increment button aria label, used by UpDownWidget */\n\n  TranslatableString[\"IncrementAriaLabel\"] = \"Increase value by 1\"; // Strings with replaceable parameters\n\n  /** Unknown field type reason, where %1 will be replaced with the type as provided by SchemaField */\n\n  TranslatableString[\"UnknownFieldType\"] = \"Unknown field type %1\";\n  /** Option prefix, where %1 will be replaced with the option index as provided by MultiSchemaField */\n\n  TranslatableString[\"OptionPrefix\"] = \"Option %1\";\n  /** Option prefix, where %1 and %2 will be replaced by the schema title and option index, respectively as provided by\r\n   * MultiSchemaField\r\n   */\n\n  TranslatableString[\"TitleOptionPrefix\"] = \"%1 option %2\";\n  /** Key label, where %1 will be replaced by the label as provided by WrapIfAdditionalTemplate */\n\n  TranslatableString[\"KeyLabel\"] = \"%1 Key\"; // Strings with replaceable parameters AND/OR that support markdown and html\n\n  /** Invalid object field configuration as provided by the ObjectField */\n\n  TranslatableString[\"InvalidObjectField\"] = \"Invalid \\\"%1\\\" object field configuration: <em>%2</em>.\";\n  /** Unsupported field schema, used by UnsupportedField */\n\n  TranslatableString[\"UnsupportedField\"] = \"Unsupported field schema.\";\n  /** Unsupported field schema, where %1 will be replaced by the idSchema.$id as provided by UnsupportedField */\n\n  TranslatableString[\"UnsupportedFieldWithId\"] = \"Unsupported field schema for field <code>%1</code>.\";\n  /** Unsupported field schema, where %1 will be replaced by the reason string as provided by UnsupportedField */\n\n  TranslatableString[\"UnsupportedFieldWithReason\"] = \"Unsupported field schema: <em>%1</em>.\";\n  /** Unsupported field schema, where %1 and %2 will be replaced by the idSchema.$id and reason strings, respectively,\r\n   * as provided by UnsupportedField\r\n   */\n\n  TranslatableString[\"UnsupportedFieldWithIdAndReason\"] = \"Unsupported field schema for field <code>%1</code>: <em>%2</em>.\";\n  /** File name, type and size info, where %1, %2 and %3 will be replaced by the file name, file type and file size as\r\n   * provided by FileWidget\r\n   */\n\n  TranslatableString[\"FilesInfo\"] = \"<strong>%1</strong> (%2, %3 bytes)\";\n})(TranslatableString || (TranslatableString = {}));\n\nexport { ADDITIONAL_PROPERTIES_KEY, ADDITIONAL_PROPERTY_FLAG, ALL_OF_KEY, ANY_OF_KEY, CONST_KEY, DEFAULT_KEY, DEFINITIONS_KEY, DEPENDENCIES_KEY, ENUM_KEY, ERRORS_KEY, ErrorSchemaBuilder, ID_KEY, ITEMS_KEY, NAME_KEY, ONE_OF_KEY, PROPERTIES_KEY, REF_KEY, REQUIRED_KEY, RJSF_ADDITONAL_PROPERTIES_FLAG, SUBMIT_BTN_OPTIONS_KEY, TranslatableString, UI_FIELD_KEY, UI_GLOBAL_OPTIONS_KEY, UI_OPTIONS_KEY, UI_WIDGET_KEY, allowAdditionalItems, ariaDescribedByIds, asNumber, canExpand, createSchemaUtils, dataURItoBlob, deepEquals, descriptionId, englishStringTranslator, enumOptionsDeselectValue, enumOptionsIndexForValue, enumOptionsIsSelected, enumOptionsSelectValue, enumOptionsValueForIndex, errorId, examplesId, findSchemaDefinition, getClosestMatchingOption, getDefaultFormState, getDisplayLabel, getFirstMatchingOption, getInputProps, getMatchingOption, getSchemaType, getSubmitButtonOptions, getTemplate, getUiOptions, getWidget, guessType, hasWidget, helpId, isConstant, isCustomWidget, isFilesArray, isFixedItems, isMultiSelect, isObject, isSelect, localToUTC, mergeDefaultsWithFormData, mergeObjects, mergeSchemas, mergeValidationData, optionId, optionsList, orderProperties, pad, parseDateString, rangeSpec, replaceStringParameters, retrieveSchema, sanitizeDataForNewSchema, schemaRequiresTrueValue, shouldRender, titleId, toConstant, toDateString, toIdSchema, toPathSchema, utcToLocal };","map":{"version":3,"sources":["../src/isObject.ts","../src/allowAdditionalItems.ts","../src/asNumber.ts","../src/constants.ts","../src/getUiOptions.ts","../src/canExpand.ts","../src/deepEquals.ts","../src/findSchemaDefinition.ts","../src/schema/getMatchingOption.ts","../src/schema/getFirstMatchingOption.ts","../src/guessType.ts","../src/getSchemaType.ts","../src/mergeSchemas.ts","../src/schema/retrieveSchema.ts","../src/schema/getClosestMatchingOption.ts","../src/isFixedItems.ts","../src/mergeDefaultsWithFormData.ts","../src/mergeObjects.ts","../src/isConstant.ts","../src/schema/isSelect.ts","../src/schema/isMultiSelect.ts","../src/schema/getDefaultFormState.ts","../src/isCustomWidget.ts","../src/schema/isFilesArray.ts","../src/schema/getDisplayLabel.ts","../src/schema/mergeValidationData.ts","../src/schema/sanitizeDataForNewSchema.ts","../src/schema/toIdSchema.ts","../src/schema/toPathSchema.ts","../src/createSchemaUtils.ts","../src/dataURItoBlob.ts","../src/replaceStringParameters.ts","../src/englishStringTranslator.ts","../src/enumOptionsValueForIndex.ts","../src/enumOptionsDeselectValue.ts","../src/enumOptionsIsSelected.ts","../src/enumOptionsIndexForValue.ts","../src/enumOptionsSelectValue.ts","../src/ErrorSchemaBuilder.ts","../src/rangeSpec.ts","../src/getInputProps.ts","../src/getSubmitButtonOptions.ts","../src/getTemplate.ts","../src/getWidget.tsx","../src/hasWidget.ts","../src/idGenerators.ts","../src/localToUTC.ts","../src/toConstant.ts","../src/optionsList.ts","../src/orderProperties.ts","../src/pad.ts","../src/parseDateString.ts","../src/schemaRequiresTrueValue.ts","../src/shouldRender.ts","../src/toDateString.ts","../src/utcToLocal.ts","../src/enums.ts"],"names":["thing","File","Date","Array","isArray","schema","additionalItems","console","warn","isObject","value","undefined","test","n","Number","valid","isNaN","ADDITIONAL_PROPERTY_FLAG","ADDITIONAL_PROPERTIES_KEY","ALL_OF_KEY","ANY_OF_KEY","CONST_KEY","DEFAULT_KEY","DEFINITIONS_KEY","DEPENDENCIES_KEY","ENUM_KEY","ERRORS_KEY","ID_KEY","ITEMS_KEY","NAME_KEY","ONE_OF_KEY","PROPERTIES_KEY","REQUIRED_KEY","SUBMIT_BTN_OPTIONS_KEY","REF_KEY","RJSF_ADDITONAL_PROPERTIES_FLAG","UI_FIELD_KEY","UI_WIDGET_KEY","UI_OPTIONS_KEY","UI_GLOBAL_OPTIONS_KEY","uiSchema","globalOptions","Object","keys","filter","key","indexOf","reduce","options","error","substring","canExpand","formData","additionalProperties","expandable","getUiOptions","_getUiOptions$expanda","maxProperties","length","deepEquals","a","b","isEqualWith","obj","other","object","remaining","omit","$ref","rootSchema","ref","startsWith","decodeURIComponent","Error","current","jsonpointer","get","theRef","splitKeyElementFromObject","subSchema","findSchemaDefinition","getMatchingOption","validator","i","option","properties","requiresAnyOf","anyOf","map","required","augmentedSchema","shallowClone","allOf","slice","push","assign","isValid","getFirstMatchingOption","type","guessType","includes","find","mergeSchemas","obj1","obj2","acc","left","right","getSchemaType","union","resolveCondition","expression","then","otherwise","resolvedSchemaLessConditional","conditionalSchema","retrieveSchema","resolveSchema","resolveReference","resolvedSchema","resolveDependencies","allOfSubschema","$refSchema","localSchema","stubExistingAdditionalProperties","theSchema","aFormData","forEach","set","rawFormData","mergeAllOf","deep","e","_resolvedSchema","resolvedSchemaWithoutAllOf","hasAdditionalProperties","dependencies","remainingSchema","oneOf","processDependencies","dependencyKey","remainingDependencies","dependencyValue","withDependentProperties","withDependentSchema","additionallyRequired","from","Set","dependentSchema","resolvedOneOf","subschema","withExactlyOneSubschema","validSubschemas","conditionPropertySchema","conditionSchema","errors","validateFormData","dependentSubschema","JUNK_OPTION","__not_really_there__","calculateIndexScore","totalScore","score","formValue","has","newSchema","getClosestMatchingOption","newScore","isString","selectedOption","allValidIndexes","validList","index","testOptions","match","times","bestIndex","scoreData","bestScore","items","every","item","mergeDefaultsWithFormData","defaults","defaultsArray","mapped","idx","mergeObjects","concatArrays","toMerge","result","concat","isSelect","altSchemas","isConstant","uniqueItems","AdditionalItemsHandling","Ignore","maybeAddDefaultToObject","computedDefault","includeUndefinedValues","requiredFields","isEmpty","rawSchema","parentDefaults","refSchema","computeDefaults","isFixedItems","itemSchema","objectDefaults","additionalPropertiesSchema","schemaItem","getInnerSchemaForArrayItem","Fallback","minItems","isMultiSelect","defaultsLength","defaultEntries","fillerSchema","Invert","fillerDefault","fillerEntries","fill","isCustomWidget","itemsSchema","format","uiOptions","label","displayLabel","schemaType","isFilesArray","validationData","additionalErrorSchema","oldErrors","errorSchema","oldErrorSchema","toErrorList","NO_VALUE","Symbol","oldSchema","data","newFormData","removeOldSchemaData","nestedData","oldKeyedSchema","newKeyedSchema","oldSchemaTypeForKey","newSchemaTypeForKey","itemData","sanitizeDataForNewSchema","newOptionDefault","oldOptionDefault","newOptionConst","oldOptionConst","oldSchemaItems","newSchemaItems","oldSchemaType","newSchemaType","maxItems","newValue","aValue","itemValue","id","idPrefix","idSeparator","_schema","toIdSchema","$id","idSchema","name","field","fieldId","toPathSchema","pathSchema","replace","element","property","SchemaUtils","getValidator","doesSchemaUtilsDiffer","getDefaultFormState","getDisplayLabel","mergeValidationData","createSchemaUtils","dataURI","splitted","split","params","param","decodeURI","binary","atob","array","charCodeAt","blob","window","Blob","Uint8Array","size","message","replaceStringParameters","inputString","output","parts","partIndex","findIndex","part","join","englishStringTranslator","stringToTranslate","enumOptionsValueForIndex","valueIndex","allEnumOptions","emptyValue","val","enumOptionsDeselectValue","selected","v","isEqual","enumOptionsIsSelected","some","sel","multiple","selectedIndexes","opt","String","enumOptionsSelectValue","all","updated","sort","ErrorSchemaBuilder","initialSchema","resetAllErrors","getOrCreateErrorBlock","pathOfError","hasPath","errorBlock","cloneDeep","addErrors","errorOrList","errorsList","setErrors","listToAdd","clearErrors","_createClass","spec","multipleOf","step","minimum","min","maximum","max","defaultType","autoDefaultStepAny","inputProps","rangeSpec","inputType","autocomplete","autoComplete","DEFAULT_OPTIONS","props","disabled","submitText","norender","getSubmitButtonOptions","getTemplate","registry","templates","widgetMap","checkbox","radio","select","hidden","string","text","password","email","hostname","ipv4","ipv6","uri","textarea","date","datetime","time","color","file","number","updown","range","integer","checkboxes","files","mergeWidgetOptions","AWidget","MergedWidget","defaultOptions","defaultProps","_jsx","getWidget","widget","registeredWidgets","ReactIs","isForwardRef","createElement","isMemo","registeredWidget","hasWidget","err","idGenerator","suffix","theId","descriptionId","errorId","examplesId","helpId","titleId","ariaDescribedByIds","includeExamples","examples","optionIndex","dateString","toJSON","schemaWithEnumNames","enumNames","process","env","NODE_ENV","aSchemaDef","aSchema","toConstant","title","orderProperties","order","arrayToHash","arr","prev","curr","errorPropList","propertyHash","orderFiltered","prop","orderHash","rest","restIndex","lastIndexOf","complete","splice","pad","num","width","s","includeTime","year","month","day","hour","minute","second","getTime","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","schemaRequiresTrueValue","schemaSome","component","nextProps","nextState","state","dateObject","_dateObject$hour","_dateObject$minute","_dateObject$second","utcTime","UTC","jsonDate","yyyy","getFullYear","MM","getMonth","dd","getDate","hh","getHours","mm","getMinutes","ss","getSeconds","SSS","getMilliseconds","TranslatableString"],"mappings":"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","sourcesContent":["/** Determines whether a `thing` is an object for the purposes of RSJF. In this case, `thing` is an object if it has\n * the type `object` but is NOT null, an array or a File.\n *\n * @param thing - The thing to check to see whether it is an object\n * @returns - True if it is a non-null, non-array, non-File object\n */\nexport default function isObject(thing: any) {\n  if (typeof File !== 'undefined' && thing instanceof File) {\n    return false;\n  }\n  if (typeof Date !== 'undefined' && thing instanceof Date) {\n    return false;\n  }\n  return typeof thing === 'object' && thing !== null && !Array.isArray(thing);\n}\n","import isObject from './isObject';\nimport { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Checks the schema to see if it is allowing additional items, by verifying that `schema.additionalItems` is an\n * object. The user is warned in the console if `schema.additionalItems` has the value `true`.\n *\n * @param schema - The schema object to check\n * @returns - True if additional items is allowed, otherwise false\n */\nexport default function allowAdditionalItems<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\n  if (schema.additionalItems === true) {\n    console.warn('additionalItems=true is currently not supported');\n  }\n  return isObject(schema.additionalItems);\n}\n","/** Attempts to convert the string into a number. If an empty string is provided, then `undefined` is returned. If a\n * `null` is provided, it is returned. If the string ends in a `.` then the string is returned because the user may be\n * in the middle of typing a float number. If a number ends in a pattern like `.0`, `.20`, `.030`, string is returned\n * because the user may be typing number that will end in a non-zero digit. Otherwise, the string is wrapped by\n * `Number()` and if that result is not `NaN`, that number will be returned, otherwise the string `value` will be.\n *\n * @param value - The string or null value to convert to a number\n * @returns - The `value` converted to a number when appropriate, otherwise the `value`\n */\nexport default function asNumber(value: string | null) {\n  if (value === '') {\n    return undefined;\n  }\n  if (value === null) {\n    return null;\n  }\n  if (/\\.$/.test(value)) {\n    // '3.' can't really be considered a number even if it parses in js. The\n    // user is most likely entering a float.\n    return value;\n  }\n  if (/\\.0$/.test(value)) {\n    // we need to return this as a string here, to allow for input like 3.07\n    return value;\n  }\n\n  if (/\\.\\d*0$/.test(value)) {\n    // It's a number, that's cool - but we need it as a string so it doesn't screw\n    // with the user when entering dollar amounts or other values (such as those with\n    // specific precision or number of significant digits)\n    return value;\n  }\n\n  const n = Number(value);\n  const valid = typeof n === 'number' && !Number.isNaN(n);\n\n  return valid ? n : value;\n}\n","/** Below are the list of all the keys into various elements of a RJSFSchema or UiSchema that are used by the various\n * utility functions. In addition to those keys, there are the special `ADDITIONAL_PROPERTY_FLAG` and\n * `RJSF_ADDITONAL_PROPERTIES_FLAG` flags that is added to a schema under certain conditions by the `retrieveSchema()`\n * utility.\n */\nexport const ADDITIONAL_PROPERTY_FLAG = '__additional_property';\nexport const ADDITIONAL_PROPERTIES_KEY = 'additionalProperties';\nexport const ALL_OF_KEY = 'allOf';\nexport const ANY_OF_KEY = 'anyOf';\nexport const CONST_KEY = 'const';\nexport const DEFAULT_KEY = 'default';\nexport const DEFINITIONS_KEY = 'definitions';\nexport const DEPENDENCIES_KEY = 'dependencies';\nexport const ENUM_KEY = 'enum';\nexport const ERRORS_KEY = '__errors';\nexport const ID_KEY = '$id';\nexport const ITEMS_KEY = 'items';\nexport const NAME_KEY = '$name';\nexport const ONE_OF_KEY = 'oneOf';\nexport const PROPERTIES_KEY = 'properties';\nexport const REQUIRED_KEY = 'required';\nexport const SUBMIT_BTN_OPTIONS_KEY = 'submitButtonOptions';\nexport const REF_KEY = '$ref';\nexport const RJSF_ADDITONAL_PROPERTIES_FLAG = '__rjsf_additionalProperties';\nexport const UI_FIELD_KEY = 'ui:field';\nexport const UI_WIDGET_KEY = 'ui:widget';\nexport const UI_OPTIONS_KEY = 'ui:options';\nexport const UI_GLOBAL_OPTIONS_KEY = 'ui:globalOptions';\n","import { UI_OPTIONS_KEY, UI_WIDGET_KEY } from './constants';\nimport isObject from './isObject';\nimport { FormContextType, GlobalUISchemaOptions, RJSFSchema, StrictRJSFSchema, UIOptionsType, UiSchema } from './types';\n\n/** Get all passed options from ui:options, and ui:<optionName>, returning them in an object with the `ui:`\n * stripped off. Any `globalOptions` will always be returned, unless they are overridden by options in the `uiSchema`.\n *\n * @param [uiSchema={}] - The UI Schema from which to get any `ui:xxx` options\n * @param [globalOptions={}] - The optional Global UI Schema from which to get any fallback `xxx` options\n * @returns - An object containing all the `ui:xxx` options with the `ui:` stripped off along with all `globalOptions`\n */\nexport default function getUiOptions<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  uiSchema: UiSchema<T, S, F> = {},\n  globalOptions: GlobalUISchemaOptions = {}\n): UIOptionsType<T, S, F> {\n  return Object.keys(uiSchema)\n    .filter((key) => key.indexOf('ui:') === 0)\n    .reduce(\n      (options, key) => {\n        const value = uiSchema[key];\n        if (key === UI_WIDGET_KEY && isObject(value)) {\n          console.error('Setting options via ui:widget object is no longer supported, use ui:options instead');\n          return options;\n        }\n        if (key === UI_OPTIONS_KEY && isObject(value)) {\n          return { ...options, ...value };\n        }\n        return { ...options, [key.substring(3)]: value };\n      },\n      { ...globalOptions }\n    );\n}\n","import { FormContextType, RJSFSchema, StrictRJSFSchema, UiSchema } from './types';\nimport getUiOptions from './getUiOptions';\n\n/** Checks whether the field described by `schema`, having the `uiSchema` and `formData` supports expanding. The UI for\n * the field can expand if it has additional properties, is not forced as non-expandable by the `uiSchema` and the\n * `formData` object doesn't already have `schema.maxProperties` elements.\n *\n * @param schema - The schema for the field that is being checked\n * @param [uiSchema={}] - The uiSchema for the field\n * @param [formData] - The formData for the field\n * @returns - True if the schema element has additionalProperties, is expandable, and not at the maxProperties limit\n */\nexport default function canExpand<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  schema: RJSFSchema,\n  uiSchema: UiSchema<T, S, F> = {},\n  formData?: T\n) {\n  if (!schema.additionalProperties) {\n    return false;\n  }\n  const { expandable = true } = getUiOptions<T, S, F>(uiSchema);\n  if (expandable === false) {\n    return expandable;\n  }\n  // if ui:options.expandable was not explicitly set to false, we can add\n  // another property if we have not exceeded maxProperties yet\n  if (schema.maxProperties !== undefined && formData) {\n    return Object.keys(formData).length < schema.maxProperties;\n  }\n  return true;\n}\n","import isEqualWith from 'lodash/isEqualWith';\n\n/** Implements a deep equals using the `lodash.isEqualWith` function, that provides a customized comparator that\n * assumes all functions are equivalent.\n *\n * @param a - The first element to compare\n * @param b - The second element to compare\n * @returns - True if the `a` and `b` are deeply equal, false otherwise\n */\nexport default function deepEquals(a: any, b: any): boolean {\n  return isEqualWith(a, b, (obj: any, other: any) => {\n    if (typeof obj === 'function' && typeof other === 'function') {\n      // Assume all functions are equivalent\n      // see https://github.com/rjsf-team/react-jsonschema-form/issues/255\n      return true;\n    }\n    return undefined; // fallback to default isEquals behavior\n  });\n}\n","import jsonpointer from 'jsonpointer';\nimport omit from 'lodash/omit';\n\nimport { REF_KEY } from './constants';\nimport { GenericObjectType, RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Splits out the value at the `key` in `object` from the `object`, returning an array that contains in the first\n * location, the `object` minus the `key: value` and in the second location the `value`.\n *\n * @param key - The key from the object to extract\n * @param object - The object from which to extract the element\n * @returns - An array with the first value being the object minus the `key` element and the second element being the\n *      value from `object[key]`\n */\nexport function splitKeyElementFromObject(key: string, object: GenericObjectType) {\n  const value = object[key];\n  const remaining = omit(object, [key]);\n  return [remaining, value];\n}\n\n/** Given the name of a `$ref` from within a schema, using the `rootSchema`, look up and return the sub-schema using the\n * path provided by that reference. If `#` is not the first character of the reference, or the path does not exist in\n * the schema, then throw an Error. Otherwise return the sub-schema. Also deals with nested `$ref`s in the sub-schema.\n *\n * @param $ref - The ref string for which the schema definition is desired\n * @param [rootSchema={}] - The root schema in which to search for the definition\n * @returns - The sub-schema within the `rootSchema` which matches the `$ref` if it exists\n * @throws - Error indicating that no schema for that reference exists\n */\nexport default function findSchemaDefinition<S extends StrictRJSFSchema = RJSFSchema>(\n  $ref?: string,\n  rootSchema: S = {} as S\n): S {\n  let ref = $ref || '';\n  if (ref.startsWith('#')) {\n    // Decode URI fragment representation.\n    ref = decodeURIComponent(ref.substring(1));\n  } else {\n    throw new Error(`Could not find a definition for ${$ref}.`);\n  }\n  const current: S = jsonpointer.get(rootSchema, ref);\n  if (current === undefined) {\n    throw new Error(`Could not find a definition for ${$ref}.`);\n  }\n  if (current[REF_KEY]) {\n    const [remaining, theRef] = splitKeyElementFromObject(REF_KEY, current);\n    const subSchema = findSchemaDefinition<S>(theRef, rootSchema);\n    if (Object.keys(remaining).length > 0) {\n      return { ...remaining, ...subSchema };\n    }\n    return subSchema;\n  }\n  return current;\n}\n","import { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\n\n/** Given the `formData` and list of `options`, attempts to find the index of the option that best matches the data.\n * Deprecated, use `getFirstMatchingOption()` instead.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param formData - The current formData, if any, used to figure out a match\n * @param options - The list of options to find a matching options from\n * @param rootSchema - The root schema, used to primarily to look up `$ref`s\n * @returns - The index of the matched option or 0 if none is available\n * @deprecated\n */\nexport default function getMatchingOption<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S, F>, formData: T | undefined, options: S[], rootSchema: S): number {\n  // For performance, skip validating subschemas if formData is undefined. We just\n  // want to get the first option in that case.\n  if (formData === undefined) {\n    return 0;\n  }\n  for (let i = 0; i < options.length; i++) {\n    const option = options[i];\n\n    // If the schema describes an object then we need to add slightly more\n    // strict matching to the schema, because unless the schema uses the\n    // \"requires\" keyword, an object will match the schema as long as it\n    // doesn't have matching keys with a conflicting type. To do this we use an\n    // \"anyOf\" with an array of requires. This augmentation expresses that the\n    // schema should match if any of the keys in the schema are present on the\n    // object and pass validation.\n    if (option.properties) {\n      // Create an \"anyOf\" schema that requires at least one of the keys in the\n      // \"properties\" object\n      const requiresAnyOf = {\n        anyOf: Object.keys(option.properties).map((key) => ({\n          required: [key],\n        })),\n      };\n\n      let augmentedSchema;\n\n      // If the \"anyOf\" keyword already exists, wrap the augmentation in an \"allOf\"\n      if (option.anyOf) {\n        // Create a shallow clone of the option\n        const { ...shallowClone } = option;\n\n        if (!shallowClone.allOf) {\n          shallowClone.allOf = [];\n        } else {\n          // If \"allOf\" already exists, shallow clone the array\n          shallowClone.allOf = shallowClone.allOf.slice();\n        }\n\n        shallowClone.allOf.push(requiresAnyOf);\n\n        augmentedSchema = shallowClone;\n      } else {\n        augmentedSchema = Object.assign({}, option, requiresAnyOf);\n      }\n\n      // Remove the \"required\" field as it's likely that not all fields have\n      // been filled in yet, which will mean that the schema is not valid\n      delete augmentedSchema.required;\n\n      if (validator.isValid(augmentedSchema, formData, rootSchema)) {\n        return i;\n      }\n    } else if (validator.isValid(option, formData, rootSchema)) {\n      return i;\n    }\n  }\n  return 0;\n}\n","import getMatchingOption from './getMatchingOption';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\n\n/** Given the `formData` and list of `options`, attempts to find the index of the first option that matches the data.\n * Always returns the first option if there is nothing that matches.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param formData - The current formData, if any, used to figure out a match\n * @param options - The list of options to find a matching options from\n * @param rootSchema - The root schema, used to primarily to look up `$ref`s\n * @returns - The index of the first matched option or 0 if none is available\n */\nexport default function getFirstMatchingOption<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S, F>, formData: T | undefined, options: S[], rootSchema: S): number {\n  return getMatchingOption<T, S, F>(validator, formData, options, rootSchema);\n}\n","/** Given a specific `value` attempts to guess the type of a schema element. In the case where we have to implicitly\n *  create a schema, it is useful to know what type to use based on the data we are defining.\n *\n * @param value - The value from which to guess the type\n * @returns - The best guess for the object type\n */\nexport default function guessType(value: any) {\n  if (Array.isArray(value)) {\n    return 'array';\n  }\n  if (typeof value === 'string') {\n    return 'string';\n  }\n  if (value == null) {\n    return 'null';\n  }\n  if (typeof value === 'boolean') {\n    return 'boolean';\n  }\n  if (!isNaN(value)) {\n    return 'number';\n  }\n  if (typeof value === 'object') {\n    return 'object';\n  }\n  // Default to string if we can't figure it out\n  return 'string';\n}\n","import guessType from './guessType';\nimport { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Gets the type of a given `schema`. If the type is not explicitly defined, then an attempt is made to infer it from\n * other elements of the schema as follows:\n * - schema.const: Returns the `guessType()` of that value\n * - schema.enum: Returns `string`\n * - schema.properties: Returns `object`\n * - schema.additionalProperties: Returns `object`\n * - type is an array with a length of 2 and one type is 'null': Returns the other type\n *\n * @param schema - The schema for which to get the type\n * @returns - The type of the schema\n */\nexport default function getSchemaType<S extends StrictRJSFSchema = RJSFSchema>(\n  schema: S\n): string | string[] | undefined {\n  let { type } = schema;\n\n  if (!type && schema.const) {\n    return guessType(schema.const);\n  }\n\n  if (!type && schema.enum) {\n    return 'string';\n  }\n\n  if (!type && (schema.properties || schema.additionalProperties)) {\n    return 'object';\n  }\n\n  if (Array.isArray(type) && type.length === 2 && type.includes('null')) {\n    type = type.find((type) => type !== 'null');\n  }\n\n  return type;\n}\n","import union from 'lodash/union';\n\nimport { REQUIRED_KEY } from './constants';\nimport getSchemaType from './getSchemaType';\nimport isObject from './isObject';\nimport { GenericObjectType } from './types';\n\n/** Recursively merge deeply nested schemas. The difference between `mergeSchemas` and `mergeObjects` is that\n * `mergeSchemas` only concats arrays for values under the 'required' keyword, and when it does, it doesn't include\n * duplicate values.\n *\n * @param obj1 - The first schema object to merge\n * @param obj2 - The second schema object to merge\n * @returns - The merged schema object\n */\nexport default function mergeSchemas(obj1: GenericObjectType, obj2: GenericObjectType) {\n  const acc = Object.assign({}, obj1); // Prevent mutation of source object.\n  return Object.keys(obj2).reduce((acc, key) => {\n    const left = obj1 ? obj1[key] : {},\n      right = obj2[key];\n    if (obj1 && key in obj1 && isObject(right)) {\n      acc[key] = mergeSchemas(left, right);\n    } else if (\n      obj1 &&\n      obj2 &&\n      (getSchemaType(obj1) === 'object' || getSchemaType(obj2) === 'object') &&\n      key === REQUIRED_KEY &&\n      Array.isArray(left) &&\n      Array.isArray(right)\n    ) {\n      // Don't include duplicate values when merging 'required' fields.\n      acc[key] = union(left, right);\n    } else {\n      acc[key] = right;\n    }\n    return acc;\n  }, acc);\n}\n","import get from 'lodash/get';\nimport set from 'lodash/set';\nimport mergeAllOf, { Options } from 'json-schema-merge-allof';\n\nimport {\n  ADDITIONAL_PROPERTIES_KEY,\n  ADDITIONAL_PROPERTY_FLAG,\n  ALL_OF_KEY,\n  ANY_OF_KEY,\n  DEPENDENCIES_KEY,\n  ONE_OF_KEY,\n  REF_KEY,\n} from '../constants';\nimport findSchemaDefinition, { splitKeyElementFromObject } from '../findSchemaDefinition';\nimport guessType from '../guessType';\nimport isObject from '../isObject';\nimport mergeSchemas from '../mergeSchemas';\nimport { FormContextType, GenericObjectType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport getFirstMatchingOption from './getFirstMatchingOption';\n\n/** Resolves a conditional block (if/else/then) by removing the condition and merging the appropriate conditional branch\n * with the rest of the schema\n *\n * @param validator - An implementation of the `ValidatorType<T, S>` interface that is used to detect valid schema conditions\n * @param schema - The schema for which resolving a condition is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param [formData] - The current formData to assist retrieving a schema\n * @returns - A schema with the appropriate condition resolved\n */\nexport function resolveCondition<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  formData?: T\n) {\n  const { if: expression, then, else: otherwise, ...resolvedSchemaLessConditional } = schema;\n\n  const conditionalSchema = validator.isValid(expression as S, formData, rootSchema) ? then : otherwise;\n\n  if (conditionalSchema && typeof conditionalSchema !== 'boolean') {\n    return retrieveSchema<T, S>(\n      validator,\n      mergeSchemas(\n        resolvedSchemaLessConditional,\n        retrieveSchema<T, S, F>(validator, conditionalSchema as S, rootSchema, formData)\n      ) as S,\n      rootSchema,\n      formData\n    );\n  }\n  return retrieveSchema<T, S, F>(validator, resolvedSchemaLessConditional as S, rootSchema, formData);\n}\n\n/** Resolves references and dependencies within a schema and its 'allOf' children.\n * Called internally by retrieveSchema.\n *\n * @param validator - An implementation of the `ValidatorType<T, S>` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a schema is desired\n * @param [rootSchema={}] - The root schema that will be forwarded to all the APIs\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The schema having its references and dependencies resolved\n */\nexport function resolveSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S = {} as S,\n  formData?: T\n): S {\n  if (REF_KEY in schema) {\n    return resolveReference<T, S, F>(validator, schema, rootSchema, formData);\n  }\n  if (DEPENDENCIES_KEY in schema) {\n    const resolvedSchema = resolveDependencies<T, S, F>(validator, schema, rootSchema, formData);\n    return retrieveSchema<T, S, F>(validator, resolvedSchema, rootSchema, formData);\n  }\n  if (ALL_OF_KEY in schema) {\n    return {\n      ...schema,\n      allOf: schema.allOf!.map((allOfSubschema) =>\n        retrieveSchema<T, S, F>(validator, allOfSubschema as S, rootSchema, formData)\n      ),\n    };\n  }\n  // No $ref or dependencies attribute found, returning the original schema.\n  return schema;\n}\n\n/** Resolves references within a schema and its 'allOf' children.\n *\n * @param validator - An implementation of the `ValidatorType<T, S>` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a reference is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The schema having its references resolved\n */\nexport function resolveReference<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  formData?: T\n): S {\n  // Retrieve the referenced schema definition.\n  const $refSchema = findSchemaDefinition<S>(schema.$ref, rootSchema);\n  // Drop the $ref property of the source schema.\n  const { $ref, ...localSchema } = schema;\n  // Update referenced schema definition with local schema properties.\n  return retrieveSchema<T, S, F>(validator, { ...$refSchema, ...localSchema }, rootSchema, formData);\n}\n\n/** Creates new 'properties' items for each key in the `formData`\n *\n * @param validator - An implementation of the `ValidatorType<T, S>` interface that will be used when necessary\n * @param theSchema - The schema for which the existing additional properties is desired\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s * @param validator\n * @param [aFormData] - The current formData, if any, to assist retrieving a schema\n * @returns - The updated schema with additional properties stubbed\n */\nexport function stubExistingAdditionalProperties<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S, F>, theSchema: S, rootSchema?: S, aFormData?: T): S {\n  // Clone the schema so we don't ruin the consumer's original\n  const schema = {\n    ...theSchema,\n    properties: { ...theSchema.properties },\n  };\n\n  // make sure formData is an object\n  const formData: GenericObjectType = aFormData && isObject(aFormData) ? aFormData : {};\n  Object.keys(formData).forEach((key) => {\n    if (key in schema.properties) {\n      // No need to stub, our schema already has the property\n      return;\n    }\n\n    let additionalProperties: S['additionalProperties'] = {};\n    if (typeof schema.additionalProperties !== 'boolean') {\n      if (REF_KEY in schema.additionalProperties!) {\n        additionalProperties = retrieveSchema<T, S, F>(\n          validator,\n          { $ref: get(schema.additionalProperties, [REF_KEY]) } as S,\n          rootSchema,\n          formData as T\n        );\n      } else if ('type' in schema.additionalProperties!) {\n        additionalProperties = { ...schema.additionalProperties };\n      } else if (ANY_OF_KEY in schema.additionalProperties! || ONE_OF_KEY in schema.additionalProperties!) {\n        additionalProperties = {\n          type: 'object',\n          ...schema.additionalProperties,\n        };\n      } else {\n        additionalProperties = { type: guessType(get(formData, [key])) };\n      }\n    } else {\n      additionalProperties = { type: guessType(get(formData, [key])) };\n    }\n\n    // The type of our new key should match the additionalProperties value;\n    schema.properties[key] = additionalProperties;\n    // Set our additional property flag so we know it was dynamically added\n    set(schema.properties, [key, ADDITIONAL_PROPERTY_FLAG], true);\n  });\n\n  return schema;\n}\n\n/** Retrieves an expanded schema that has had all of its conditions, additional properties, references and dependencies\n * resolved and merged into the `schema` given a `validator`, `rootSchema` and `rawFormData` that is used to do the\n * potentially recursive resolution.\n *\n * @param validator - An implementation of the `ValidatorType<T, S>` interface that will be forwarded to all the APIs\n * @param schema - The schema for which retrieving a schema is desired\n * @param [rootSchema={}] - The root schema that will be forwarded to all the APIs\n * @param [rawFormData] - The current formData, if any, to assist retrieving a schema\n * @returns - The schema having its conditions, additional properties, references and dependencies resolved\n */\nexport default function retrieveSchema<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S, F>, schema: S, rootSchema: S = {} as S, rawFormData?: T): S {\n  if (!isObject(schema)) {\n    return {} as S;\n  }\n  let resolvedSchema = resolveSchema<T, S, F>(validator, schema, rootSchema, rawFormData);\n\n  if ('if' in schema) {\n    return resolveCondition<T, S, F>(validator, schema, rootSchema, rawFormData as T);\n  }\n\n  const formData: GenericObjectType = rawFormData || {};\n\n  if (ALL_OF_KEY in schema) {\n    try {\n      resolvedSchema = mergeAllOf(resolvedSchema, {\n        deep: false,\n      } as Options) as S;\n    } catch (e) {\n      console.warn('could not merge subschemas in allOf:\\n' + e);\n      const { allOf, ...resolvedSchemaWithoutAllOf } = resolvedSchema;\n      return resolvedSchemaWithoutAllOf as S;\n    }\n  }\n  const hasAdditionalProperties =\n    ADDITIONAL_PROPERTIES_KEY in resolvedSchema && resolvedSchema.additionalProperties !== false;\n  if (hasAdditionalProperties) {\n    return stubExistingAdditionalProperties<T, S, F>(validator, resolvedSchema, rootSchema, formData as T);\n  }\n  return resolvedSchema;\n}\n\n/** Resolves dependencies within a schema and its 'allOf' children.\n *\n * @param validator - An implementation of the `ValidatorType<T, S>` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a dependency is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The schema with its dependencies resolved\n */\nexport function resolveDependencies<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  formData?: T\n): S {\n  // Drop the dependencies from the source schema.\n  const { dependencies, ...remainingSchema } = schema;\n  let resolvedSchema: S = remainingSchema as S;\n  if (Array.isArray(resolvedSchema.oneOf)) {\n    resolvedSchema = resolvedSchema.oneOf[\n      getFirstMatchingOption<T, S, F>(validator, formData, resolvedSchema.oneOf as S[], rootSchema)\n    ] as S;\n  } else if (Array.isArray(resolvedSchema.anyOf)) {\n    resolvedSchema = resolvedSchema.anyOf[\n      getFirstMatchingOption<T, S, F>(validator, formData, resolvedSchema.anyOf as S[], rootSchema)\n    ] as S;\n  }\n  return processDependencies<T, S, F>(validator, dependencies, resolvedSchema, rootSchema, formData);\n}\n\n/** Processes all the `dependencies` recursively into the `resolvedSchema` as needed\n *\n * @param validator - An implementation of the `ValidatorType<T, S>` interface that will be forwarded to all the APIs\n * @param dependencies - The set of dependencies that needs to be processed\n * @param resolvedSchema - The schema for which processing dependencies is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The schema with the `dependencies` resolved into it\n */\nexport function processDependencies<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  dependencies: S['dependencies'],\n  resolvedSchema: S,\n  rootSchema: S,\n  formData?: T\n): S {\n  let schema = resolvedSchema;\n  // Process dependencies updating the local schema properties as appropriate.\n  for (const dependencyKey in dependencies) {\n    // Skip this dependency if its trigger property is not present.\n    if (get(formData, [dependencyKey]) === undefined) {\n      continue;\n    }\n    // Skip this dependency if it is not included in the schema (such as when dependencyKey is itself a hidden dependency.)\n    if (schema.properties && !(dependencyKey in schema.properties)) {\n      continue;\n    }\n    const [remainingDependencies, dependencyValue] = splitKeyElementFromObject(\n      dependencyKey,\n      dependencies as GenericObjectType\n    );\n    if (Array.isArray(dependencyValue)) {\n      schema = withDependentProperties<S>(schema, dependencyValue);\n    } else if (isObject(dependencyValue)) {\n      schema = withDependentSchema<T, S, F>(\n        validator,\n        schema,\n        rootSchema,\n        dependencyKey,\n        dependencyValue as S,\n        formData\n      );\n    }\n    return processDependencies<T, S, F>(validator, remainingDependencies, schema, rootSchema, formData);\n  }\n  return schema;\n}\n\n/** Updates a schema with additionally required properties added\n *\n * @param schema - The schema for which resolving a dependent properties is desired\n * @param [additionallyRequired] - An optional array of additionally required names\n * @returns - The schema with the additional required values merged in\n */\nexport function withDependentProperties<S extends StrictRJSFSchema = RJSFSchema>(\n  schema: S,\n  additionallyRequired?: string[]\n) {\n  if (!additionallyRequired) {\n    return schema;\n  }\n  const required = Array.isArray(schema.required)\n    ? Array.from(new Set([...schema.required, ...additionallyRequired]))\n    : additionallyRequired;\n  return { ...schema, required: required };\n}\n\n/** Merges a dependent schema into the `schema` dealing with oneOfs and references\n *\n * @param validator - An implementation of the `ValidatorType<T, S>` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a dependent schema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param dependencyKey - The key name of the dependency\n * @param dependencyValue - The potentially dependent schema\n * @param formData- The current formData to assist retrieving a schema\n * @returns - The schema with the dependent schema resolved into it\n */\nexport function withDependentSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  dependencyKey: string,\n  dependencyValue: S,\n  formData?: T\n) {\n  const { oneOf, ...dependentSchema } = retrieveSchema<T, S, F>(validator, dependencyValue, rootSchema, formData);\n  schema = mergeSchemas(schema, dependentSchema) as S;\n  // Since it does not contain oneOf, we return the original schema.\n  if (oneOf === undefined) {\n    return schema;\n  }\n  // Resolve $refs inside oneOf.\n  const resolvedOneOf = oneOf.map((subschema) => {\n    if (typeof subschema === 'boolean' || !(REF_KEY in subschema)) {\n      return subschema;\n    }\n    return resolveReference<T, S, F>(validator, subschema as S, rootSchema, formData);\n  });\n  return withExactlyOneSubschema<T, S, F>(validator, schema, rootSchema, dependencyKey, resolvedOneOf, formData);\n}\n\n/** Returns a `schema` with the best choice from the `oneOf` options merged into it\n *\n * @param validator - An implementation of the `ValidatorType<T, S>` interface that will be used to validate oneOf options\n * @param schema - The schema for which resolving a oneOf subschema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param dependencyKey - The key name of the oneOf dependency\n * @param oneOf - The list of schemas representing the oneOf options\n * @param [formData] - The current formData to assist retrieving a schema\n * @returns  The schema with the best choice of oneOf schemas merged into\n */\nexport function withExactlyOneSubschema<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  dependencyKey: string,\n  oneOf: S['oneOf'],\n  formData?: T\n): S {\n  const validSubschemas = oneOf!.filter((subschema) => {\n    if (typeof subschema === 'boolean' || !subschema || !subschema.properties) {\n      return false;\n    }\n    const { [dependencyKey]: conditionPropertySchema } = subschema.properties;\n    if (conditionPropertySchema) {\n      const conditionSchema: S = {\n        type: 'object',\n        properties: {\n          [dependencyKey]: conditionPropertySchema,\n        },\n      } as S;\n      const { errors } = validator.validateFormData(formData, conditionSchema);\n      return errors.length === 0;\n    }\n    return false;\n  });\n\n  if (validSubschemas!.length !== 1) {\n    console.warn(\"ignoring oneOf in dependencies because there isn't exactly one subschema that is valid\");\n    return schema;\n  }\n  const subschema: S = validSubschemas[0] as S;\n  const [dependentSubschema] = splitKeyElementFromObject(dependencyKey, subschema.properties as GenericObjectType);\n  const dependentSchema = { ...subschema, properties: dependentSubschema };\n  return mergeSchemas(schema, retrieveSchema<T, S>(validator, dependentSchema, rootSchema, formData)) as S;\n}\n","import get from 'lodash/get';\nimport has from 'lodash/has';\nimport isObject from 'lodash/isObject';\nimport isString from 'lodash/isString';\nimport reduce from 'lodash/reduce';\nimport times from 'lodash/times';\n\nimport getFirstMatchingOption from './getFirstMatchingOption';\nimport retrieveSchema from './retrieveSchema';\nimport { ONE_OF_KEY, REF_KEY } from '../constants';\nimport guessType from '../guessType';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\n\n/** A junk option used to determine when the getFirstMatchingOption call really matches an option rather than returning\n * the first item\n */\nexport const JUNK_OPTION: StrictRJSFSchema = {\n  type: 'object',\n  properties: {\n    __not_really_there__: {\n      type: 'number',\n    },\n  },\n};\n\n/** Recursive function that calculates the score of a `formData` against the given `schema`. The computation is fairly\n * simple. Initially the total score is 0. When `schema.properties` object exists, then all the `key/value` pairs within\n * the object are processed as follows after obtaining the formValue from `formData` using the `key`:\n * - If the `value` contains a `$ref`, `calculateIndexScore()` is called recursively with the formValue and the new\n *   schema that is the result of the ref in the schema being resolved and that sub-schema's resulting score is added to\n *   the total.\n * - If the `value` contains a `oneOf` and there is a formValue, then score based on the index returned from calling\n *   `getClosestMatchingOption()` of that oneOf.\n * - If the type of the `value` is 'object', `calculateIndexScore()` is called recursively with the formValue and the\n *   `value` itself as the sub-schema, and the score is added to the total.\n * - If the type of the `value` matches the guessed-type of the `formValue`, the score is incremented by 1, UNLESS the\n *   value has a `default` or `const`. In those case, if the `default` or `const` and the `formValue` match, the score\n *   is incremented by another 1 otherwise it is decremented by 1.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param rootSchema - The root JSON schema of the entire form\n * @param schema - The schema for which the score is being calculated\n * @param formData - The form data associated with the schema, used to calculate the score\n * @returns - The score a schema against the formData\n */\nexport function calculateIndexScore<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  rootSchema: S,\n  schema?: S,\n  formData: any = {}\n): number {\n  let totalScore = 0;\n  if (schema) {\n    if (isObject(schema.properties)) {\n      totalScore += reduce(\n        schema.properties,\n        (score, value, key) => {\n          const formValue = get(formData, key);\n          if (typeof value === 'boolean') {\n            return score;\n          }\n          if (has(value, REF_KEY)) {\n            const newSchema = retrieveSchema<T, S, F>(validator, value as S, rootSchema, formValue);\n            return score + calculateIndexScore<T, S, F>(validator, rootSchema, newSchema, formValue || {});\n          }\n          if (has(value, ONE_OF_KEY) && formValue) {\n            return (\n              score + getClosestMatchingOption<T, S, F>(validator, rootSchema, formValue, get(value, ONE_OF_KEY) as S[])\n            );\n          }\n          if (value.type === 'object') {\n            return score + calculateIndexScore<T, S, F>(validator, rootSchema, value as S, formValue || {});\n          }\n          if (value.type === guessType(formValue)) {\n            // If the types match, then we bump the score by one\n            let newScore = score + 1;\n            if (value.default) {\n              // If the schema contains a readonly default value score the value that matches the default higher and\n              // any non-matching value lower\n              newScore += formValue === value.default ? 1 : -1;\n            } else if (value.const) {\n              // If the schema contains a const value score the value that matches the default higher and\n              // any non-matching value lower\n              newScore += formValue === value.const ? 1 : -1;\n            }\n            // TODO eventually, deal with enums/arrays\n            return newScore;\n          }\n          return score;\n        },\n        0\n      );\n    } else if (isString(schema.type) && schema.type === guessType(formData)) {\n      totalScore += 1;\n    }\n  }\n  return totalScore;\n}\n\n/** Determines which of the given `options` provided most closely matches the `formData`. Using\n * `getFirstMatchingOption()` to match two schemas that differ only by the readOnly, default or const value of a field\n * based on the `formData` and returns 0 when there is no match. Rather than passing in all the `options` at once to\n * this utility, instead an array of valid option indexes is created by iterating over the list of options, call\n * `getFirstMatchingOptions` with a list of one junk option and one good option, seeing if the good option is considered\n * matched.\n *\n * Once the list of valid indexes is created, if there is only one valid index, just return it. Otherwise, if there are\n * no valid indexes, then fill the valid indexes array with the indexes of all the options. Next, the index of the\n * option with the highest score is determined by iterating over the list of valid options, calling\n * `calculateIndexScore()` on each, comparing it against the current best score, and returning the index of the one that\n * eventually has the best score.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param rootSchema - The root JSON schema of the entire form\n * @param formData - The form data associated with the schema\n * @param options - The list of options that can be selected from\n * @param [selectedOption=-1] - The index of the currently selected option, defaulted to -1 if not specified\n * @returns - The index of the option that is the closest match to the `formData` or the `selectedOption` if no match\n */\nexport default function getClosestMatchingOption<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  rootSchema: S,\n  formData: T | undefined,\n  options: S[],\n  selectedOption = -1\n): number {\n  // Reduce the array of options down to a list of the indexes that are considered matching options\n  const allValidIndexes = options.reduce((validList: number[], option, index: number) => {\n    const testOptions: S[] = [JUNK_OPTION as S, option];\n    const match = getFirstMatchingOption<T, S, F>(validator, formData, testOptions, rootSchema);\n    // The match is the real option, so add its index to list of valid indexes\n    if (match === 1) {\n      validList.push(index);\n    }\n    return validList;\n  }, []);\n\n  // There is only one valid index, so return it!\n  if (allValidIndexes.length === 1) {\n    return allValidIndexes[0];\n  }\n  if (!allValidIndexes.length) {\n    // No indexes were valid, so we'll score all the options, add all the indexes\n    times(options.length, (i) => allValidIndexes.push(i));\n  }\n  type BestType = { bestIndex: number; bestScore: number };\n  // Score all the options in the list of valid indexes and return the index with the best score\n  const { bestIndex }: BestType = allValidIndexes.reduce(\n    (scoreData: BestType, index: number) => {\n      const { bestScore } = scoreData;\n      let option = options[index];\n      if (has(option, REF_KEY)) {\n        option = retrieveSchema<T, S, F>(validator, option, rootSchema, formData);\n      }\n      const score = calculateIndexScore(validator, rootSchema, option, formData);\n      if (score > bestScore) {\n        return { bestIndex: index, bestScore: score };\n      }\n      return scoreData;\n    },\n    { bestIndex: selectedOption, bestScore: 0 }\n  );\n  return bestIndex;\n}\n","import isObject from './isObject';\nimport { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Detects whether the given `schema` contains fixed items. This is the case when `schema.items` is a non-empty array\n * that only contains objects.\n *\n * @param schema - The schema in which to check for fixed items\n * @returns - True if there are fixed items in the schema, false otherwise\n */\nexport default function isFixedItems<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\n  return Array.isArray(schema.items) && schema.items.length > 0 && schema.items.every((item) => isObject(item));\n}\n","import get from 'lodash/get';\n\nimport isObject from './isObject';\nimport { GenericObjectType } from '../src';\n\n/** Merges the `defaults` object of type `T` into the `formData` of type `T`\n *\n * When merging defaults and form data, we want to merge in this specific way:\n * - objects are deeply merged\n * - arrays are merged in such a way that:\n *   - when the array is set in form data, only array entries set in form data\n *     are deeply merged; additional entries from the defaults are ignored\n *   - when the array is not set in form data, the default is copied over\n * - scalars are overwritten/set by form data\n *\n * @param [defaults] - The defaults to merge\n * @param [formData] - The form data into which the defaults will be merged\n * @returns - The resulting merged form data with defaults\n */\nexport default function mergeDefaultsWithFormData<T = any>(defaults?: T, formData?: T): T | undefined {\n  if (Array.isArray(formData)) {\n    const defaultsArray = Array.isArray(defaults) ? defaults : [];\n    const mapped = formData.map((value, idx) => {\n      if (defaultsArray[idx]) {\n        return mergeDefaultsWithFormData<any>(defaultsArray[idx], value);\n      }\n      return value;\n    });\n    return mapped as unknown as T;\n  }\n  if (isObject(formData)) {\n    const acc: { [key in keyof T]: any } = Object.assign({}, defaults); // Prevent mutation of source object.\n    return Object.keys(formData as GenericObjectType).reduce((acc, key) => {\n      acc[key as keyof T] = mergeDefaultsWithFormData<T>(defaults ? get(defaults, key) : {}, get(formData, key));\n      return acc;\n    }, acc);\n  }\n  return formData;\n}\n","import isObject from './isObject';\nimport { GenericObjectType } from './types';\n\n/** Recursively merge deeply nested objects.\n *\n * @param obj1 - The first object to merge\n * @param obj2 - The second object to merge\n * @param [concatArrays=false] - Optional flag that, when true, will cause arrays to be concatenated. Use\n *          \"preventDuplicates\" to merge arrays in a manner that prevents any duplicate entries from being merged.\n *          NOTE: Uses shallow comparison for the duplicate checking.\n * @returns - A new object that is the merge of the two given objects\n */\nexport default function mergeObjects(\n  obj1: GenericObjectType,\n  obj2: GenericObjectType,\n  concatArrays: boolean | 'preventDuplicates' = false\n) {\n  return Object.keys(obj2).reduce((acc, key) => {\n    const left = obj1 ? obj1[key] : {},\n      right = obj2[key];\n    if (obj1 && key in obj1 && isObject(right)) {\n      acc[key] = mergeObjects(left, right, concatArrays);\n    } else if (concatArrays && Array.isArray(left) && Array.isArray(right)) {\n      let toMerge = right;\n      if (concatArrays === 'preventDuplicates') {\n        toMerge = right.reduce((result, value) => {\n          if (!left.includes(value)) {\n            result.push(value);\n          }\n          return result;\n        }, []);\n      }\n      acc[key] = left.concat(toMerge);\n    } else {\n      acc[key] = right;\n    }\n    return acc;\n  }, Object.assign({}, obj1)); // Prevent mutation of source object.\n}\n","import { CONST_KEY } from './constants';\nimport { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** This function checks if the given `schema` matches a single constant value. This happens when either the schema has\n * an `enum` array with a single value or there is a `const` defined.\n *\n * @param schema - The schema for a field\n * @returns - True if the `schema` has a single constant value, false otherwise\n */\nexport default function isConstant<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\n  return (Array.isArray(schema.enum) && schema.enum.length === 1) || CONST_KEY in schema;\n}\n","import isConstant from '../isConstant';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport retrieveSchema from './retrieveSchema';\n\n/** Checks to see if the `schema` combination represents a select\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param theSchema - The schema for which check for a select flag is desired\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @returns - True if schema contains a select, otherwise false\n */\nexport default function isSelect<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  theSchema: S,\n  rootSchema: S = {} as S\n) {\n  const schema = retrieveSchema<T, S, F>(validator, theSchema, rootSchema, undefined);\n  const altSchemas = schema.oneOf || schema.anyOf;\n  if (Array.isArray(schema.enum)) {\n    return true;\n  }\n  if (Array.isArray(altSchemas)) {\n    return altSchemas.every((altSchemas) => typeof altSchemas !== 'boolean' && isConstant(altSchemas));\n  }\n  return false;\n}\n","import { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\n\nimport isSelect from './isSelect';\n\n/** Checks to see if the `schema` combination represents a multi-select\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which check for a multi-select flag is desired\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @returns - True if schema contains a multi-select, otherwise false\n */\nexport default function isMultiSelect<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S, F>, schema: S, rootSchema?: S) {\n  if (!schema.uniqueItems || !schema.items || typeof schema.items === 'boolean') {\n    return false;\n  }\n  return isSelect<T, S, F>(validator, schema.items as S, rootSchema);\n}\n","import get from 'lodash/get';\nimport isEmpty from 'lodash/isEmpty';\n\nimport { ANY_OF_KEY, DEFAULT_KEY, DEPENDENCIES_KEY, PROPERTIES_KEY, ONE_OF_KEY, REF_KEY } from '../constants';\nimport findSchemaDefinition from '../findSchemaDefinition';\nimport getClosestMatchingOption from './getClosestMatchingOption';\nimport getSchemaType from '../getSchemaType';\nimport isObject from '../isObject';\nimport isFixedItems from '../isFixedItems';\nimport mergeDefaultsWithFormData from '../mergeDefaultsWithFormData';\nimport mergeObjects from '../mergeObjects';\nimport { FormContextType, GenericObjectType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport isMultiSelect from './isMultiSelect';\nimport retrieveSchema, { resolveDependencies } from './retrieveSchema';\n\n/** Enum that indicates how `schema.additionalItems` should be handled by the `getInnerSchemaForArrayItem()` function.\n */\nexport enum AdditionalItemsHandling {\n  Ignore,\n  Invert,\n  Fallback,\n}\n\n/** Given a `schema` will return an inner schema that for an array item. This is computed differently based on the\n * `additionalItems` enum and the value of `idx`. There are four possible returns:\n * 1. If `idx` is >= 0, then if `schema.items` is an array the `idx`th element of the array is returned if it is a valid\n *    index and not a boolean, otherwise it falls through to 3.\n * 2. If `schema.items` is not an array AND truthy and not a boolean, then `schema.items` is returned since it actually\n *    is a schema, otherwise it falls through to 3.\n * 3. If `additionalItems` is not `AdditionalItemsHandling.Ignore` and `schema.additionalItems` is an object, then\n *    `schema.additionalItems` is returned since it actually is a schema, otherwise it falls through to 4.\n * 4. {} is returned representing an empty schema\n *\n * @param schema - The schema from which to get the particular item\n * @param [additionalItems=AdditionalItemsHandling.Ignore] - How do we want to handle additional items?\n * @param [idx=-1] - Index, if non-negative, will be used to return the idx-th element in a `schema.items` array\n * @returns - The best fit schema object from the `schema` given the `additionalItems` and `idx` modifiers\n */\nexport function getInnerSchemaForArrayItem<S extends StrictRJSFSchema = RJSFSchema>(\n  schema: S,\n  additionalItems: AdditionalItemsHandling = AdditionalItemsHandling.Ignore,\n  idx = -1\n): S {\n  if (idx >= 0) {\n    if (Array.isArray(schema.items) && idx < schema.items.length) {\n      const item = schema.items[idx];\n      if (typeof item !== 'boolean') {\n        return item as S;\n      }\n    }\n  } else if (schema.items && !Array.isArray(schema.items) && typeof schema.items !== 'boolean') {\n    return schema.items as S;\n  }\n  if (additionalItems !== AdditionalItemsHandling.Ignore && isObject(schema.additionalItems)) {\n    return schema.additionalItems as S;\n  }\n  return {} as S;\n}\n\n/** Either add `computedDefault` at `key` into `obj` or not add it based on its value and the value of\n * `includeUndefinedValues`. Generally undefined `computedDefault` values are added only when `includeUndefinedValues`\n * is either true or \"excludeObjectChildren\". If `includeUndefinedValues` is false, then non-undefined and\n * non-empty-object values will be added.\n *\n * @param obj - The object into which the computed default may be added\n * @param key - The key into the object at which the computed default may be added\n * @param computedDefault - The computed default value that maybe should be added to the obj\n * @param includeUndefinedValues - Optional flag, if true, cause undefined values to be added as defaults.\n *          If \"excludeObjectChildren\", cause undefined values for this object and pass `includeUndefinedValues` as\n *          false when computing defaults for any nested object properties. If \"allowEmptyObject\", prevents undefined\n *          values in this object while allow the object itself to be empty and passing `includeUndefinedValues` as\n *          false when computing defaults for any nested object properties.\n * @param requiredFields - The list of fields that are required\n */\nfunction maybeAddDefaultToObject<T = any>(\n  obj: GenericObjectType,\n  key: string,\n  computedDefault: T | T[] | undefined,\n  includeUndefinedValues: boolean | 'excludeObjectChildren',\n  requiredFields: string[] = []\n) {\n  if (includeUndefinedValues) {\n    obj[key] = computedDefault;\n  } else if (isObject(computedDefault)) {\n    // Store computedDefault if it's a non-empty object (e.g. not {})\n    if (!isEmpty(computedDefault) || requiredFields.includes(key)) {\n      obj[key] = computedDefault;\n    }\n  } else if (computedDefault !== undefined) {\n    // Store computedDefault if it's a defined primitive (e.g. true)\n    obj[key] = computedDefault;\n  }\n}\n\n/** Computes the defaults for the current `schema` given the `rawFormData` and `parentDefaults` if any. This drills into\n * each level of the schema, recursively, to fill out every level of defaults provided by the schema.\n *\n * @param validator - an implementation of the `ValidatorType` interface that will be used when necessary\n * @param rawSchema - The schema for which the default state is desired\n * @param [parentDefaults] - Any defaults provided by the parent field in the schema\n * @param [rootSchema] - The options root schema, used to primarily to look up `$ref`s\n * @param [rawFormData] - The current formData, if any, onto which to provide any missing defaults\n * @param [includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.\n *          If \"excludeObjectChildren\", cause undefined values for this object and pass `includeUndefinedValues` as\n *          false when computing defaults for any nested object properties.\n * @returns - The resulting `formData` with all the defaults provided\n */\nexport function computeDefaults<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  rawSchema: S,\n  parentDefaults?: T,\n  rootSchema: S = {} as S,\n  rawFormData?: T,\n  includeUndefinedValues: boolean | 'excludeObjectChildren' = false\n): T | T[] | undefined {\n  const formData: T = (isObject(rawFormData) ? rawFormData : {}) as T;\n  let schema: S = isObject(rawSchema) ? rawSchema : ({} as S);\n  // Compute the defaults recursively: give highest priority to deepest nodes.\n  let defaults: T | T[] | undefined = parentDefaults;\n  if (isObject(defaults) && isObject(schema.default)) {\n    // For object defaults, only override parent defaults that are defined in\n    // schema.default.\n    defaults = mergeObjects(defaults!, schema.default as GenericObjectType) as T;\n  } else if (DEFAULT_KEY in schema) {\n    defaults = schema.default as unknown as T;\n  } else if (REF_KEY in schema) {\n    // Use referenced schema defaults for this node.\n    const refSchema = findSchemaDefinition<S>(schema[REF_KEY]!, rootSchema);\n    return computeDefaults<T, S, F>(validator, refSchema, defaults, rootSchema, formData as T, includeUndefinedValues);\n  } else if (DEPENDENCIES_KEY in schema) {\n    const resolvedSchema = resolveDependencies<T, S, F>(validator, schema, rootSchema, formData);\n    return computeDefaults<T, S, F>(\n      validator,\n      resolvedSchema,\n      defaults,\n      rootSchema,\n      formData as T,\n      includeUndefinedValues\n    );\n  } else if (isFixedItems(schema)) {\n    defaults = (schema.items! as S[]).map((itemSchema: S, idx: number) =>\n      computeDefaults<T, S>(\n        validator,\n        itemSchema,\n        Array.isArray(parentDefaults) ? parentDefaults[idx] : undefined,\n        rootSchema,\n        formData as T,\n        includeUndefinedValues\n      )\n    ) as T[];\n  } else if (ONE_OF_KEY in schema) {\n    if (schema.oneOf!.length === 0) {\n      return undefined;\n    }\n    schema = schema.oneOf![\n      getClosestMatchingOption<T, S, F>(\n        validator,\n        rootSchema,\n        isEmpty(formData) ? undefined : formData,\n        schema.oneOf as S[],\n        0\n      )\n    ] as S;\n  } else if (ANY_OF_KEY in schema) {\n    if (schema.anyOf!.length === 0) {\n      return undefined;\n    }\n    schema = schema.anyOf![\n      getClosestMatchingOption<T, S, F>(\n        validator,\n        rootSchema,\n        isEmpty(formData) ? undefined : formData,\n        schema.anyOf as S[],\n        0\n      )\n    ] as S;\n  }\n\n  // Not defaults defined for this node, fallback to generic typed ones.\n  if (typeof defaults === 'undefined') {\n    defaults = schema.default as unknown as T;\n  }\n\n  switch (getSchemaType<S>(schema)) {\n    // We need to recur for object schema inner default values.\n    case 'object': {\n      const objectDefaults = Object.keys(schema.properties || {}).reduce((acc: GenericObjectType, key: string) => {\n        // Compute the defaults for this node, with the parent defaults we might\n        // have from a previous run: defaults[key].\n        const computedDefault = computeDefaults<T, S, F>(\n          validator,\n          get(schema, [PROPERTIES_KEY, key]),\n          get(defaults, [key]),\n          rootSchema,\n          get(formData, [key]),\n          includeUndefinedValues === true\n        );\n        maybeAddDefaultToObject<T>(acc, key, computedDefault, includeUndefinedValues, schema.required);\n        return acc;\n      }, {}) as T;\n      if (schema.additionalProperties && isObject(defaults)) {\n        const additionalPropertiesSchema = isObject(schema.additionalProperties) ? schema.additionalProperties : {}; // as per spec additionalProperties may be either schema or boolean\n        Object.keys(defaults as GenericObjectType)\n          .filter((key) => !schema.properties || !schema.properties[key])\n          .forEach((key) => {\n            const computedDefault = computeDefaults(\n              validator,\n              additionalPropertiesSchema as S,\n              get(defaults, [key]),\n              rootSchema,\n              get(formData, [key]),\n              includeUndefinedValues === true\n            );\n            maybeAddDefaultToObject<T>(\n              objectDefaults as GenericObjectType,\n              key,\n              computedDefault,\n              includeUndefinedValues\n            );\n          });\n      }\n      return objectDefaults;\n    }\n    case 'array':\n      // Inject defaults into existing array defaults\n      if (Array.isArray(defaults)) {\n        defaults = defaults.map((item, idx) => {\n          const schemaItem: S = getInnerSchemaForArrayItem<S>(schema, AdditionalItemsHandling.Fallback, idx);\n          return computeDefaults<T, S, F>(validator, schemaItem, item, rootSchema);\n        }) as T[];\n      }\n\n      // Deeply inject defaults into already existing form data\n      if (Array.isArray(rawFormData)) {\n        const schemaItem: S = getInnerSchemaForArrayItem<S>(schema);\n        defaults = rawFormData.map((item: T, idx: number) => {\n          return computeDefaults<T, S, F>(validator, schemaItem, get(defaults, [idx]), rootSchema, item);\n        }) as T[];\n      }\n      if (schema.minItems) {\n        if (!isMultiSelect<T, S, F>(validator, schema, rootSchema)) {\n          const defaultsLength = Array.isArray(defaults) ? defaults.length : 0;\n          if (schema.minItems > defaultsLength) {\n            const defaultEntries: T[] = (defaults || []) as T[];\n            // populate the array with the defaults\n            const fillerSchema: S = getInnerSchemaForArrayItem<S>(schema, AdditionalItemsHandling.Invert);\n            const fillerDefault = fillerSchema.default;\n            const fillerEntries: T[] = new Array(schema.minItems - defaultsLength).fill(\n              computeDefaults<any, S, F>(validator, fillerSchema, fillerDefault, rootSchema)\n            ) as T[];\n            // then fill up the rest with either the item default or empty, up to minItems\n            return defaultEntries.concat(fillerEntries);\n          }\n        }\n        return defaults ? defaults : [];\n      }\n  }\n  return defaults;\n}\n\n/** Returns the superset of `formData` that includes the given set updated to include any missing fields that have\n * computed to have defaults provided in the `schema`.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param theSchema - The schema for which the default state is desired\n * @param [formData] - The current formData, if any, onto which to provide any missing defaults\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.\n *          If \"excludeObjectChildren\", cause undefined values for this object and pass `includeUndefinedValues` as\n *          false when computing defaults for any nested object properties.\n * @returns - The resulting `formData` with all the defaults provided\n */\nexport default function getDefaultFormState<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  theSchema: S,\n  formData?: T,\n  rootSchema?: S,\n  includeUndefinedValues: boolean | 'excludeObjectChildren' = false\n) {\n  if (!isObject(theSchema)) {\n    throw new Error('Invalid schema: ' + theSchema);\n  }\n  const schema = retrieveSchema<T, S, F>(validator, theSchema, rootSchema, formData);\n  const defaults = computeDefaults<T, S, F>(validator, schema, undefined, rootSchema, formData, includeUndefinedValues);\n  if (typeof formData === 'undefined' || formData === null || (typeof formData === 'number' && isNaN(formData))) {\n    // No form data? Use schema defaults.\n    return defaults;\n  }\n  if (isObject(formData)) {\n    return mergeDefaultsWithFormData<T>(defaults as T, formData);\n  }\n  if (Array.isArray(formData)) {\n    return mergeDefaultsWithFormData<T[]>(defaults as T[], formData);\n  }\n  return formData;\n}\n","import getUiOptions from './getUiOptions';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, UiSchema } from './types';\n\n/** Checks to see if the `uiSchema` contains the `widget` field and that the widget is not `hidden`\n *\n * @param uiSchema - The UI Schema from which to detect if it is customized\n * @returns - True if the `uiSchema` describes a custom widget, false otherwise\n */\nexport default function isCustomWidget<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(uiSchema: UiSchema<T, S, F> = {}) {\n  return (\n    // TODO: Remove the `&& uiSchema['ui:widget'] !== 'hidden'` once we support hidden widgets for arrays.\n    // https://rjsf-team.github.io/react-jsonschema-form/docs/usage/widgets/#hidden-widgets\n    'widget' in getUiOptions<T, S, F>(uiSchema) && getUiOptions<T, S, F>(uiSchema)['widget'] !== 'hidden'\n  );\n}\n","import { UI_WIDGET_KEY } from '../constants';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, UiSchema, ValidatorType } from '../types';\nimport retrieveSchema from './retrieveSchema';\n\n/** Checks to see if the `schema` and `uiSchema` combination represents an array of files\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which check for array of files flag is desired\n * @param [uiSchema={}] - The UI schema from which to check the widget\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @returns - True if schema/uiSchema contains an array of files, otherwise false\n */\nexport default function isFilesArray<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  uiSchema: UiSchema<T, S, F> = {},\n  rootSchema?: S\n) {\n  if (uiSchema[UI_WIDGET_KEY] === 'files') {\n    return true;\n  }\n  if (schema.items) {\n    const itemsSchema = retrieveSchema<T, S, F>(validator, schema.items as S, rootSchema);\n    return itemsSchema.type === 'string' && itemsSchema.format === 'data-url';\n  }\n  return false;\n}\n","import { UI_FIELD_KEY, UI_WIDGET_KEY } from '../constants';\nimport getSchemaType from '../getSchemaType';\nimport getUiOptions from '../getUiOptions';\nimport isCustomWidget from '../isCustomWidget';\nimport {\n  FormContextType,\n  GlobalUISchemaOptions,\n  RJSFSchema,\n  StrictRJSFSchema,\n  UiSchema,\n  ValidatorType,\n} from '../types';\nimport isFilesArray from './isFilesArray';\nimport isMultiSelect from './isMultiSelect';\n\n/** Determines whether the combination of `schema` and `uiSchema` properties indicates that the label for the `schema`\n * should be displayed in a UI.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which the display label flag is desired\n * @param [uiSchema={}] - The UI schema from which to derive potentially displayable information\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [globalOptions={}] - The optional Global UI Schema from which to get any fallback `xxx` options\n * @returns - True if the label should be displayed or false if it should not\n */\nexport default function getDisplayLabel<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  uiSchema: UiSchema<T, S, F> = {},\n  rootSchema?: S,\n  globalOptions?: GlobalUISchemaOptions\n): boolean {\n  const uiOptions = getUiOptions<T, S, F>(uiSchema, globalOptions);\n  const { label = true } = uiOptions;\n  let displayLabel = !!label;\n  const schemaType = getSchemaType<S>(schema);\n\n  if (schemaType === 'array') {\n    displayLabel =\n      isMultiSelect<T, S, F>(validator, schema, rootSchema) ||\n      isFilesArray<T, S, F>(validator, schema, uiSchema, rootSchema) ||\n      isCustomWidget(uiSchema);\n  }\n\n  if (schemaType === 'object') {\n    displayLabel = false;\n  }\n  if (schemaType === 'boolean' && !uiSchema[UI_WIDGET_KEY]) {\n    displayLabel = false;\n  }\n  if (uiSchema[UI_FIELD_KEY]) {\n    displayLabel = false;\n  }\n  return displayLabel;\n}\n","import isEmpty from 'lodash/isEmpty';\n\nimport mergeObjects from '../mergeObjects';\nimport { ErrorSchema, FormContextType, RJSFSchema, StrictRJSFSchema, ValidationData, ValidatorType } from '../types';\n\n/** Merges the errors in `additionalErrorSchema` into the existing `validationData` by combining the hierarchies in the\n * two `ErrorSchema`s and then appending the error list from the `additionalErrorSchema` obtained by calling\n * `validator.toErrorList()` onto the `errors` in the `validationData`. If no `additionalErrorSchema` is passed, then\n * `validationData` is returned.\n *\n * @param validator - The validator used to convert an ErrorSchema to a list of errors\n * @param validationData - The current `ValidationData` into which to merge the additional errors\n * @param [additionalErrorSchema] - The additional set of errors in an `ErrorSchema`\n * @returns - The `validationData` with the additional errors from `additionalErrorSchema` merged into it, if provided.\n */\nexport default function mergeValidationData<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  validationData: ValidationData<T>,\n  additionalErrorSchema?: ErrorSchema<T>\n): ValidationData<T> {\n  if (!additionalErrorSchema) {\n    return validationData;\n  }\n  const { errors: oldErrors, errorSchema: oldErrorSchema } = validationData;\n  let errors = validator.toErrorList(additionalErrorSchema);\n  let errorSchema = additionalErrorSchema;\n  if (!isEmpty(oldErrorSchema)) {\n    errorSchema = mergeObjects(oldErrorSchema, additionalErrorSchema, true) as ErrorSchema<T>;\n    errors = [...oldErrors].concat(errors);\n  }\n  return { errorSchema, errors };\n}\n","import get from 'lodash/get';\nimport has from 'lodash/has';\n\nimport { FormContextType, GenericObjectType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport { PROPERTIES_KEY, REF_KEY } from '../constants';\nimport retrieveSchema from './retrieveSchema';\n\nconst NO_VALUE = Symbol('no Value');\n\n/** Sanitize the `data` associated with the `oldSchema` so it is considered appropriate for the `newSchema`. If the new\n * schema does not contain any properties, then `undefined` is returned to clear all the form data. Due to the nature\n * of schemas, this sanitization happens recursively for nested objects of data. Also, any properties in the old schema\n * that are non-existent in the new schema are set to `undefined`. The data sanitization process has the following flow:\n *\n * - If the new schema is an object that contains a `properties` object then:\n *   - Create a `removeOldSchemaData` object, setting each key in the `oldSchema.properties` having `data` to undefined\n *   - Create an empty `nestedData` object for use in the key filtering below:\n *   - Iterate over each key in the `newSchema.properties` as follows:\n *     - Get the `formValue` of the key from the `data`\n *     - Get the `oldKeySchema` and `newKeyedSchema` for the key, defaulting to `{}` when it doesn't exist\n *     - Retrieve the schema for any refs within each `oldKeySchema` and/or `newKeySchema`\n *     - Get the types of the old and new keyed schemas and if the old doesn't exist or the old & new are the same then:\n *       - If `removeOldSchemaData` has an entry for the key, delete it since the new schema has the same property\n *       - If type of the key in the new schema is `object`:\n *         - Store the value from the recursive `sanitizeDataForNewSchema` call in `nestedData[key]`\n *       - Otherwise, check for default or const values:\n *         - Get the old and new `default` values from the schema and check:\n *           - If the new `default` value does not match the form value:\n *             - If the old `default` value DOES match the form value, then:\n *               - Replace `removeOldSchemaData[key]` with the new `default`\n *               - Otherwise, if the new schema is `readOnly` then replace `removeOldSchemaData[key]` with undefined\n *         - Get the old and new `const` values from the schema and check:\n *           - If the new `const` value does not match the form value:\n *           - If the old `const` value DOES match the form value, then:\n *             - Replace `removeOldSchemaData[key]` with the new `const`\n *             - Otherwise, replace `removeOldSchemaData[key]` with undefined\n *   - Once all keys have been processed, return an object built as follows:\n *     - `{ ...removeOldSchemaData, ...nestedData, ...pick(data, keysToKeep) }`\n * - If the new and old schema types are array and the `data` is an array then:\n *   - If the type of the old and new schema `items` are a non-array objects:\n *     - Retrieve the schema for any refs within each `oldKeySchema.items` and/or `newKeySchema.items`\n *     - If the `type`s of both items are the same (or the old does not have a type):\n *       - If the type is \"object\", then:\n *         - For each element in the `data` recursively sanitize the data, stopping at `maxItems` if specified\n *       - Otherwise, just return the `data` removing any values after `maxItems` if it is set\n *   - If the type of the old and new schema `items` are booleans of the same value, return `data` as is\n * - Otherwise return `undefined`\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param rootSchema - The root JSON schema of the entire form\n * @param [newSchema] - The new schema for which the data is being sanitized\n * @param [oldSchema] - The old schema from which the data originated\n * @param [data={}] - The form data associated with the schema, defaulting to an empty object when undefined\n * @returns - The new form data, with all the fields uniquely associated with the old schema set\n *      to `undefined`. Will return `undefined` if the new schema is not an object containing properties.\n */\nexport default function sanitizeDataForNewSchema<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S, F>, rootSchema: S, newSchema?: S, oldSchema?: S, data: any = {}): T {\n  // By default, we will clear the form data\n  let newFormData;\n  // If the new schema is of type object and that object contains a list of properties\n  if (has(newSchema, PROPERTIES_KEY)) {\n    // Create an object containing root-level keys in the old schema, setting each key to undefined to remove the data\n    const removeOldSchemaData: GenericObjectType = {};\n    if (has(oldSchema, PROPERTIES_KEY)) {\n      const properties = get(oldSchema, PROPERTIES_KEY, {});\n      Object.keys(properties).forEach((key) => {\n        if (has(data, key)) {\n          removeOldSchemaData[key] = undefined;\n        }\n      });\n    }\n    const keys: string[] = Object.keys(get(newSchema, PROPERTIES_KEY, {}));\n    // Create a place to store nested data that will be a side-effect of the filter\n    const nestedData: GenericObjectType = {};\n    keys.forEach((key) => {\n      const formValue = get(data, key);\n      let oldKeyedSchema: S = get(oldSchema, [PROPERTIES_KEY, key], {});\n      let newKeyedSchema: S = get(newSchema, [PROPERTIES_KEY, key], {});\n      // Resolve the refs if they exist\n      if (has(oldKeyedSchema, REF_KEY)) {\n        oldKeyedSchema = retrieveSchema<T, S, F>(validator, oldKeyedSchema, rootSchema, formValue);\n      }\n      if (has(newKeyedSchema, REF_KEY)) {\n        newKeyedSchema = retrieveSchema<T, S, F>(validator, newKeyedSchema, rootSchema, formValue);\n      }\n      // Now get types and see if they are the same\n      const oldSchemaTypeForKey = get(oldKeyedSchema, 'type');\n      const newSchemaTypeForKey = get(newKeyedSchema, 'type');\n      // Check if the old option has the same key with the same type\n      if (!oldSchemaTypeForKey || oldSchemaTypeForKey === newSchemaTypeForKey) {\n        if (has(removeOldSchemaData, key)) {\n          // SIDE-EFFECT: remove the undefined value for a key that has the same type between the old and new schemas\n          delete removeOldSchemaData[key];\n        }\n        // If it is an object, we'll recurse and store the resulting sanitized data for the key\n        if (newSchemaTypeForKey === 'object' || (newSchemaTypeForKey === 'array' && Array.isArray(formValue))) {\n          // SIDE-EFFECT: process the new schema type of object recursively to save iterations\n          const itemData = sanitizeDataForNewSchema<T, S, F>(\n            validator,\n            rootSchema,\n            newKeyedSchema,\n            oldKeyedSchema,\n            formValue\n          );\n          if (itemData !== undefined || newSchemaTypeForKey === 'array') {\n            // only put undefined values for the array type and not the object type\n            nestedData[key] = itemData;\n          }\n        } else {\n          // Ok, the non-object types match, let's make sure that a default or a const of a different value is replaced\n          // with the new default or const. This allows the case where two schemas differ that only by the default/const\n          // value to be properly selected\n          const newOptionDefault = get(newKeyedSchema, 'default', NO_VALUE);\n          const oldOptionDefault = get(oldKeyedSchema, 'default', NO_VALUE);\n          if (newOptionDefault !== NO_VALUE && newOptionDefault !== formValue) {\n            if (oldOptionDefault === formValue) {\n              // If the old default matches the formValue, we'll update the new value to match the new default\n              removeOldSchemaData[key] = newOptionDefault;\n            } else if (get(newKeyedSchema, 'readOnly') === true) {\n              // If the new schema has the default set to read-only, treat it like a const and remove the value\n              removeOldSchemaData[key] = undefined;\n            }\n          }\n\n          const newOptionConst = get(newKeyedSchema, 'const', NO_VALUE);\n          const oldOptionConst = get(oldKeyedSchema, 'const', NO_VALUE);\n          if (newOptionConst !== NO_VALUE && newOptionConst !== formValue) {\n            // Since this is a const, if the old value matches, replace the value with the new const otherwise clear it\n            removeOldSchemaData[key] = oldOptionConst === formValue ? newOptionConst : undefined;\n          }\n        }\n      }\n    });\n\n    newFormData = {\n      ...data,\n      ...removeOldSchemaData,\n      ...nestedData,\n    };\n    // First apply removing the old schema data, then apply the nested data, then apply the old data keys to keep\n  } else if (get(oldSchema, 'type') === 'array' && get(newSchema, 'type') === 'array' && Array.isArray(data)) {\n    let oldSchemaItems = get(oldSchema, 'items');\n    let newSchemaItems = get(newSchema, 'items');\n    // If any of the array types `items` are arrays (remember arrays are objects) then we'll just drop the data\n    // Eventually, we may want to deal with when either of the `items` are arrays since those tuple validations\n    if (\n      typeof oldSchemaItems === 'object' &&\n      typeof newSchemaItems === 'object' &&\n      !Array.isArray(oldSchemaItems) &&\n      !Array.isArray(newSchemaItems)\n    ) {\n      if (has(oldSchemaItems, REF_KEY)) {\n        oldSchemaItems = retrieveSchema<T, S, F>(validator, oldSchemaItems as S, rootSchema, data as T);\n      }\n      if (has(newSchemaItems, REF_KEY)) {\n        newSchemaItems = retrieveSchema<T, S, F>(validator, newSchemaItems as S, rootSchema, data as T);\n      }\n      // Now get types and see if they are the same\n      const oldSchemaType = get(oldSchemaItems, 'type');\n      const newSchemaType = get(newSchemaItems, 'type');\n      // Check if the old option has the same key with the same type\n      if (!oldSchemaType || oldSchemaType === newSchemaType) {\n        const maxItems = get(newSchema, 'maxItems', -1);\n        if (newSchemaType === 'object') {\n          newFormData = data.reduce((newValue, aValue) => {\n            const itemValue = sanitizeDataForNewSchema<T, S, F>(\n              validator,\n              rootSchema,\n              newSchemaItems as S,\n              oldSchemaItems as S,\n              aValue\n            );\n            if (itemValue !== undefined && (maxItems < 0 || newValue.length < maxItems)) {\n              newValue.push(itemValue);\n            }\n            return newValue;\n          }, []);\n        } else {\n          newFormData = maxItems > 0 && data.length > maxItems ? data.slice(0, maxItems) : data;\n        }\n      }\n    } else if (\n      typeof oldSchemaItems === 'boolean' &&\n      typeof newSchemaItems === 'boolean' &&\n      oldSchemaItems === newSchemaItems\n    ) {\n      // If they are both booleans and have the same value just return the data as is otherwise fall-thru to undefined\n      newFormData = data;\n    }\n    // Also probably want to deal with `prefixItems` as tuples with the latest 2020 draft\n  }\n  return newFormData as T;\n}\n","import get from 'lodash/get';\n\nimport { ALL_OF_KEY, DEPENDENCIES_KEY, ID_KEY, ITEMS_KEY, PROPERTIES_KEY, REF_KEY } from '../constants';\nimport isObject from '../isObject';\nimport { FormContextType, IdSchema, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport retrieveSchema from './retrieveSchema';\n\n/** Generates an `IdSchema` object for the `schema`, recursively\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which the `IdSchema` is desired\n * @param [id] - The base id for the schema\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @param [idPrefix='root'] - The prefix to use for the id\n * @param [idSeparator='_'] - The separator to use for the path segments in the id\n * @returns - The `IdSchema` object for the `schema`\n */\nexport default function toIdSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  id?: string | null,\n  rootSchema?: S,\n  formData?: T,\n  idPrefix = 'root',\n  idSeparator = '_'\n): IdSchema<T> {\n  if (REF_KEY in schema || DEPENDENCIES_KEY in schema || ALL_OF_KEY in schema) {\n    const _schema = retrieveSchema<T, S, F>(validator, schema, rootSchema, formData);\n    return toIdSchema<T, S, F>(validator, _schema, id, rootSchema, formData, idPrefix, idSeparator);\n  }\n  if (ITEMS_KEY in schema && !get(schema, [ITEMS_KEY, REF_KEY])) {\n    return toIdSchema<T, S, F>(validator, get(schema, ITEMS_KEY) as S, id, rootSchema, formData, idPrefix, idSeparator);\n  }\n  const $id = id || idPrefix;\n  const idSchema: IdSchema = { $id } as IdSchema<T>;\n  if (schema.type === 'object' && PROPERTIES_KEY in schema) {\n    for (const name in schema.properties) {\n      const field = get(schema, [PROPERTIES_KEY, name]);\n      const fieldId = idSchema[ID_KEY] + idSeparator + name;\n      idSchema[name] = toIdSchema<T, S, F>(\n        validator,\n        isObject(field) ? field : {},\n        fieldId,\n        rootSchema,\n        // It's possible that formData is not an object -- this can happen if an\n        // array item has just been added, but not populated with data yet\n        get(formData, [name]),\n        idPrefix,\n        idSeparator\n      );\n    }\n  }\n  return idSchema as IdSchema<T>;\n}\n","import get from 'lodash/get';\nimport set from 'lodash/set';\n\nimport {\n  ALL_OF_KEY,\n  ANY_OF_KEY,\n  ADDITIONAL_PROPERTIES_KEY,\n  DEPENDENCIES_KEY,\n  ITEMS_KEY,\n  NAME_KEY,\n  ONE_OF_KEY,\n  PROPERTIES_KEY,\n  REF_KEY,\n  RJSF_ADDITONAL_PROPERTIES_FLAG,\n} from '../constants';\nimport { FormContextType, PathSchema, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport { getClosestMatchingOption } from './index';\nimport retrieveSchema from './retrieveSchema';\n\n/** Generates an `PathSchema` object for the `schema`, recursively\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which the `PathSchema` is desired\n * @param [name=''] - The base name for the schema\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The `PathSchema` object for the `schema`\n */\nexport default function toPathSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  name = '',\n  rootSchema?: S,\n  formData?: T\n): PathSchema<T> {\n  if (REF_KEY in schema || DEPENDENCIES_KEY in schema || ALL_OF_KEY in schema) {\n    const _schema = retrieveSchema<T, S, F>(validator, schema, rootSchema, formData);\n    return toPathSchema<T, S, F>(validator, _schema, name, rootSchema, formData);\n  }\n\n  const pathSchema: PathSchema = {\n    [NAME_KEY]: name.replace(/^\\./, ''),\n  } as PathSchema;\n\n  if (ONE_OF_KEY in schema) {\n    const index = getClosestMatchingOption<T, S, F>(validator, rootSchema!, formData, schema.oneOf as S[], 0);\n    const _schema: S = schema.oneOf![index] as S;\n    return toPathSchema<T, S, F>(validator, _schema, name, rootSchema, formData);\n  }\n\n  if (ANY_OF_KEY in schema) {\n    const index = getClosestMatchingOption<T, S, F>(validator, rootSchema!, formData, schema.anyOf as S[], 0);\n    const _schema: S = schema.anyOf![index] as S;\n    return toPathSchema<T, S, F>(validator, _schema, name, rootSchema, formData);\n  }\n\n  if (ADDITIONAL_PROPERTIES_KEY in schema && schema[ADDITIONAL_PROPERTIES_KEY] !== false) {\n    set(pathSchema, RJSF_ADDITONAL_PROPERTIES_FLAG, true);\n  }\n\n  if (ITEMS_KEY in schema && Array.isArray(formData)) {\n    formData.forEach((element, i: number) => {\n      pathSchema[i] = toPathSchema<T, S, F>(validator, schema.items as S, `${name}.${i}`, rootSchema, element);\n    });\n  } else if (PROPERTIES_KEY in schema) {\n    for (const property in schema.properties) {\n      const field = get(schema, [PROPERTIES_KEY, property]);\n      pathSchema[property] = toPathSchema<T, S, F>(\n        validator,\n        field,\n        `${name}.${property}`,\n        rootSchema,\n        // It's possible that formData is not an object -- this can happen if an\n        // array item has just been added, but not populated with data yet\n        get(formData, [property])\n      );\n    }\n  }\n  return pathSchema as PathSchema<T>;\n}\n","import deepEquals from './deepEquals';\nimport {\n  ErrorSchema,\n  FormContextType,\n  GlobalUISchemaOptions,\n  IdSchema,\n  PathSchema,\n  RJSFSchema,\n  SchemaUtilsType,\n  StrictRJSFSchema,\n  UiSchema,\n  ValidationData,\n  ValidatorType,\n} from './types';\nimport {\n  getDefaultFormState,\n  getDisplayLabel,\n  getClosestMatchingOption,\n  getFirstMatchingOption,\n  getMatchingOption,\n  isFilesArray,\n  isMultiSelect,\n  isSelect,\n  mergeValidationData,\n  retrieveSchema,\n  sanitizeDataForNewSchema,\n  toIdSchema,\n  toPathSchema,\n} from './schema';\n\n/** The `SchemaUtils` class provides a wrapper around the publicly exported APIs in the `utils/schema` directory such\n * that one does not have to explicitly pass the `validator` or `rootSchema` to each method. Since both the `validator`\n * and `rootSchema` generally does not change across a `Form`, this allows for providing a simplified set of APIs to the\n * `@rjsf/core` components and the various themes as well. This class implements the `SchemaUtilsType` interface.\n */\nclass SchemaUtils<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>\n  implements SchemaUtilsType<T, S, F>\n{\n  rootSchema: S;\n  validator: ValidatorType<T, S, F>;\n\n  /** Constructs the `SchemaUtils` instance with the given `validator` and `rootSchema` stored as instance variables\n   *\n   * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n   * @param rootSchema - The root schema that will be forwarded to all the APIs\n   */\n  constructor(validator: ValidatorType<T, S, F>, rootSchema: S) {\n    this.rootSchema = rootSchema;\n    this.validator = validator;\n  }\n\n  /** Returns the `ValidatorType` in the `SchemaUtilsType`\n   *\n   * @returns - The `ValidatorType`\n   */\n  getValidator() {\n    return this.validator;\n  }\n\n  /** Determines whether either the `validator` and `rootSchema` differ from the ones associated with this instance of\n   * the `SchemaUtilsType`. If either `validator` or `rootSchema` are falsy, then return false to prevent the creation\n   * of a new `SchemaUtilsType` with incomplete properties.\n   *\n   * @param validator - An implementation of the `ValidatorType` interface that will be compared against the current one\n   * @param rootSchema - The root schema that will be compared against the current one\n   * @returns - True if the `SchemaUtilsType` differs from the given `validator` or `rootSchema`\n   */\n  doesSchemaUtilsDiffer(validator: ValidatorType<T, S, F>, rootSchema: S): boolean {\n    if (!validator || !rootSchema) {\n      return false;\n    }\n    return this.validator !== validator || !deepEquals(this.rootSchema, rootSchema);\n  }\n\n  /** Returns the superset of `formData` that includes the given set updated to include any missing fields that have\n   * computed to have defaults provided in the `schema`.\n   *\n   * @param schema - The schema for which the default state is desired\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\n   * @param [includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.\n   *          If \"excludeObjectChildren\", pass `includeUndefinedValues` as false when computing defaults for any nested\n   *          object properties.\n   * @returns - The resulting `formData` with all the defaults provided\n   */\n  getDefaultFormState(\n    schema: S,\n    formData?: T,\n    includeUndefinedValues: boolean | 'excludeObjectChildren' = false\n  ): T | T[] | undefined {\n    return getDefaultFormState<T, S, F>(this.validator, schema, formData, this.rootSchema, includeUndefinedValues);\n  }\n\n  /** Determines whether the combination of `schema` and `uiSchema` properties indicates that the label for the `schema`\n   * should be displayed in a UI.\n   *\n   * @param schema - The schema for which the display label flag is desired\n   * @param [uiSchema] - The UI schema from which to derive potentially displayable information\n   * @param [globalOptions={}] - The optional Global UI Schema from which to get any fallback `xxx` options\n   * @returns - True if the label should be displayed or false if it should not\n   */\n  getDisplayLabel(schema: S, uiSchema?: UiSchema<T, S, F>, globalOptions?: GlobalUISchemaOptions) {\n    return getDisplayLabel<T, S, F>(this.validator, schema, uiSchema, this.rootSchema, globalOptions);\n  }\n\n  /** Determines which of the given `options` provided most closely matches the `formData`.\n   * Returns the index of the option that is valid and is the closest match, or 0 if there is no match.\n   *\n   * The closest match is determined using the number of matching properties, and more heavily favors options with\n   * matching readOnly, default, or const values.\n   *\n   * @param formData - The form data associated with the schema\n   * @param options - The list of options that can be selected from\n   * @param [selectedOption] - The index of the currently selected option, defaulted to -1 if not specified\n   * @returns - The index of the option that is the closest match to the `formData` or the `selectedOption` if no match\n   */\n  getClosestMatchingOption(formData: T | undefined, options: S[], selectedOption?: number): number {\n    return getClosestMatchingOption<T, S, F>(this.validator, this.rootSchema, formData, options, selectedOption);\n  }\n\n  /** Given the `formData` and list of `options`, attempts to find the index of the first option that matches the data.\n   * Always returns the first option if there is nothing that matches.\n   *\n   * @param formData - The current formData, if any, used to figure out a match\n   * @param options - The list of options to find a matching options from\n   * @returns - The firstindex of the matched option or 0 if none is available\n   */\n  getFirstMatchingOption(formData: T | undefined, options: S[]): number {\n    return getFirstMatchingOption<T, S, F>(this.validator, formData, options, this.rootSchema);\n  }\n\n  /** Given the `formData` and list of `options`, attempts to find the index of the option that best matches the data.\n   * Deprecated, use `getFirstMatchingOption()` instead.\n   *\n   * @param formData - The current formData, if any, onto which to provide any missing defaults\n   * @param options - The list of options to find a matching options from\n   * @returns - The index of the matched option or 0 if none is available\n   * @deprecated\n   */\n  getMatchingOption(formData: T | undefined, options: S[]) {\n    return getMatchingOption<T, S, F>(this.validator, formData, options, this.rootSchema);\n  }\n\n  /** Checks to see if the `schema` and `uiSchema` combination represents an array of files\n   *\n   * @param schema - The schema for which check for array of files flag is desired\n   * @param [uiSchema] - The UI schema from which to check the widget\n   * @returns - True if schema/uiSchema contains an array of files, otherwise false\n   */\n  isFilesArray(schema: S, uiSchema?: UiSchema<T, S, F>) {\n    return isFilesArray<T, S, F>(this.validator, schema, uiSchema, this.rootSchema);\n  }\n\n  /** Checks to see if the `schema` combination represents a multi-select\n   *\n   * @param schema - The schema for which check for a multi-select flag is desired\n   * @returns - True if schema contains a multi-select, otherwise false\n   */\n  isMultiSelect(schema: S) {\n    return isMultiSelect<T, S, F>(this.validator, schema, this.rootSchema);\n  }\n\n  /** Checks to see if the `schema` combination represents a select\n   *\n   * @param schema - The schema for which check for a select flag is desired\n   * @returns - True if schema contains a select, otherwise false\n   */\n  isSelect(schema: S) {\n    return isSelect<T, S, F>(this.validator, schema, this.rootSchema);\n  }\n\n  /** Merges the errors in `additionalErrorSchema` into the existing `validationData` by combining the hierarchies in\n   * the two `ErrorSchema`s and then appending the error list from the `additionalErrorSchema` obtained by calling\n   * `getValidator().toErrorList()` onto the `errors` in the `validationData`. If no `additionalErrorSchema` is passed,\n   * then `validationData` is returned.\n   *\n   * @param validationData - The current `ValidationData` into which to merge the additional errors\n   * @param [additionalErrorSchema] - The additional set of errors\n   * @returns - The `validationData` with the additional errors from `additionalErrorSchema` merged into it, if provided.\n   */\n  mergeValidationData(validationData: ValidationData<T>, additionalErrorSchema?: ErrorSchema<T>): ValidationData<T> {\n    return mergeValidationData<T, S, F>(this.validator, validationData, additionalErrorSchema);\n  }\n\n  /** Retrieves an expanded schema that has had all of its conditions, additional properties, references and\n   * dependencies resolved and merged into the `schema` given a `rawFormData` that is used to do the potentially\n   * recursive resolution.\n   *\n   * @param schema - The schema for which retrieving a schema is desired\n   * @param [rawFormData] - The current formData, if any, to assist retrieving a schema\n   * @returns - The schema having its conditions, additional properties, references and dependencies resolved\n   */\n  retrieveSchema(schema: S, rawFormData?: T) {\n    return retrieveSchema<T, S, F>(this.validator, schema, this.rootSchema, rawFormData);\n  }\n\n  /** Sanitize the `data` associated with the `oldSchema` so it is considered appropriate for the `newSchema`. If the\n   * new schema does not contain any properties, then `undefined` is returned to clear all the form data. Due to the\n   * nature of schemas, this sanitization happens recursively for nested objects of data. Also, any properties in the\n   * old schemas that are non-existent in the new schema are set to `undefined`.\n   *\n   * @param [newSchema] - The new schema for which the data is being sanitized\n   * @param [oldSchema] - The old schema from which the data originated\n   * @param [data={}] - The form data associated with the schema, defaulting to an empty object when undefined\n   * @returns - The new form data, with all the fields uniquely associated with the old schema set\n   *      to `undefined`. Will return `undefined` if the new schema is not an object containing properties.\n   */\n  sanitizeDataForNewSchema(newSchema?: S, oldSchema?: S, data?: any): T {\n    return sanitizeDataForNewSchema(this.validator, this.rootSchema, newSchema, oldSchema, data);\n  }\n\n  /** Generates an `IdSchema` object for the `schema`, recursively\n   *\n   * @param schema - The schema for which the display label flag is desired\n   * @param [id] - The base id for the schema\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\n   * @param [idPrefix='root'] - The prefix to use for the id\n   * @param [idSeparator='_'] - The separator to use for the path segments in the id\n   * @returns - The `IdSchema` object for the `schema`\n   */\n  toIdSchema(schema: S, id?: string | null, formData?: T, idPrefix = 'root', idSeparator = '_'): IdSchema<T> {\n    return toIdSchema<T, S, F>(this.validator, schema, id, this.rootSchema, formData, idPrefix, idSeparator);\n  }\n\n  /** Generates an `PathSchema` object for the `schema`, recursively\n   *\n   * @param schema - The schema for which the display label flag is desired\n   * @param [name] - The base name for the schema\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\n   * @returns - The `PathSchema` object for the `schema`\n   */\n  toPathSchema(schema: S, name?: string, formData?: T): PathSchema<T> {\n    return toPathSchema<T, S, F>(this.validator, schema, name, this.rootSchema, formData);\n  }\n}\n\n/** Creates a `SchemaUtilsType` interface that is based around the given `validator` and `rootSchema` parameters. The\n * resulting interface implementation will forward the `validator` and `rootSchema` to all the wrapped APIs.\n *\n * @param validator - an implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @returns - An implementation of a `SchemaUtilsType` interface\n */\nexport default function createSchemaUtils<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S, F>, rootSchema: S): SchemaUtilsType<T, S, F> {\n  return new SchemaUtils<T, S, F>(validator, rootSchema);\n}\n","/** Given the `FileReader.readAsDataURL()` based `dataURI` extracts that data into an actual Blob along with the name\n * of that Blob if provided in the URL. If no name is provided, then the name falls back to `unknown`.\n *\n * @param dataURI - The `DataUrl` potentially containing name and raw data to be converted to a Blob\n * @returns - an object containing a Blob and its name, extracted from the URI\n */\nexport default function dataURItoBlob(dataURI: string) {\n  // Split metadata from data\n  const splitted: string[] = dataURI.split(',');\n  // Split params\n  const params: string[] = splitted[0].split(';');\n  // Get mime-type from params\n  const type: string = params[0].replace('data:', '');\n  // Filter the name property from params\n  const properties = params.filter((param) => {\n    return param.split('=')[0] === 'name';\n  });\n  // Look for the name and use unknown if no name property.\n  let name: string;\n  if (properties.length !== 1) {\n    name = 'unknown';\n  } else {\n    // Because we filtered out the other property,\n    // we only have the name case here, which we decode to make it human-readable\n    name = decodeURI(properties[0].split('=')[1]);\n  }\n\n  // Built the Uint8Array Blob parameter from the base64 string.\n  try {\n    const binary = atob(splitted[1]);\n    const array = [];\n    for (let i = 0; i < binary.length; i++) {\n      array.push(binary.charCodeAt(i));\n    }\n    // Create the blob object\n    const blob = new window.Blob([new Uint8Array(array)], { type });\n\n    return { blob, name };\n  } catch (error) {\n    return { blob: { size: 0, type: (error as Error).message }, name: dataURI };\n  }\n}\n","/** Potentially substitutes all replaceable parameters with the associated value(s) from the `params` if available. When\n * a `params` array is provided, each value in the array is used to replace any of the replaceable parameters in the\n * `inputString` using the `%1`, `%2`, etc. replacement specifiers.\n *\n * @param inputString - The string which will be potentially updated with replacement parameters\n * @param params - The optional list of replaceable parameter values to substitute into the english string\n * @returns - The updated string with any replacement specifiers replaced\n */\nexport default function replaceStringParameters(inputString: string, params?: string[]) {\n  let output = inputString;\n  if (Array.isArray(params)) {\n    const parts = output.split(/(%\\d)/);\n    params.forEach((param, index) => {\n      const partIndex = parts.findIndex((part) => part === `%${index + 1}`);\n      if (partIndex >= 0) {\n        parts[partIndex] = param;\n      }\n    });\n    output = parts.join('');\n  }\n  return output;\n}\n","import { TranslatableString } from './enums';\nimport replaceStringParameters from './replaceStringParameters';\n\n/** Translates a `TranslatableString` value `stringToTranslate` into english. When a `params` array is provided, each\n * value in the array is used to replace any of the replaceable parameters in the `stringToTranslate` using the `%1`,\n * `%2`, etc. replacement specifiers.\n *\n * @param stringToTranslate - The `TranslatableString` value to convert to english\n * @param params - The optional list of replaceable parameter values to substitute into the english string\n * @returns - The `stringToTranslate` itself with any replaceable parameter values substituted\n */\nexport default function englishStringTranslator(stringToTranslate: TranslatableString, params?: string[]): string {\n  return replaceStringParameters(stringToTranslate, params);\n}\n","import { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Returns the value(s) from `allEnumOptions` at the index(es) provided by `valueIndex`. If `valueIndex` is not an\n * array AND the index is not valid for `allEnumOptions`, `emptyValue` is returned. If `valueIndex` is an array, AND it\n * contains an invalid index, the returned array will have the resulting undefined values filtered out, leaving only\n * valid values or in the worst case, an empty array.\n *\n * @param valueIndex - The index(es) of the value(s) that should be returned\n * @param [allEnumOptions=[]] - The list of all the known enumOptions\n * @param [emptyValue] - The value to return when the non-array `valueIndex` does not refer to a real option\n * @returns - The single or list of values specified by the single or list of indexes if they are valid. Otherwise,\n *        `emptyValue` or an empty list.\n */\nexport default function enumOptionsValueForIndex<S extends StrictRJSFSchema = RJSFSchema>(\n  valueIndex: string | number | Array<string | number>,\n  allEnumOptions: EnumOptionsType<S>[] = [],\n  emptyValue?: EnumOptionsType<S>['value']\n): EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][] | undefined {\n  if (Array.isArray(valueIndex)) {\n    return valueIndex.map((index) => enumOptionsValueForIndex(index, allEnumOptions)).filter((val) => val);\n  }\n  // So Number(null) and Number('') both return 0, so use emptyValue for those two values\n  const index = valueIndex === '' || valueIndex === null ? -1 : Number(valueIndex);\n  const option = allEnumOptions[index];\n  return option ? option.value : emptyValue;\n}\n","import isEqual from 'lodash/isEqual';\n\nimport { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\nimport enumOptionsValueForIndex from './enumOptionsValueForIndex';\n\n/** Removes the enum option value at the `valueIndex` from the currently `selected` (list of) value(s). If `selected` is\n * a list, then that list is updated to remove the enum option value with the `valueIndex` in `allEnumOptions`. If it is\n * a single value, then if the enum option value with the `valueIndex` in `allEnumOptions` matches `selected`, undefined\n * is returned, otherwise the `selected` value is returned.\n *\n * @param valueIndex - The index of the value to be removed from the selected list or single value\n * @param selected - The current (list of) selected value(s)\n * @param [allEnumOptions=[]] - The list of all the known enumOptions\n * @returns - The updated `selected` with the enum option value at `valueIndex` in `allEnumOptions` removed from it,\n *        unless `selected` is a single value. In that case, if the `valueIndex` value matches `selected`, returns\n *        undefined, otherwise `selected`.\n */\nexport default function enumOptionsDeselectValue<S extends StrictRJSFSchema = RJSFSchema>(\n  valueIndex: string | number,\n  selected?: EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][],\n  allEnumOptions: EnumOptionsType<S>[] = []\n): EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][] | undefined {\n  const value = enumOptionsValueForIndex<S>(valueIndex, allEnumOptions);\n  if (Array.isArray(selected)) {\n    return selected.filter((v) => !isEqual(v, value));\n  }\n  return isEqual(value, selected) ? undefined : selected;\n}\n","import isEqual from 'lodash/isEqual';\n\nimport { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Determines whether the given `value` is (one of) the `selected` value(s).\n *\n * @param value - The value being checked to see if it is selected\n * @param selected - The current selected value or list of values\n * @returns - true if the `value` is one of the `selected` ones, false otherwise\n */\nexport default function enumOptionsIsSelected<S extends StrictRJSFSchema = RJSFSchema>(\n  value: EnumOptionsType<S>['value'],\n  selected: EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][]\n) {\n  if (Array.isArray(selected)) {\n    return selected.some((sel) => isEqual(sel, value));\n  }\n  return isEqual(selected, value);\n}\n","import { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\nimport enumOptionsIsSelected from './enumOptionsIsSelected';\n\n/** Returns the index(es) of the options in `allEnumOptions` whose value(s) match the ones in `value`. All the\n * `enumOptions` are filtered based on whether they are a \"selected\" `value` and the index of each selected one is then\n * stored in an array. If `multiple` is true, that array is returned, otherwise the first element in the array is\n * returned.\n *\n * @param value - The single value or list of values for which indexes are desired\n * @param [allEnumOptions=[]] - The list of all the known enumOptions\n * @param [multiple=false] - Optional flag, if true will return a list of index, otherwise a single one\n * @returns - A single string index for the first `value` in `allEnumOptions`, if not `multiple`. Otherwise, the list\n *        of indexes for (each of) the value(s) in `value`.\n */\nexport default function enumOptionsIndexForValue<S extends StrictRJSFSchema = RJSFSchema>(\n  value: EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][],\n  allEnumOptions: EnumOptionsType<S>[] = [],\n  multiple = false\n): string | string[] | undefined {\n  const selectedIndexes: string[] = allEnumOptions\n    .map((opt, index) => (enumOptionsIsSelected(opt.value, value) ? String(index) : undefined))\n    .filter((opt) => typeof opt !== 'undefined') as string[];\n  if (!multiple) {\n    return selectedIndexes[0];\n  }\n  return selectedIndexes;\n}\n","import { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\nimport enumOptionsValueForIndex from './enumOptionsValueForIndex';\n\n/** Add the enum option value at the `valueIndex` to the list of `selected` values in the proper order as defined by\n * `allEnumOptions`\n *\n * @param valueIndex - The index of the value that should be selected\n * @param selected - The current list of selected values\n * @param [allEnumOptions=[]] - The list of all the known enumOptions\n * @returns - The updated list of selected enum values with enum value at the `valueIndex` added to it\n */\nexport default function enumOptionsSelectValue<S extends StrictRJSFSchema = RJSFSchema>(\n  valueIndex: string | number,\n  selected: EnumOptionsType<S>['value'][],\n  allEnumOptions: EnumOptionsType<S>[] = []\n) {\n  const value = enumOptionsValueForIndex<S>(valueIndex, allEnumOptions);\n  if (value) {\n    const index = allEnumOptions.findIndex((opt) => value === opt.value);\n    const all = allEnumOptions.map(({ value: val }) => val);\n    const updated = selected.slice(0, index).concat(value, selected.slice(index));\n    // As inserting values at predefined index positions doesn't work with empty\n    // arrays, we need to reorder the updated selection to match the initial order\n    return updated.sort((a, b) => Number(all.indexOf(a) > all.indexOf(b)));\n  }\n  return selected;\n}\n","import cloneDeep from 'lodash/cloneDeep';\nimport get from 'lodash/get';\nimport set from 'lodash/set';\n\nimport { ErrorSchema } from './types';\nimport { ERRORS_KEY } from './constants';\n\n/** The `ErrorSchemaBuilder<T>` is used to build an `ErrorSchema<T>` since the definition of the `ErrorSchema` type is\n * designed for reading information rather than writing it. Use this class to add, replace or clear errors in an error\n * schema by using either dotted path or an array of path names. Once you are done building the `ErrorSchema`, you can\n * get the result and/or reset all the errors back to an initial set and start again.\n */\nexport default class ErrorSchemaBuilder<T = any> {\n  /** The error schema being built\n   *\n   * @private\n   */\n  private errorSchema: ErrorSchema<T> = {};\n\n  /** Construct an `ErrorSchemaBuilder` with an optional initial set of errors in an `ErrorSchema`.\n   *\n   * @param [initialSchema] - The optional set of initial errors, that will be cloned into the class\n   */\n  constructor(initialSchema?: ErrorSchema<T>) {\n    this.resetAllErrors(initialSchema);\n  }\n\n  /** Returns the `ErrorSchema` that has been updated by the methods of the `ErrorSchemaBuilder`\n   */\n  get ErrorSchema() {\n    return this.errorSchema;\n  }\n\n  /** Will get an existing `ErrorSchema` at the specified `pathOfError` or create and return one.\n   *\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to add the error(s)\n   * @returns - The error block for the given `pathOfError` or the root if not provided\n   * @private\n   */\n  private getOrCreateErrorBlock(pathOfError?: string | string[]) {\n    const hasPath = (Array.isArray(pathOfError) && pathOfError.length > 0) || typeof pathOfError === 'string';\n    let errorBlock: ErrorSchema = hasPath ? get(this.errorSchema, pathOfError) : this.errorSchema;\n    if (!errorBlock && pathOfError) {\n      errorBlock = {};\n      set(this.errorSchema, pathOfError, errorBlock);\n    }\n    return errorBlock;\n  }\n\n  /** Resets all errors in the `ErrorSchemaBuilder` back to the `initialSchema` if provided, otherwise an empty set.\n   *\n   * @param [initialSchema] - The optional set of initial errors, that will be cloned into the class\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\n   */\n  resetAllErrors(initialSchema?: ErrorSchema<T>) {\n    this.errorSchema = initialSchema ? cloneDeep(initialSchema) : {};\n    return this;\n  }\n\n  /** Adds the `errorOrList` to the list of errors in the `ErrorSchema` at either the root level or the location within\n   * the schema described by the `pathOfError`. For more information about how to specify the path see the\n   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).\n   *\n   * @param errorOrList - The error or list of errors to add into the `ErrorSchema`\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to add the error(s)\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\n   */\n  addErrors(errorOrList: string | string[], pathOfError?: string | string[]) {\n    const errorBlock: ErrorSchema = this.getOrCreateErrorBlock(pathOfError);\n    let errorsList = get(errorBlock, ERRORS_KEY);\n    if (!Array.isArray(errorsList)) {\n      errorsList = [];\n      errorBlock[ERRORS_KEY] = errorsList;\n    }\n\n    if (Array.isArray(errorOrList)) {\n      errorsList.push(...errorOrList);\n    } else {\n      errorsList.push(errorOrList);\n    }\n    return this;\n  }\n\n  /** Sets/replaces the `errorOrList` as the error(s) in the `ErrorSchema` at either the root level or the location\n   * within the schema described by the `pathOfError`. For more information about how to specify the path see the\n   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).\n   *\n   * @param errorOrList - The error or list of errors to set into the `ErrorSchema`\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to set the error(s)\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\n   */\n  setErrors(errorOrList: string | string[], pathOfError?: string | string[]) {\n    const errorBlock: ErrorSchema = this.getOrCreateErrorBlock(pathOfError);\n    // Effectively clone the array being given to prevent accidental outside manipulation of the given list\n    const listToAdd = Array.isArray(errorOrList) ? [...errorOrList] : [errorOrList];\n    set(errorBlock, ERRORS_KEY, listToAdd);\n    return this;\n  }\n\n  /** Clears the error(s) in the `ErrorSchema` at either the root level or the location within the schema described by\n   * the `pathOfError`. For more information about how to specify the path see the\n   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).\n   *\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to clear the error(s)\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\n   */\n  clearErrors(pathOfError?: string | string[]) {\n    const errorBlock: ErrorSchema = this.getOrCreateErrorBlock(pathOfError);\n    set(errorBlock, ERRORS_KEY, []);\n    return this;\n  }\n}\n","import { RangeSpecType, StrictRJSFSchema } from './types';\nimport { RJSFSchema } from './types';\n\n/** Extracts the range spec information `{ step?: number, min?: number, max?: number }` that can be spread onto an HTML\n * input from the range analog in the schema `{ multipleOf?: number, minimum?: number, maximum?: number }`.\n *\n * @param schema - The schema from which to extract the range spec\n * @returns - A range specification from the schema\n */\nexport default function rangeSpec<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\n  const spec: RangeSpecType = {};\n  if (schema.multipleOf) {\n    spec.step = schema.multipleOf;\n  }\n  if (schema.minimum || schema.minimum === 0) {\n    spec.min = schema.minimum;\n  }\n  if (schema.maximum || schema.maximum === 0) {\n    spec.max = schema.maximum;\n  }\n  return spec;\n}\n","import rangeSpec from './rangeSpec';\nimport { FormContextType, InputPropsType, RJSFSchema, StrictRJSFSchema, UIOptionsType } from './types';\n\n/** Using the `schema`, `defaultType` and `options`, extract out the props for the <input> element that make sense.\n *\n * @param schema - The schema for the field provided by the widget\n * @param [defaultType] - The default type, if any, for the field provided by the widget\n * @param [options={}] - The UI Options for the field provided by the widget\n * @param [autoDefaultStepAny=true] - Determines whether to auto-default step=any when the type is number and no step\n * @returns - The extracted `InputPropsType` object\n */\nexport default function getInputProps<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  schema: RJSFSchema,\n  defaultType?: string,\n  options: UIOptionsType<T, S, F> = {},\n  autoDefaultStepAny = true\n): InputPropsType {\n  const inputProps: InputPropsType = {\n    type: defaultType || 'text',\n    ...rangeSpec(schema),\n  };\n\n  // If options.inputType is set use that as the input type\n  if (options.inputType) {\n    inputProps.type = options.inputType;\n  } else if (!defaultType) {\n    // If the schema is of type number or integer, set the input type to number\n    if (schema.type === 'number') {\n      inputProps.type = 'number';\n      // Only add step if one isn't already defined and we are auto-defaulting the \"any\" step\n      if (autoDefaultStepAny && inputProps.step === undefined) {\n        // Setting step to 'any' fixes a bug in Safari where decimals are not\n        // allowed in number inputs\n        inputProps.step = 'any';\n      }\n    } else if (schema.type === 'integer') {\n      inputProps.type = 'number';\n      // Only add step if one isn't already defined\n      if (inputProps.step === undefined) {\n        // Since this is integer, you always want to step up or down in multiples of 1\n        inputProps.step = 1;\n      }\n    }\n  }\n\n  if (options.autocomplete) {\n    inputProps.autoComplete = options.autocomplete;\n  }\n\n  return inputProps;\n}\n","import { SUBMIT_BTN_OPTIONS_KEY } from './constants';\nimport getUiOptions from './getUiOptions';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, UiSchema, UISchemaSubmitButtonOptions } from './types';\n\n/** The default submit button options, exported for testing purposes\n */\nexport const DEFAULT_OPTIONS: UISchemaSubmitButtonOptions = {\n  props: {\n    disabled: false,\n  },\n  submitText: 'Submit',\n  norender: false,\n};\n\n/** Extracts any `ui:submitButtonOptions` from the `uiSchema` and merges them onto the `DEFAULT_OPTIONS`\n *\n * @param [uiSchema={}] - the UI Schema from which to extract submit button props\n * @returns - The merging of the `DEFAULT_OPTIONS` with any custom ones\n */\nexport default function getSubmitButtonOptions<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(uiSchema: UiSchema<T, S, F> = {}): UISchemaSubmitButtonOptions {\n  const uiOptions = getUiOptions<T, S, F>(uiSchema);\n  if (uiOptions && uiOptions[SUBMIT_BTN_OPTIONS_KEY]) {\n    const options = uiOptions[SUBMIT_BTN_OPTIONS_KEY] as UISchemaSubmitButtonOptions;\n    return { ...DEFAULT_OPTIONS, ...options };\n  }\n\n  return DEFAULT_OPTIONS;\n}\n","import { FormContextType, TemplatesType, Registry, UIOptionsType, StrictRJSFSchema, RJSFSchema } from './types';\n\n/** Returns the template with the given `name` from either the `uiSchema` if it is defined or from the `registry`\n * otherwise. NOTE, since `ButtonTemplates` are not overridden in `uiSchema` only those in the `registry` are returned.\n *\n * @param name - The name of the template to fetch, restricted to the keys of `TemplatesType`\n * @param registry - The `Registry` from which to read the template\n * @param [uiOptions={}] - The `UIOptionsType` from which to read an alternate template\n * @returns - The template from either the `uiSchema` or `registry` for the `name`\n */\nexport default function getTemplate<\n  Name extends keyof TemplatesType<T, S, F>,\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(name: Name, registry: Registry<T, S, F>, uiOptions: UIOptionsType<T, S, F> = {}): TemplatesType<T, S, F>[Name] {\n  const { templates } = registry;\n  if (name === 'ButtonTemplates') {\n    return templates[name];\n  }\n  return (\n    // Evaluating uiOptions[name] results in TS2590: Expression produces a union type that is too complex to represent\n    // To avoid that, we cast uiOptions to `any` before accessing the name field\n    ((uiOptions as any)[name] as TemplatesType<T, S, F>[Name]) || templates[name]\n  );\n}\n","import { createElement } from 'react';\nimport ReactIs from 'react-is';\nimport get from 'lodash/get';\nimport set from 'lodash/set';\n\nimport { FormContextType, RJSFSchema, Widget, RegistryWidgetsType, StrictRJSFSchema } from './types';\nimport getSchemaType from './getSchemaType';\n\n/** The map of schema types to widget type to widget name\n */\nconst widgetMap: { [k: string]: { [j: string]: string } } = {\n  boolean: {\n    checkbox: 'CheckboxWidget',\n    radio: 'RadioWidget',\n    select: 'SelectWidget',\n    hidden: 'HiddenWidget',\n  },\n  string: {\n    text: 'TextWidget',\n    password: 'PasswordWidget',\n    email: 'EmailWidget',\n    hostname: 'TextWidget',\n    ipv4: 'TextWidget',\n    ipv6: 'TextWidget',\n    uri: 'URLWidget',\n    'data-url': 'FileWidget',\n    radio: 'RadioWidget',\n    select: 'SelectWidget',\n    textarea: 'TextareaWidget',\n    hidden: 'HiddenWidget',\n    date: 'DateWidget',\n    datetime: 'DateTimeWidget',\n    'date-time': 'DateTimeWidget',\n    'alt-date': 'AltDateWidget',\n    'alt-datetime': 'AltDateTimeWidget',\n    time: 'TimeWidget',\n    color: 'ColorWidget',\n    file: 'FileWidget',\n  },\n  number: {\n    text: 'TextWidget',\n    select: 'SelectWidget',\n    updown: 'UpDownWidget',\n    range: 'RangeWidget',\n    radio: 'RadioWidget',\n    hidden: 'HiddenWidget',\n  },\n  integer: {\n    text: 'TextWidget',\n    select: 'SelectWidget',\n    updown: 'UpDownWidget',\n    range: 'RangeWidget',\n    radio: 'RadioWidget',\n    hidden: 'HiddenWidget',\n  },\n  array: {\n    select: 'SelectWidget',\n    checkboxes: 'CheckboxesWidget',\n    files: 'FileWidget',\n    hidden: 'HiddenWidget',\n  },\n};\n\n/** Wraps the given widget with stateless functional component that will merge any `defaultProps.options` with the\n * `options` that are provided in the props. It will add the wrapper component as a `MergedWidget` property onto the\n * `Widget` so that future attempts to wrap `AWidget` will return the already existing wrapper.\n *\n * @param AWidget - A widget that will be wrapped or one that is already wrapped\n * @returns - The wrapper widget\n */\nfunction mergeWidgetOptions<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  AWidget: Widget<T, S, F>\n) {\n  let MergedWidget: Widget<T, S, F> | undefined = get(AWidget, 'MergedWidget');\n  // cache return value as property of widget for proper react reconciliation\n  if (!MergedWidget) {\n    const defaultOptions = (AWidget.defaultProps && AWidget.defaultProps.options) || {};\n    MergedWidget = ({ options, ...props }) => {\n      return <AWidget options={{ ...defaultOptions, ...options }} {...props} />;\n    };\n    set(AWidget, 'MergedWidget', MergedWidget);\n  }\n  return MergedWidget;\n}\n\n/** Given a schema representing a field to render and either the name or actual `Widget` implementation, returns the\n * React component that is used to render the widget. If the `widget` is already a React component, then it is wrapped\n * with a `MergedWidget`. Otherwise an attempt is made to look up the widget inside of the `registeredWidgets` map based\n * on the schema type and `widget` name. If no widget component can be found an `Error` is thrown.\n *\n * @param schema - The schema for the field\n * @param [widget] - Either the name of the widget OR a `Widget` implementation to use\n * @param [registeredWidgets={}] - A registry of widget name to `Widget` implementation\n * @returns - The `Widget` component to use\n * @throws - An error if there is no `Widget` component that can be returned\n */\nexport default function getWidget<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  schema: RJSFSchema,\n  widget?: Widget<T, S, F> | string,\n  registeredWidgets: RegistryWidgetsType<T, S, F> = {}\n): Widget<T, S, F> {\n  const type = getSchemaType(schema);\n\n  if (\n    typeof widget === 'function' ||\n    (widget && ReactIs.isForwardRef(createElement(widget))) ||\n    ReactIs.isMemo(widget)\n  ) {\n    return mergeWidgetOptions<T, S, F>(widget as Widget<T, S, F>);\n  }\n\n  if (typeof widget !== 'string') {\n    throw new Error(`Unsupported widget definition: ${typeof widget}`);\n  }\n\n  if (widget in registeredWidgets) {\n    const registeredWidget = registeredWidgets[widget];\n    return getWidget<T, S, F>(schema, registeredWidget, registeredWidgets);\n  }\n\n  if (typeof type === 'string') {\n    if (!(type in widgetMap)) {\n      throw new Error(`No widget for type '${type}'`);\n    }\n\n    if (widget in widgetMap[type]) {\n      const registeredWidget = registeredWidgets[widgetMap[type][widget]];\n      return getWidget<T, S, F>(schema, registeredWidget, registeredWidgets);\n    }\n  }\n\n  throw new Error(`No widget '${widget}' for type '${type}'`);\n}\n","import getWidget from './getWidget';\nimport { FormContextType, RegistryWidgetsType, RJSFSchema, StrictRJSFSchema, Widget } from './types';\n\n/** Detects whether the `widget` exists for the `schema` with the associated `registryWidgets` and returns true if it\n * does, or false if it doesn't.\n *\n * @param schema - The schema for the field\n * @param widget - Either the name of the widget OR a `Widget` implementation to use\n * @param [registeredWidgets={}] - A registry of widget name to `Widget` implementation\n * @returns - True if the widget exists, false otherwise\n */\nexport default function hasWidget<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  schema: RJSFSchema,\n  widget: Widget<T, S, F> | string,\n  registeredWidgets: RegistryWidgetsType<T, S, F> = {}\n) {\n  try {\n    getWidget(schema, widget, registeredWidgets);\n    return true;\n  } catch (e) {\n    const err: Error = e as Error;\n    if (err.message && (err.message.startsWith('No widget') || err.message.startsWith('Unsupported widget'))) {\n      return false;\n    }\n    throw e;\n  }\n}\n","import isString from 'lodash/isString';\n\nimport { IdSchema } from './types';\nimport { ID_KEY } from './constants';\n\n/** Generates a consistent `id` pattern for a given `id` and a `suffix`\n *\n * @param id - Either simple string id or an IdSchema from which to extract it\n * @param suffix - The suffix to append to the id\n */\nfunction idGenerator<T = any>(id: IdSchema<T> | string, suffix: string) {\n  const theId = isString(id) ? id : id[ID_KEY];\n  return `${theId}__${suffix}`;\n}\n/** Return a consistent `id` for the field description element\n *\n * @param id - Either simple string id or an IdSchema from which to extract it\n * @returns - The consistent id for the field description element from the given `id`\n */\nexport function descriptionId<T = any>(id: IdSchema<T> | string) {\n  return idGenerator<T>(id, 'description');\n}\n\n/** Return a consistent `id` for the field error element\n *\n * @param id - Either simple string id or an IdSchema from which to extract it\n * @returns - The consistent id for the field error element from the given `id`\n */\nexport function errorId<T = any>(id: IdSchema<T> | string) {\n  return idGenerator<T>(id, 'error');\n}\n\n/** Return a consistent `id` for the field examples element\n *\n * @param id - Either simple string id or an IdSchema from which to extract it\n * @returns - The consistent id for the field examples element from the given `id`\n */\nexport function examplesId<T = any>(id: IdSchema<T> | string) {\n  return idGenerator<T>(id, 'examples');\n}\n\n/** Return a consistent `id` for the field help element\n *\n * @param id - Either simple string id or an IdSchema from which to extract it\n * @returns - The consistent id for the field help element from the given `id`\n */\nexport function helpId<T = any>(id: IdSchema<T> | string) {\n  return idGenerator<T>(id, 'help');\n}\n\n/** Return a consistent `id` for the field title element\n *\n * @param id - Either simple string id or an IdSchema from which to extract it\n * @returns - The consistent id for the field title element from the given `id`\n */\nexport function titleId<T = any>(id: IdSchema<T> | string) {\n  return idGenerator<T>(id, 'title');\n}\n\n/** Return a list of element ids that contain additional information about the field that can be used to as the aria\n * description of the field. This is correctly omitting `titleId` which would be \"labeling\" rather than \"describing\" the\n * element.\n *\n * @param id - Either simple string id or an IdSchema from which to extract it\n * @param [includeExamples=false] - Optional flag, if true, will add the `examplesId` into the list\n * @returns - The string containing the list of ids for use in an `aria-describedBy` attribute\n */\nexport function ariaDescribedByIds<T = any>(id: IdSchema<T> | string, includeExamples = false) {\n  const examples = includeExamples ? ` ${examplesId<T>(id)}` : '';\n  return `${errorId<T>(id)} ${descriptionId<T>(id)} ${helpId<T>(id)}${examples}`;\n}\n\n/** Return a consistent `id` for the `optionIndex`s of a `Radio` or `Checkboxes` widget\n *\n * @param id - The id of the parent component for the option\n * @param optionIndex - The index of the option for which the id is desired\n * @returns - An id for the option index based on the parent `id`\n */\nexport function optionId(id: string, optionIndex: number) {\n  return `${id}-${optionIndex}`;\n}\n","/** Converts a local Date string into a UTC date string\n *\n * @param dateString - The string representation of a date as accepted by the `Date()` constructor\n * @returns - A UTC date string if `dateString` is truthy, otherwise undefined\n */\nexport default function localToUTC(dateString: string) {\n  return dateString ? new Date(dateString).toJSON() : undefined;\n}\n","import { CONST_KEY, ENUM_KEY } from './constants';\nimport { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Returns the constant value from the schema when it is either a single value enum or has a const key. Otherwise\n * throws an error.\n *\n * @param schema - The schema from which to obtain the constant value\n * @returns - The constant value for the schema\n * @throws - Error when the schema does not have a constant value\n */\nexport default function toConstant<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\n  if (ENUM_KEY in schema && Array.isArray(schema.enum) && schema.enum.length === 1) {\n    return schema.enum[0];\n  }\n  if (CONST_KEY in schema) {\n    return schema.const;\n  }\n  throw new Error('schema cannot be inferred as a constant');\n}\n","import toConstant from './toConstant';\nimport { RJSFSchema, EnumOptionsType, StrictRJSFSchema } from './types';\n\n/** Gets the list of options from the schema. If the schema has an enum list, then those enum values are returned. The\n * labels for the options will be extracted from the non-standard, RJSF-deprecated `enumNames` if it exists, otherwise\n * the label will be the same as the `value`. If the schema has a `oneOf` or `anyOf`, then the value is the list of\n * `const` values from the schema and the label is either the `schema.title` or the value.\n *\n * @param schema - The schema from which to extract the options list\n * @returns - The list of options from the schema\n */\nexport default function optionsList<S extends StrictRJSFSchema = RJSFSchema>(\n  schema: S\n): EnumOptionsType<S>[] | undefined {\n  // enumNames was deprecated in v5 and is intentionally omitted from the RJSFSchema type.\n  // Cast the type to include enumNames so the feature still works.\n  const schemaWithEnumNames = schema as S & { enumNames?: string[] };\n  if (schemaWithEnumNames.enumNames && process.env.NODE_ENV !== 'production') {\n    console.warn('The enumNames property is deprecated and may be removed in a future major release.');\n  }\n  if (schema.enum) {\n    return schema.enum.map((value, i) => {\n      const label = (schemaWithEnumNames.enumNames && schemaWithEnumNames.enumNames[i]) || String(value);\n      return { label, value };\n    });\n  }\n  const altSchemas = schema.oneOf || schema.anyOf;\n  return (\n    altSchemas &&\n    altSchemas.map((aSchemaDef) => {\n      const aSchema = aSchemaDef as S;\n      const value = toConstant(aSchema);\n      const label = aSchema.title || String(value);\n      return {\n        schema: aSchema,\n        label,\n        value,\n      };\n    })\n  );\n}\n","import { GenericObjectType } from './types';\n\n/** Given a list of `properties` and an `order` list, returns a list that contains the `properties` ordered correctly.\n * If `order` is not an array, then the untouched `properties` list is returned. Otherwise `properties` is ordered per\n * the `order` list. If `order` contains a '*' then any `properties` that are not mentioned explicity in `order` will be\n * places in the location of the `*`.\n *\n * @param properties - The list of property keys to be ordered\n * @param order - An array of property keys to be ordered first, with an optional '*' property\n * @returns - A list with the `properties` ordered\n * @throws - Error when the properties cannot be ordered correctly\n */\nexport default function orderProperties(properties: string[], order?: string[]): string[] {\n  if (!Array.isArray(order)) {\n    return properties;\n  }\n\n  const arrayToHash = (arr: string[]) =>\n    arr.reduce((prev: GenericObjectType, curr) => {\n      prev[curr] = true;\n      return prev;\n    }, {});\n  const errorPropList = (arr: string[]) =>\n    arr.length > 1 ? `properties '${arr.join(\"', '\")}'` : `property '${arr[0]}'`;\n  const propertyHash = arrayToHash(properties);\n  const orderFiltered = order.filter((prop) => prop === '*' || propertyHash[prop]);\n  const orderHash = arrayToHash(orderFiltered);\n\n  const rest = properties.filter((prop: string) => !orderHash[prop]);\n  const restIndex = orderFiltered.indexOf('*');\n  if (restIndex === -1) {\n    if (rest.length) {\n      throw new Error(`uiSchema order list does not contain ${errorPropList(rest)}`);\n    }\n    return orderFiltered;\n  }\n  if (restIndex !== orderFiltered.lastIndexOf('*')) {\n    throw new Error('uiSchema order list contains more than one wildcard item');\n  }\n\n  const complete = [...orderFiltered];\n  complete.splice(restIndex, 1, ...rest);\n  return complete;\n}\n","/** Returns a string representation of the `num` that is padded with leading \"0\"s if necessary\n *\n * @param num - The number to pad\n * @param width - The width of the string at which no lead padding is necessary\n * @returns - The number converted to a string with leading zero padding if the number of digits is less than `width`\n */\nexport default function pad(num: number, width: number) {\n  let s = String(num);\n  while (s.length < width) {\n    s = '0' + s;\n  }\n  return s;\n}\n","import { DateObject } from './types';\n\n/** Parses the `dateString` into a `DateObject`, including the time information when `includeTime` is true\n *\n * @param dateString - The date string to parse into a DateObject\n * @param [includeTime=true] - Optional flag, if false, will not include the time data into the object\n * @returns - The date string converted to a `DateObject`\n * @throws - Error when the date cannot be parsed from the string\n */\nexport default function parseDateString(dateString?: string, includeTime = true): DateObject {\n  if (!dateString) {\n    return {\n      year: -1,\n      month: -1,\n      day: -1,\n      hour: includeTime ? -1 : 0,\n      minute: includeTime ? -1 : 0,\n      second: includeTime ? -1 : 0,\n    };\n  }\n  const date = new Date(dateString);\n  if (Number.isNaN(date.getTime())) {\n    throw new Error('Unable to parse date ' + dateString);\n  }\n  return {\n    year: date.getUTCFullYear(),\n    month: date.getUTCMonth() + 1, // oh you, javascript.\n    day: date.getUTCDate(),\n    hour: includeTime ? date.getUTCHours() : 0,\n    minute: includeTime ? date.getUTCMinutes() : 0,\n    second: includeTime ? date.getUTCSeconds() : 0,\n  };\n}\n","import { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Check to see if a `schema` specifies that a value must be true. This happens when:\n * - `schema.const` is truthy\n * - `schema.enum` == `[true]`\n * - `schema.anyOf` or `schema.oneOf` has a single value which recursively returns true\n * - `schema.allOf` has at least one value which recursively returns true\n *\n * @param schema - The schema to check\n * @returns - True if the schema specifies a value that must be true, false otherwise\n */\nexport default function schemaRequiresTrueValue<S extends StrictRJSFSchema = RJSFSchema>(schema: S): boolean {\n  // Check if const is a truthy value\n  if (schema.const) {\n    return true;\n  }\n\n  // Check if an enum has a single value of true\n  if (schema.enum && schema.enum.length === 1 && schema.enum[0] === true) {\n    return true;\n  }\n\n  // If anyOf has a single value, evaluate the subschema\n  if (schema.anyOf && schema.anyOf.length === 1) {\n    return schemaRequiresTrueValue(schema.anyOf[0] as S);\n  }\n\n  // If oneOf has a single value, evaluate the subschema\n  if (schema.oneOf && schema.oneOf.length === 1) {\n    return schemaRequiresTrueValue(schema.oneOf[0] as S);\n  }\n\n  // Evaluate each subschema in allOf, to see if one of them requires a true value\n  if (schema.allOf) {\n    const schemaSome = (subSchema: S['additionalProperties']) => schemaRequiresTrueValue(subSchema as S);\n    return schema.allOf.some(schemaSome);\n  }\n\n  return false;\n}\n","import React from 'react';\n\nimport deepEquals from './deepEquals';\n\n/** Determines whether the given `component` should be rerendered by comparing its current set of props and state\n * against the next set. If either of those two sets are not the same, then the component should be rerendered.\n *\n * @param component - A React component being checked\n * @param nextProps - The next set of props against which to check\n * @param nextState - The next set of state against which to check\n * @returns - True if the component should be re-rendered, false otherwise\n */\nexport default function shouldRender(component: React.Component, nextProps: any, nextState: any) {\n  const { props, state } = component;\n  return !deepEquals(props, nextProps) || !deepEquals(state, nextState);\n}\n","import { DateObject } from './types';\n\n/** Returns a UTC date string for the given `dateObject`. If `time` is false, then the time portion of the string is\n * removed.\n *\n * @param dateObject - The `DateObject` to convert to a date string\n * @param [time=true] - Optional flag used to remove the time portion of the date string if false\n * @returns - The UTC date string\n */\nexport default function toDateString(dateObject: DateObject, time = true) {\n  const { year, month, day, hour = 0, minute = 0, second = 0 } = dateObject;\n  const utcTime = Date.UTC(year, month - 1, day, hour, minute, second);\n  const datetime = new Date(utcTime).toJSON();\n  return time ? datetime : datetime.slice(0, 10);\n}\n","import pad from './pad';\n\n/** Converts a UTC date string into a local Date format\n *\n * @param jsonDate - A UTC date string\n * @returns - An empty string when `jsonDate` is falsey, otherwise a date string in local format\n */\nexport default function utcToLocal(jsonDate: string) {\n  if (!jsonDate) {\n    return '';\n  }\n\n  // required format of `'yyyy-MM-ddThh:mm' followed by optional ':ss' or ':ss.SSS'\n  // https://html.spec.whatwg.org/multipage/input.html#local-date-and-time-state-(type%3Ddatetime-local)\n  // > should be a _valid local date and time string_ (not GMT)\n\n  // Note - date constructor passed local ISO-8601 does not correctly\n  // change time to UTC in node pre-8\n  const date = new Date(jsonDate);\n\n  const yyyy = pad(date.getFullYear(), 4);\n  const MM = pad(date.getMonth() + 1, 2);\n  const dd = pad(date.getDate(), 2);\n  const hh = pad(date.getHours(), 2);\n  const mm = pad(date.getMinutes(), 2);\n  const ss = pad(date.getSeconds(), 2);\n  const SSS = pad(date.getMilliseconds(), 3);\n\n  return `${yyyy}-${MM}-${dd}T${hh}:${mm}:${ss}.${SSS}`;\n}\n","/** An enumeration of all the translatable strings used by `@rjsf/core` and its themes. The value of each of the\n * enumeration keys is expected to be the actual english string. Some strings contain replaceable parameter values\n * as indicated by `%1`, `%2`, etc. The number after the `%` indicates the order of the parameter. The ordering of\n * parameters is important because some languages may choose to put the second parameter before the first in its\n * translation. Also, some strings are rendered using `markdown-to-jsx` and thus support markdown and inline html.\n */\nexport enum TranslatableString {\n  /** Fallback title of an array item, used by ArrayField */\n  ArrayItemTitle = 'Item',\n  /** Missing items reason, used by ArrayField */\n  MissingItems = 'Missing items definition',\n  /** Yes label, used by BooleanField */\n  YesLabel = 'Yes',\n  /** No label, used by BooleanField */\n  NoLabel = 'No',\n  /** Close label, used by ErrorList */\n  CloseLabel = 'Close',\n  /** Errors label, used by ErrorList */\n  ErrorsLabel = 'Errors',\n  /** New additionalProperties string default value, used by ObjectField */\n  NewStringDefault = 'New Value',\n  /** Add button title, used by AddButton */\n  AddButton = 'Add',\n  /** Add button title, used by AddButton */\n  AddItemButton = 'Add Item',\n  /** Copy button title, used by IconButton */\n  CopyButton = 'Copy',\n  /** Move down button title, used by IconButton */\n  MoveDownButton = 'Move down',\n  /** Move up button title, used by IconButton */\n  MoveUpButton = 'Move up',\n  /** Remove button title, used by IconButton */\n  RemoveButton = 'Remove',\n  /** Now label, used by AltDateWidget */\n  NowLabel = 'Now',\n  /** Clear label, used by AltDateWidget */\n  ClearLabel = 'Clear',\n  /** Aria date label, used by DateWidget */\n  AriaDateLabel = 'Select a date',\n  /** Decrement button aria label, used by UpDownWidget */\n  DecrementAriaLabel = 'Decrease value by 1',\n  /** Increment button aria label, used by UpDownWidget */\n  IncrementAriaLabel = 'Increase value by 1',\n  // Strings with replaceable parameters\n  /** Unknown field type reason, where %1 will be replaced with the type as provided by SchemaField */\n  UnknownFieldType = 'Unknown field type %1',\n  /** Option prefix, where %1 will be replaced with the option index as provided by MultiSchemaField */\n  OptionPrefix = 'Option %1',\n  /** Option prefix, where %1 and %2 will be replaced by the schema title and option index, respectively as provided by\n   * MultiSchemaField\n   */\n  TitleOptionPrefix = '%1 option %2',\n  /** Key label, where %1 will be replaced by the label as provided by WrapIfAdditionalTemplate */\n  KeyLabel = '%1 Key',\n  // Strings with replaceable parameters AND/OR that support markdown and html\n  /** Invalid object field configuration as provided by the ObjectField */\n  InvalidObjectField = 'Invalid \"%1\" object field configuration: <em>%2</em>.',\n  /** Unsupported field schema, used by UnsupportedField */\n  UnsupportedField = 'Unsupported field schema.',\n  /** Unsupported field schema, where %1 will be replaced by the idSchema.$id as provided by UnsupportedField */\n  UnsupportedFieldWithId = 'Unsupported field schema for field <code>%1</code>.',\n  /** Unsupported field schema, where %1 will be replaced by the reason string as provided by UnsupportedField */\n  UnsupportedFieldWithReason = 'Unsupported field schema: <em>%1</em>.',\n  /** Unsupported field schema, where %1 and %2 will be replaced by the idSchema.$id and reason strings, respectively,\n   * as provided by UnsupportedField\n   */\n  UnsupportedFieldWithIdAndReason = 'Unsupported field schema for field <code>%1</code>: <em>%2</em>.',\n  /** File name, type and size info, where %1, %2 and %3 will be replaced by the file name, file type and file size as\n   * provided by FileWidget\n   */\n  FilesInfo = '<strong>%1</strong> (%2, %3 bytes)',\n}\n"]},"metadata":{},"sourceType":"module"}