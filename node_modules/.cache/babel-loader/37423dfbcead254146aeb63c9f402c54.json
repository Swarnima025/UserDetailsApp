{"ast":null,"code":"const compare = require('json-schema-compare');\n\nconst forEach = require('lodash/forEach');\n\nconst {\n  allUniqueKeys,\n  deleteUndefinedProps,\n  has,\n  isSchema,\n  notUndefined,\n  uniqWith\n} = require('../common');\n\nfunction removeFalseSchemasFromArray(target) {\n  forEach(target, function (schema, index) {\n    if (schema === false) {\n      target.splice(index, 1);\n    }\n  });\n}\n\nfunction getItemSchemas(subSchemas, key) {\n  return subSchemas.map(function (sub) {\n    if (!sub) {\n      return undefined;\n    }\n\n    if (Array.isArray(sub.items)) {\n      const schemaAtPos = sub.items[key];\n\n      if (isSchema(schemaAtPos)) {\n        return schemaAtPos;\n      } else if (has(sub, 'additionalItems')) {\n        return sub.additionalItems;\n      }\n    } else {\n      return sub.items;\n    }\n\n    return undefined;\n  });\n}\n\nfunction getAdditionalSchemas(subSchemas) {\n  return subSchemas.map(function (sub) {\n    if (!sub) {\n      return undefined;\n    }\n\n    if (Array.isArray(sub.items)) {\n      return sub.additionalItems;\n    }\n\n    return sub.items;\n  });\n} // Provide source when array\n\n\nfunction mergeItems(group, mergeSchemas, items) {\n  const allKeys = allUniqueKeys(items);\n  return allKeys.reduce(function (all, key) {\n    const schemas = getItemSchemas(group, key);\n    const compacted = uniqWith(schemas.filter(notUndefined), compare);\n    all[key] = mergeSchemas(compacted, key);\n    return all;\n  }, []);\n}\n\nmodule.exports = {\n  keywords: ['items', 'additionalItems'],\n\n  resolver(values, parents, mergers) {\n    // const createSubMerger = groupKey => (schemas, key) => mergeSchemas(schemas, parents.concat(groupKey, key))\n    const items = values.map(s => s.items);\n    const itemsCompacted = items.filter(notUndefined);\n    const returnObject = {}; // if all items keyword values are schemas, we can merge them as simple schemas\n    // if not we need to merge them as mixed\n\n    if (itemsCompacted.every(isSchema)) {\n      returnObject.items = mergers.items(items);\n    } else {\n      returnObject.items = mergeItems(values, mergers.items, items);\n    }\n\n    let schemasAtLastPos;\n\n    if (itemsCompacted.every(Array.isArray)) {\n      schemasAtLastPos = values.map(s => s.additionalItems);\n    } else if (itemsCompacted.some(Array.isArray)) {\n      schemasAtLastPos = getAdditionalSchemas(values);\n    }\n\n    if (schemasAtLastPos) {\n      returnObject.additionalItems = mergers.additionalItems(schemasAtLastPos);\n    }\n\n    if (returnObject.additionalItems === false && Array.isArray(returnObject.items)) {\n      removeFalseSchemasFromArray(returnObject.items);\n    }\n\n    return deleteUndefinedProps(returnObject);\n  }\n\n};","map":{"version":3,"sources":["C:/Users/swarnima.mazumdar/Desktop/Contact-app/node_modules/json-schema-merge-allof/src/complex-resolvers/items.js"],"names":["compare","require","forEach","allUniqueKeys","deleteUndefinedProps","has","isSchema","notUndefined","uniqWith","removeFalseSchemasFromArray","target","schema","index","splice","getItemSchemas","subSchemas","key","map","sub","undefined","Array","isArray","items","schemaAtPos","additionalItems","getAdditionalSchemas","mergeItems","group","mergeSchemas","allKeys","reduce","all","schemas","compacted","filter","module","exports","keywords","resolver","values","parents","mergers","s","itemsCompacted","returnObject","every","schemasAtLastPos","some"],"mappings":"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","sourcesContent":["\nconst compare = require('json-schema-compare')\nconst forEach = require('lodash/forEach')\nconst {\n  allUniqueKeys,\n  deleteUndefinedProps,\n  has,\n  isSchema,\n  notUndefined,\n  uniqWith\n} = require('../common')\n\nfunction removeFalseSchemasFromArray(target) {\n  forEach(target, function(schema, index) {\n    if (schema === false) {\n      target.splice(index, 1)\n    }\n  })\n}\n\nfunction getItemSchemas(subSchemas, key) {\n  return subSchemas.map(function(sub) {\n    if (!sub) {\n      return undefined\n    }\n\n    if (Array.isArray(sub.items)) {\n      const schemaAtPos = sub.items[key]\n      if (isSchema(schemaAtPos)) {\n        return schemaAtPos\n      } else if (has(sub, 'additionalItems')) {\n        return sub.additionalItems\n      }\n    } else {\n      return sub.items\n    }\n\n    return undefined\n  })\n}\n\nfunction getAdditionalSchemas(subSchemas) {\n  return subSchemas.map(function(sub) {\n    if (!sub) {\n      return undefined\n    }\n    if (Array.isArray(sub.items)) {\n      return sub.additionalItems\n    }\n    return sub.items\n  })\n}\n\n// Provide source when array\nfunction mergeItems(group, mergeSchemas, items) {\n  const allKeys = allUniqueKeys(items)\n  return allKeys.reduce(function(all, key) {\n    const schemas = getItemSchemas(group, key)\n    const compacted = uniqWith(schemas.filter(notUndefined), compare)\n    all[key] = mergeSchemas(compacted, key)\n    return all\n  }, [])\n}\n\nmodule.exports = {\n  keywords: ['items', 'additionalItems'],\n  resolver(values, parents, mergers) {\n    // const createSubMerger = groupKey => (schemas, key) => mergeSchemas(schemas, parents.concat(groupKey, key))\n    const items = values.map(s => s.items)\n    const itemsCompacted = items.filter(notUndefined)\n    const returnObject = {}\n\n    // if all items keyword values are schemas, we can merge them as simple schemas\n    // if not we need to merge them as mixed\n    if (itemsCompacted.every(isSchema)) {\n      returnObject.items = mergers.items(items)\n    } else {\n      returnObject.items = mergeItems(values, mergers.items, items)\n    }\n\n    let schemasAtLastPos\n    if (itemsCompacted.every(Array.isArray)) {\n      schemasAtLastPos = values.map(s => s.additionalItems)\n    } else if (itemsCompacted.some(Array.isArray)) {\n      schemasAtLastPos = getAdditionalSchemas(values)\n    }\n\n    if (schemasAtLastPos) {\n      returnObject.additionalItems = mergers.additionalItems(schemasAtLastPos)\n    }\n\n    if (returnObject.additionalItems === false && Array.isArray(returnObject.items)) {\n      removeFalseSchemasFromArray(returnObject.items)\n    }\n\n    return deleteUndefinedProps(returnObject)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}