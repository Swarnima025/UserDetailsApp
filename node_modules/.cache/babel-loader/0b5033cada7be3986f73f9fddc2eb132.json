{"ast":null,"code":"const cloneDeep = require('lodash/cloneDeep');\n\nconst compare = require('json-schema-compare');\n\nconst computeLcm = require('compute-lcm');\n\nconst defaultsDeep = require('lodash/defaultsDeep');\n\nconst flatten = require('lodash/flatten');\n\nconst flattenDeep = require('lodash/flattenDeep');\n\nconst intersection = require('lodash/intersection');\n\nconst intersectionWith = require('lodash/intersectionWith');\n\nconst isEqual = require('lodash/isEqual');\n\nconst isPlainObject = require('lodash/isPlainObject');\n\nconst pullAll = require('lodash/pullAll');\n\nconst sortBy = require('lodash/sortBy');\n\nconst uniq = require('lodash/uniq');\n\nconst uniqWith = require('lodash/uniqWith');\n\nconst propertiesResolver = require('./complex-resolvers/properties');\n\nconst itemsResolver = require('./complex-resolvers/items');\n\nconst contains = (arr, val) => arr.indexOf(val) !== -1;\n\nconst isSchema = val => isPlainObject(val) || val === true || val === false;\n\nconst isFalse = val => val === false;\n\nconst isTrue = val => val === true;\n\nconst schemaResolver = (compacted, key, mergeSchemas) => mergeSchemas(compacted);\n\nconst stringArray = values => sortBy(uniq(flattenDeep(values)));\n\nconst notUndefined = val => val !== undefined;\n\nconst allUniqueKeys = arr => uniq(flattenDeep(arr.map(keys))); // resolvers\n\n\nconst first = compacted => compacted[0];\n\nconst required = compacted => stringArray(compacted);\n\nconst maximumValue = compacted => Math.max.apply(Math, compacted);\n\nconst minimumValue = compacted => Math.min.apply(Math, compacted);\n\nconst uniqueItems = compacted => compacted.some(isTrue);\n\nconst examples = compacted => uniqWith(flatten(compacted), isEqual);\n\nfunction compareProp(key) {\n  return function (a, b) {\n    return compare({\n      [key]: a\n    }, {\n      [key]: b\n    });\n  };\n}\n\nfunction getAllOf(schema) {\n  let {\n    allOf = [],\n    ...copy\n  } = schema;\n  copy = isPlainObject(schema) ? copy : schema; // if schema is boolean\n\n  return [copy, ...allOf.map(getAllOf)];\n}\n\nfunction getValues(schemas, key) {\n  return schemas.map(schema => schema && schema[key]);\n}\n\nfunction tryMergeSchemaGroups(schemaGroups, mergeSchemas) {\n  return schemaGroups.map(function (schemas, index) {\n    try {\n      return mergeSchemas(schemas, index);\n    } catch (e) {\n      return undefined;\n    }\n  }).filter(notUndefined);\n}\n\nfunction keys(obj) {\n  if (isPlainObject(obj) || Array.isArray(obj)) {\n    return Object.keys(obj);\n  } else {\n    return [];\n  }\n}\n\nfunction getAnyOfCombinations(arrOfArrays, combinations) {\n  combinations = combinations || [];\n\n  if (!arrOfArrays.length) {\n    return combinations;\n  }\n\n  const values = arrOfArrays.slice(0).shift();\n  const rest = arrOfArrays.slice(1);\n\n  if (combinations.length) {\n    return getAnyOfCombinations(rest, flatten(combinations.map(combination => values.map(item => [item].concat(combination)))));\n  }\n\n  return getAnyOfCombinations(rest, values.map(item => item));\n}\n\nfunction throwIncompatible(values, paths) {\n  let asJSON;\n\n  try {\n    asJSON = values.map(function (val) {\n      return JSON.stringify(val, null, 2);\n    }).join('\\n');\n  } catch (variable) {\n    asJSON = values.join(', ');\n  }\n\n  throw new Error('Could not resolve values for path:\"' + paths.join('.') + '\". They are probably incompatible. Values: \\n' + asJSON);\n}\n\nfunction callGroupResolver(complexKeywords, resolverName, schemas, mergeSchemas, options, parents) {\n  if (complexKeywords.length) {\n    const resolverConfig = options.complexResolvers[resolverName];\n\n    if (!resolverConfig || !resolverConfig.resolver) {\n      throw new Error('No resolver found for ' + resolverName);\n    } // extract all keywords from all the schemas that have one or more\n    // then remove all undefined ones and not unique\n\n\n    const extractedKeywordsOnly = schemas.map(schema => complexKeywords.reduce((all, key) => {\n      if (schema[key] !== undefined) all[key] = schema[key];\n      return all;\n    }, {}));\n    const unique = uniqWith(extractedKeywordsOnly, compare); // create mergers that automatically add the path of the keyword for use in the complex resolver\n\n    const mergers = resolverConfig.keywords.reduce((all, key) => ({ ...all,\n      [key]: function (schemas) {\n        let extraKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n        return mergeSchemas(schemas, null, parents.concat(key, extraKey));\n      }\n    }), {});\n    const result = resolverConfig.resolver(unique, parents.concat(resolverName), mergers, options);\n\n    if (!isPlainObject(result)) {\n      throwIncompatible(unique, parents.concat(resolverName));\n    }\n\n    return result;\n  }\n}\n\nfunction createRequiredMetaArray(arr) {\n  return {\n    required: arr\n  };\n}\n\nconst schemaGroupProps = ['properties', 'patternProperties', 'definitions', 'dependencies'];\nconst schemaArrays = ['anyOf', 'oneOf'];\nconst schemaProps = ['additionalProperties', 'additionalItems', 'contains', 'propertyNames', 'not', 'items'];\nconst defaultResolvers = {\n  type(compacted) {\n    if (compacted.some(Array.isArray)) {\n      const normalized = compacted.map(function (val) {\n        return Array.isArray(val) ? val : [val];\n      });\n      const common = intersection.apply(null, normalized);\n\n      if (common.length === 1) {\n        return common[0];\n      } else if (common.length > 1) {\n        return uniq(common);\n      }\n    }\n  },\n\n  dependencies(compacted, paths, mergeSchemas) {\n    const allChildren = allUniqueKeys(compacted);\n    return allChildren.reduce(function (all, childKey) {\n      const childSchemas = getValues(compacted, childKey);\n      let innerCompacted = uniqWith(childSchemas.filter(notUndefined), isEqual); // to support dependencies\n\n      const innerArrays = innerCompacted.filter(Array.isArray);\n\n      if (innerArrays.length) {\n        if (innerArrays.length === innerCompacted.length) {\n          all[childKey] = stringArray(innerCompacted);\n        } else {\n          const innerSchemas = innerCompacted.filter(isSchema);\n          const arrayMetaScheams = innerArrays.map(createRequiredMetaArray);\n          all[childKey] = mergeSchemas(innerSchemas.concat(arrayMetaScheams), childKey);\n        }\n\n        return all;\n      }\n\n      innerCompacted = uniqWith(innerCompacted, compare);\n      all[childKey] = mergeSchemas(innerCompacted, childKey);\n      return all;\n    }, {});\n  },\n\n  oneOf(compacted, paths, mergeSchemas) {\n    const combinations = getAnyOfCombinations(cloneDeep(compacted));\n    const result = tryMergeSchemaGroups(combinations, mergeSchemas);\n    const unique = uniqWith(result, compare);\n\n    if (unique.length) {\n      return unique;\n    }\n  },\n\n  not(compacted) {\n    return {\n      anyOf: compacted\n    };\n  },\n\n  pattern(compacted) {\n    return compacted.map(r => '(?=' + r + ')').join('');\n  },\n\n  multipleOf(compacted) {\n    let integers = compacted.slice(0);\n    let factor = 1;\n\n    while (integers.some(n => !Number.isInteger(n))) {\n      integers = integers.map(n => n * 10);\n      factor = factor * 10;\n    }\n\n    return computeLcm(integers) / factor;\n  },\n\n  enum(compacted) {\n    const enums = intersectionWith.apply(null, compacted.concat(isEqual));\n\n    if (enums.length) {\n      return sortBy(enums);\n    }\n  }\n\n};\ndefaultResolvers.$id = first;\ndefaultResolvers.$ref = first;\ndefaultResolvers.$schema = first;\ndefaultResolvers.additionalItems = schemaResolver;\ndefaultResolvers.additionalProperties = schemaResolver;\ndefaultResolvers.anyOf = defaultResolvers.oneOf;\ndefaultResolvers.contains = schemaResolver;\ndefaultResolvers.default = first;\ndefaultResolvers.definitions = defaultResolvers.dependencies;\ndefaultResolvers.description = first;\ndefaultResolvers.examples = examples;\ndefaultResolvers.exclusiveMaximum = minimumValue;\ndefaultResolvers.exclusiveMinimum = maximumValue;\ndefaultResolvers.items = itemsResolver;\ndefaultResolvers.maximum = minimumValue;\ndefaultResolvers.maxItems = minimumValue;\ndefaultResolvers.maxLength = minimumValue;\ndefaultResolvers.maxProperties = minimumValue;\ndefaultResolvers.minimum = maximumValue;\ndefaultResolvers.minItems = maximumValue;\ndefaultResolvers.minLength = maximumValue;\ndefaultResolvers.minProperties = maximumValue;\ndefaultResolvers.properties = propertiesResolver;\ndefaultResolvers.propertyNames = schemaResolver;\ndefaultResolvers.required = required;\ndefaultResolvers.title = first;\ndefaultResolvers.uniqueItems = uniqueItems;\nconst defaultComplexResolvers = {\n  properties: propertiesResolver,\n  items: itemsResolver\n};\n\nfunction merger(rootSchema, options, totalSchemas) {\n  totalSchemas = totalSchemas || [];\n  options = defaultsDeep(options, {\n    ignoreAdditionalProperties: false,\n    resolvers: defaultResolvers,\n    complexResolvers: defaultComplexResolvers,\n    deep: true\n  });\n  const complexResolvers = Object.entries(options.complexResolvers);\n\n  function mergeSchemas(schemas, base, parents) {\n    schemas = cloneDeep(schemas.filter(notUndefined));\n    parents = parents || [];\n    const merged = isPlainObject(base) ? base : {}; // return undefined, an empty schema\n\n    if (!schemas.length) {\n      return;\n    }\n\n    if (schemas.some(isFalse)) {\n      return false;\n    }\n\n    if (schemas.every(isTrue)) {\n      return true;\n    } // there are no false and we don't need the true ones as they accept everything\n\n\n    schemas = schemas.filter(isPlainObject);\n    const allKeys = allUniqueKeys(schemas);\n\n    if (options.deep && contains(allKeys, 'allOf')) {\n      return merger({\n        allOf: schemas\n      }, options, totalSchemas);\n    }\n\n    const complexKeysArr = complexResolvers.map(_ref => {\n      let [mainKeyWord, resolverConf] = _ref;\n      return allKeys.filter(k => resolverConf.keywords.includes(k));\n    }); // remove all complex keys before simple resolvers\n\n    complexKeysArr.forEach(keys => pullAll(allKeys, keys)); // call all simple resolvers for relevant keywords\n\n    allKeys.forEach(function (key) {\n      const values = getValues(schemas, key);\n      const compacted = uniqWith(values.filter(notUndefined), compareProp(key)); // arrayprops like anyOf and oneOf must be merged first, as they contains schemas\n      // allOf is treated differently alltogether\n\n      if (compacted.length === 1 && contains(schemaArrays, key)) {\n        merged[key] = compacted[0].map(schema => mergeSchemas([schema], schema)); // prop groups must always be resolved\n      } else if (compacted.length === 1 && !contains(schemaGroupProps, key) && !contains(schemaProps, key)) {\n        merged[key] = compacted[0];\n      } else {\n        const resolver = options.resolvers[key] || options.resolvers.defaultResolver;\n        if (!resolver) throw new Error('No resolver found for key ' + key + '. You can provide a resolver for this keyword in the options, or provide a default resolver.');\n\n        const merger = function (schemas) {\n          let extraKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n          return mergeSchemas(schemas, null, parents.concat(key, extraKey));\n        };\n\n        merged[key] = resolver(compacted, parents.concat(key), merger, options);\n\n        if (merged[key] === undefined) {\n          throwIncompatible(compacted, parents.concat(key));\n        } else if (merged[key] === undefined) {\n          delete merged[key];\n        }\n      }\n    });\n    return complexResolvers.reduce((all, _ref2, index) => {\n      let [resolverKeyword, config] = _ref2;\n      return { ...all,\n        ...callGroupResolver(complexKeysArr[index], resolverKeyword, schemas, mergeSchemas, options, parents)\n      };\n    }, merged);\n  }\n\n  const allSchemas = flattenDeep(getAllOf(rootSchema));\n  const merged = mergeSchemas(allSchemas);\n  return merged;\n}\n\nmerger.options = {\n  resolvers: defaultResolvers\n};\nmodule.exports = merger;","map":{"version":3,"sources":["C:/Users/swarnima.mazumdar/Desktop/Contact-app/node_modules/json-schema-merge-allof/src/index.js"],"names":["cloneDeep","require","compare","computeLcm","defaultsDeep","flatten","flattenDeep","intersection","intersectionWith","isEqual","isPlainObject","pullAll","sortBy","uniq","uniqWith","propertiesResolver","itemsResolver","contains","arr","val","indexOf","isSchema","isFalse","isTrue","schemaResolver","compacted","key","mergeSchemas","stringArray","values","notUndefined","undefined","allUniqueKeys","map","keys","first","required","maximumValue","Math","max","apply","minimumValue","min","uniqueItems","some","examples","compareProp","a","b","getAllOf","schema","allOf","copy","getValues","schemas","tryMergeSchemaGroups","schemaGroups","index","e","filter","obj","Array","isArray","Object","getAnyOfCombinations","arrOfArrays","combinations","length","slice","shift","rest","combination","item","concat","throwIncompatible","paths","asJSON","JSON","stringify","join","variable","Error","callGroupResolver","complexKeywords","resolverName","options","parents","resolverConfig","complexResolvers","resolver","extractedKeywordsOnly","reduce","all","unique","mergers","keywords","extraKey","result","createRequiredMetaArray","schemaGroupProps","schemaArrays","schemaProps","defaultResolvers","type","normalized","common","dependencies","allChildren","childKey","childSchemas","innerCompacted","innerArrays","innerSchemas","arrayMetaScheams","oneOf","not","anyOf","pattern","r","multipleOf","integers","factor","n","Number","isInteger","enum","enums","$id","$ref","$schema","additionalItems","additionalProperties","default","definitions","description","exclusiveMaximum","exclusiveMinimum","items","maximum","maxItems","maxLength","maxProperties","minimum","minItems","minLength","minProperties","properties","propertyNames","title","defaultComplexResolvers","merger","rootSchema","totalSchemas","ignoreAdditionalProperties","resolvers","deep","entries","base","merged","every","allKeys","complexKeysArr","mainKeyWord","resolverConf","k","includes","forEach","defaultResolver","resolverKeyword","config","allSchemas","module","exports"],"mappings":"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","sourcesContent":["const cloneDeep = require('lodash/cloneDeep')\nconst compare = require('json-schema-compare')\nconst computeLcm = require('compute-lcm')\nconst defaultsDeep = require('lodash/defaultsDeep')\nconst flatten = require('lodash/flatten')\nconst flattenDeep = require('lodash/flattenDeep')\nconst intersection = require('lodash/intersection')\nconst intersectionWith = require('lodash/intersectionWith')\nconst isEqual = require('lodash/isEqual')\nconst isPlainObject = require('lodash/isPlainObject')\nconst pullAll = require('lodash/pullAll')\nconst sortBy = require('lodash/sortBy')\nconst uniq = require('lodash/uniq')\nconst uniqWith = require('lodash/uniqWith')\n\nconst propertiesResolver = require('./complex-resolvers/properties')\nconst itemsResolver = require('./complex-resolvers/items')\n\nconst contains = (arr, val) => arr.indexOf(val) !== -1\nconst isSchema = (val) => isPlainObject(val) || val === true || val === false\nconst isFalse = (val) => val === false\nconst isTrue = (val) => val === true\nconst schemaResolver = (compacted, key, mergeSchemas) => mergeSchemas(compacted)\nconst stringArray = (values) => sortBy(uniq(flattenDeep(values)))\nconst notUndefined = (val) => val !== undefined\nconst allUniqueKeys = (arr) => uniq(flattenDeep(arr.map(keys)))\n\n// resolvers\nconst first = compacted => compacted[0]\nconst required = compacted => stringArray(compacted)\nconst maximumValue = compacted => Math.max.apply(Math, compacted)\nconst minimumValue = compacted => Math.min.apply(Math, compacted)\nconst uniqueItems = compacted => compacted.some(isTrue)\nconst examples = compacted => uniqWith(flatten(compacted), isEqual)\n\nfunction compareProp(key) {\n  return function(a, b) {\n    return compare({\n      [key]: a\n    }, { [key]: b })\n  }\n}\n\nfunction getAllOf(schema) {\n  let { allOf = [], ...copy } = schema\n  copy = isPlainObject(schema) ? copy : schema // if schema is boolean\n  return [copy, ...allOf.map(getAllOf)]\n}\n\nfunction getValues(schemas, key) {\n  return schemas.map(schema => schema && schema[key])\n}\n\nfunction tryMergeSchemaGroups(schemaGroups, mergeSchemas) {\n  return schemaGroups.map(function(schemas, index) {\n    try {\n      return mergeSchemas(schemas, index)\n    } catch (e) {\n      return undefined\n    }\n  }).filter(notUndefined)\n}\n\nfunction keys(obj) {\n  if (isPlainObject(obj) || Array.isArray(obj)) {\n    return Object.keys(obj)\n  } else {\n    return []\n  }\n}\n\nfunction getAnyOfCombinations(arrOfArrays, combinations) {\n  combinations = combinations || []\n  if (!arrOfArrays.length) {\n    return combinations\n  }\n\n  const values = arrOfArrays.slice(0).shift()\n  const rest = arrOfArrays.slice(1)\n  if (combinations.length) {\n    return getAnyOfCombinations(rest, flatten(combinations.map(combination => values.map(item => ([item].concat(combination))))))\n  }\n  return getAnyOfCombinations(rest, values.map(item => (item)))\n}\n\nfunction throwIncompatible(values, paths) {\n  let asJSON\n  try {\n    asJSON = values.map(function(val) {\n      return JSON.stringify(val, null, 2)\n    }).join('\\n')\n  } catch (variable) {\n    asJSON = values.join(', ')\n  }\n  throw new Error('Could not resolve values for path:\"' + paths.join('.') + '\". They are probably incompatible. Values: \\n' + asJSON)\n}\n\nfunction callGroupResolver(complexKeywords, resolverName, schemas, mergeSchemas, options, parents) {\n  if (complexKeywords.length) {\n    const resolverConfig = options.complexResolvers[resolverName]\n    if (!resolverConfig || !resolverConfig.resolver) {\n      throw new Error('No resolver found for ' + resolverName)\n    }\n\n    // extract all keywords from all the schemas that have one or more\n    // then remove all undefined ones and not unique\n    const extractedKeywordsOnly = schemas.map(schema => complexKeywords.reduce((all, key) => {\n      if (schema[key] !== undefined) all[key] = schema[key]\n      return all\n    }, {}))\n    const unique = uniqWith(extractedKeywordsOnly, compare)\n\n    // create mergers that automatically add the path of the keyword for use in the complex resolver\n    const mergers = resolverConfig.keywords.reduce((all, key) => ({\n      ...all,\n      [key]: (schemas, extraKey = []) => mergeSchemas(schemas, null, parents.concat(key, extraKey))\n    }), {})\n\n    const result = resolverConfig.resolver(unique, parents.concat(resolverName), mergers, options)\n\n    if (!isPlainObject(result)) {\n      throwIncompatible(unique, parents.concat(resolverName))\n    }\n\n    return result\n  }\n}\n\nfunction createRequiredMetaArray(arr) {\n  return { required: arr }\n}\n\nconst schemaGroupProps = ['properties', 'patternProperties', 'definitions', 'dependencies']\nconst schemaArrays = ['anyOf', 'oneOf']\nconst schemaProps = [\n  'additionalProperties',\n  'additionalItems',\n  'contains',\n  'propertyNames',\n  'not',\n  'items'\n]\n\nconst defaultResolvers = {\n  type(compacted) {\n    if (compacted.some(Array.isArray)) {\n      const normalized = compacted.map(function(val) {\n        return Array.isArray(val)\n          ? val\n          : [val]\n      })\n      const common = intersection.apply(null, normalized)\n\n      if (common.length === 1) {\n        return common[0]\n      } else if (common.length > 1) {\n        return uniq(common)\n      }\n    }\n  },\n  dependencies(compacted, paths, mergeSchemas) {\n    const allChildren = allUniqueKeys(compacted)\n\n    return allChildren.reduce(function(all, childKey) {\n      const childSchemas = getValues(compacted, childKey)\n      let innerCompacted = uniqWith(childSchemas.filter(notUndefined), isEqual)\n\n      // to support dependencies\n      const innerArrays = innerCompacted.filter(Array.isArray)\n\n      if (innerArrays.length) {\n        if (innerArrays.length === innerCompacted.length) {\n          all[childKey] = stringArray(innerCompacted)\n        } else {\n          const innerSchemas = innerCompacted.filter(isSchema)\n          const arrayMetaScheams = innerArrays.map(createRequiredMetaArray)\n          all[childKey] = mergeSchemas(innerSchemas.concat(arrayMetaScheams), childKey)\n        }\n        return all\n      }\n\n      innerCompacted = uniqWith(innerCompacted, compare)\n\n      all[childKey] = mergeSchemas(innerCompacted, childKey)\n      return all\n    }, {})\n  },\n  oneOf(compacted, paths, mergeSchemas) {\n    const combinations = getAnyOfCombinations(cloneDeep(compacted))\n    const result = tryMergeSchemaGroups(combinations, mergeSchemas)\n    const unique = uniqWith(result, compare)\n\n    if (unique.length) {\n      return unique\n    }\n  },\n  not(compacted) {\n    return { anyOf: compacted }\n  },\n  pattern(compacted) {\n    return compacted.map(r => '(?=' + r + ')').join('')\n  },\n  multipleOf(compacted) {\n    let integers = compacted.slice(0)\n    let factor = 1\n    while (integers.some(n => !Number.isInteger(n))) {\n      integers = integers.map(n => n * 10)\n      factor = factor * 10\n    }\n    return computeLcm(integers) / factor\n  },\n  enum(compacted) {\n    const enums = intersectionWith.apply(null, compacted.concat(isEqual))\n    if (enums.length) {\n      return sortBy(enums)\n    }\n  }\n}\n\ndefaultResolvers.$id = first\ndefaultResolvers.$ref = first\ndefaultResolvers.$schema = first\ndefaultResolvers.additionalItems = schemaResolver\ndefaultResolvers.additionalProperties = schemaResolver\ndefaultResolvers.anyOf = defaultResolvers.oneOf\ndefaultResolvers.contains = schemaResolver\ndefaultResolvers.default = first\ndefaultResolvers.definitions = defaultResolvers.dependencies\ndefaultResolvers.description = first\ndefaultResolvers.examples = examples\ndefaultResolvers.exclusiveMaximum = minimumValue\ndefaultResolvers.exclusiveMinimum = maximumValue\ndefaultResolvers.items = itemsResolver\ndefaultResolvers.maximum = minimumValue\ndefaultResolvers.maxItems = minimumValue\ndefaultResolvers.maxLength = minimumValue\ndefaultResolvers.maxProperties = minimumValue\ndefaultResolvers.minimum = maximumValue\ndefaultResolvers.minItems = maximumValue\ndefaultResolvers.minLength = maximumValue\ndefaultResolvers.minProperties = maximumValue\ndefaultResolvers.properties = propertiesResolver\ndefaultResolvers.propertyNames = schemaResolver\ndefaultResolvers.required = required\ndefaultResolvers.title = first\ndefaultResolvers.uniqueItems = uniqueItems\n\nconst defaultComplexResolvers = {\n  properties: propertiesResolver,\n  items: itemsResolver\n}\n\nfunction merger(rootSchema, options, totalSchemas) {\n  totalSchemas = totalSchemas || []\n  options = defaultsDeep(options, {\n    ignoreAdditionalProperties: false,\n    resolvers: defaultResolvers,\n    complexResolvers: defaultComplexResolvers,\n    deep: true\n  })\n\n  const complexResolvers = Object.entries(options.complexResolvers)\n\n  function mergeSchemas(schemas, base, parents) {\n    schemas = cloneDeep(schemas.filter(notUndefined))\n    parents = parents || []\n    const merged = isPlainObject(base)\n      ? base\n      : {}\n\n    // return undefined, an empty schema\n    if (!schemas.length) {\n      return\n    }\n\n    if (schemas.some(isFalse)) {\n      return false\n    }\n\n    if (schemas.every(isTrue)) {\n      return true\n    }\n\n    // there are no false and we don't need the true ones as they accept everything\n    schemas = schemas.filter(isPlainObject)\n\n    const allKeys = allUniqueKeys(schemas)\n    if (options.deep && contains(allKeys, 'allOf')) {\n      return merger({\n        allOf: schemas\n      }, options, totalSchemas)\n    }\n\n    const complexKeysArr = complexResolvers.map(([mainKeyWord, resolverConf]) =>\n      allKeys.filter(k => resolverConf.keywords.includes(k)))\n\n    // remove all complex keys before simple resolvers\n    complexKeysArr.forEach(keys => pullAll(allKeys, keys))\n\n    // call all simple resolvers for relevant keywords\n    allKeys.forEach(function(key) {\n      const values = getValues(schemas, key)\n      const compacted = uniqWith(values.filter(notUndefined), compareProp(key))\n\n      // arrayprops like anyOf and oneOf must be merged first, as they contains schemas\n      // allOf is treated differently alltogether\n      if (compacted.length === 1 && contains(schemaArrays, key)) {\n        merged[key] = compacted[0].map(schema => mergeSchemas([schema], schema))\n        // prop groups must always be resolved\n      } else if (compacted.length === 1 && !contains(schemaGroupProps, key) && !contains(schemaProps, key)) {\n        merged[key] = compacted[0]\n      } else {\n        const resolver = options.resolvers[key] || options.resolvers.defaultResolver\n        if (!resolver) throw new Error('No resolver found for key ' + key + '. You can provide a resolver for this keyword in the options, or provide a default resolver.')\n\n        const merger = (schemas, extraKey = []) => mergeSchemas(schemas, null, parents.concat(key, extraKey))\n        merged[key] = resolver(compacted, parents.concat(key), merger, options)\n\n        if (merged[key] === undefined) {\n          throwIncompatible(compacted, parents.concat(key))\n        } else if (merged[key] === undefined) {\n          delete merged[key]\n        }\n      }\n    })\n\n    return complexResolvers.reduce((all, [resolverKeyword, config], index) => ({\n      ...all,\n      ...callGroupResolver(complexKeysArr[index], resolverKeyword, schemas, mergeSchemas, options, parents)\n    }), merged)\n  }\n\n  const allSchemas = flattenDeep(getAllOf(rootSchema))\n  const merged = mergeSchemas(allSchemas)\n\n  return merged\n}\n\nmerger.options = {\n  resolvers: defaultResolvers\n}\n\nmodule.exports = merger\n"]},"metadata":{},"sourceType":"script"}