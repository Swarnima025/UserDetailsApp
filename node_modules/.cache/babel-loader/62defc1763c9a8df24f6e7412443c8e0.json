{"ast":null,"code":"import * as n from \"react\";\n\nfunction r() {\n  return r = Object.assign || function (n) {\n    for (var r = 1; r < arguments.length; r++) {\n      var t = arguments[r];\n\n      for (var e in t) Object.prototype.hasOwnProperty.call(t, e) && (n[e] = t[e]);\n    }\n\n    return n;\n  }, r.apply(this, arguments);\n}\n\nvar t = [\"children\", \"options\"],\n    e = [\"allowFullScreen\", \"allowTransparency\", \"autoComplete\", \"autoFocus\", \"autoPlay\", \"cellPadding\", \"cellSpacing\", \"charSet\", \"className\", \"classId\", \"colSpan\", \"contentEditable\", \"contextMenu\", \"crossOrigin\", \"encType\", \"formAction\", \"formEncType\", \"formMethod\", \"formNoValidate\", \"formTarget\", \"frameBorder\", \"hrefLang\", \"inputMode\", \"keyParams\", \"keyType\", \"marginHeight\", \"marginWidth\", \"maxLength\", \"mediaGroup\", \"minLength\", \"noValidate\", \"radioGroup\", \"readOnly\", \"rowSpan\", \"spellCheck\", \"srcDoc\", \"srcLang\", \"srcSet\", \"tabIndex\", \"useMap\"].reduce(function (n, r) {\n  return n[r.toLowerCase()] = r, n;\n}, {\n  for: \"htmlFor\"\n}),\n    o = {\n  amp: \"&\",\n  apos: \"'\",\n  gt: \">\",\n  lt: \"<\",\n  nbsp: \" \",\n  quot: \"“\"\n},\n    u = [\"style\", \"script\"],\n    a = /([-A-Z0-9_:]+)(?:\\s*=\\s*(?:(?:\"((?:\\\\.|[^\"])*)\")|(?:'((?:\\\\.|[^'])*)')|(?:\\{((?:\\\\.|{[^}]*?}|[^}])*)\\})))?/gi,\n    c = /mailto:/i,\n    i = /\\n{2,}$/,\n    _ = /^( *>[^\\n]+(\\n[^\\n]+)*\\n*)+\\n{2,}/,\n    f = /^ *> ?/gm,\n    l = /^ {2,}\\n/,\n    s = /^(?:( *[-*_])){3,} *(?:\\n *)+\\n/,\n    d = /^\\s*(`{3,}|~{3,}) *(\\S+)?([^\\n]*?)?\\n([\\s\\S]+?)\\s*\\1 *(?:\\n *)*\\n?/,\n    p = /^(?: {4}[^\\n]+\\n*)+(?:\\n *)+\\n?/,\n    m = /^(`+)\\s*([\\s\\S]*?[^`])\\s*\\1(?!`)/,\n    g = /^(?:\\n *)*\\n/,\n    v = /\\r\\n?/g,\n    y = /^\\[\\^([^\\]]+)](:.*)\\n/,\n    h = /^\\[\\^([^\\]]+)]/,\n    k = /\\f/g,\n    x = /^\\s*?\\[(x|\\s)\\]/,\n    b = /^ *(#{1,6}) *([^\\n]+?)(?: +#*)?(?:\\n *)*(?:\\n|$)/,\n    S = /^([^\\n]+)\\n *(=|-){3,} *(?:\\n *)+\\n/,\n    $ = /^ *(?!<[a-z][^ >/]* ?\\/>)<([a-z][^ >/]*) ?([^>]*)\\/{0}>\\n?(\\s*(?:<\\1[^>]*?>[\\s\\S]*?<\\/\\1>|(?!<\\1)[\\s\\S])*?)<\\/\\1>\\n*/i,\n    z = /&([a-zA-Z]+);/g,\n    w = /^<!--[\\s\\S]*?(?:-->)/,\n    A = /^(data|aria|x)-[a-z_][a-z\\d_.-]*$/,\n    E = /^ *<([a-z][a-z0-9:]*)(?:\\s+((?:<.*?>|[^>])*))?\\/?>(?!<\\/\\1>)(\\s*\\n)?/i,\n    L = /^\\{.*\\}$/,\n    M = /^(https?:\\/\\/[^\\s<]+[^<.,:;\"')\\]\\s])/,\n    I = /^<([^ >]+@[^ >]+)>/,\n    O = /^<([^ >]+:\\/[^ >]+)>/,\n    B = /-([a-z])?/gi,\n    R = /^(.*\\|?.*)\\n *(\\|? *[-:]+ *\\|[-| :]*)\\n((?:.*\\|.*\\n)*)\\n?/,\n    T = /^\\[([^\\]]*)\\]:\\s+<?([^\\s>]+)>?\\s*(\"([^\"]*)\")?/,\n    j = /^!\\[([^\\]]*)\\] ?\\[([^\\]]*)\\]/,\n    C = /^\\[([^\\]]*)\\] ?\\[([^\\]]*)\\]/,\n    D = /(\\[|\\])/g,\n    N = /(\\n|^[-*]\\s|^#|^ {2,}|^-{2,}|^>\\s)/,\n    Z = /\\t/g,\n    F = /^ *\\| */,\n    P = /(^ *\\||\\| *$)/g,\n    G = / *$/,\n    H = /^ *:-+: *$/,\n    q = /^ *:-+ *$/,\n    U = /^ *-+: *$/,\n    V = /^([*_])\\1((?:\\[.*?\\][([].*?[)\\]]|<.*?>(?:.*?<.*?>)?|`.*?`|~+.*?~+|.)*?)\\1\\1(?!\\1)/,\n    W = /^([*_])((?:\\[.*?\\][([].*?[)\\]]|<.*?>(?:.*?<.*?>)?|`.*?`|~+.*?~+|.)*?)\\1(?!\\1|\\w)/,\n    Q = /^==((?:\\[.*?\\]|<.*?>(?:.*?<.*?>)?|`.*?`|.)*?)==/,\n    X = /^~~((?:\\[.*?\\]|<.*?>(?:.*?<.*?>)?|`.*?`|.)*?)~~/,\n    J = /^\\\\([^0-9A-Za-z\\s])/,\n    K = /^[\\s\\S]+?(?=[^0-9A-Z\\s\\u00c0-\\uffff&;.()'\"]|\\d+\\.|\\n\\n| {2,}\\n|\\w+:\\S|$)/i,\n    Y = /^\\n+/,\n    nn = /^([ \\t]*)/,\n    rn = /\\\\([^\\\\])/g,\n    tn = / *\\n+$/,\n    en = /(?:^|\\n)( *)$/,\n    on = \"(?:\\\\d+\\\\.)\",\n    un = \"(?:[*+-])\";\n\nfunction an(n) {\n  return \"( *)(\" + (1 === n ? on : un) + \") +\";\n}\n\nvar cn = an(1),\n    _n = an(2);\n\nfunction fn(n) {\n  return new RegExp(\"^\" + (1 === n ? cn : _n));\n}\n\nvar ln = fn(1),\n    sn = fn(2);\n\nfunction dn(n) {\n  return new RegExp(\"^\" + (1 === n ? cn : _n) + \"[^\\\\n]*(?:\\\\n(?!\\\\1\" + (1 === n ? on : un) + \" )[^\\\\n]*)*(\\\\n|$)\", \"gm\");\n}\n\nvar pn = dn(1),\n    mn = dn(2);\n\nfunction gn(n) {\n  var r = 1 === n ? on : un;\n  return new RegExp(\"^( *)(\" + r + \") [\\\\s\\\\S]+?(?:\\\\n{2,}(?! )(?!\\\\1\" + r + \" (?!\" + r + \" ))\\\\n*|\\\\s*\\\\n*$)\");\n}\n\nvar vn = gn(1),\n    yn = gn(2);\n\nfunction hn(n, r) {\n  var t = 1 === r,\n      e = t ? vn : yn,\n      o = t ? pn : mn,\n      u = t ? ln : sn;\n  return {\n    t: function (n, r, t) {\n      var o = en.exec(t);\n      return o && (r.o || !r.u && !r.i) ? e.exec(n = o[1] + n) : null;\n    },\n    _: Nn.HIGH,\n    l: function (n, r, e) {\n      var a = t ? +n[2] : void 0,\n          c = n[0].replace(i, \"\\n\").match(o),\n          _ = !1;\n\n      return {\n        p: c.map(function (n, t) {\n          var o = u.exec(n)[0].length,\n              a = new RegExp(\"^ {1,\" + o + \"}\", \"gm\"),\n              i = n.replace(a, \"\").replace(u, \"\"),\n              f = t === c.length - 1,\n              l = -1 !== i.indexOf(\"\\n\\n\") || f && _;\n\n          _ = l;\n          var s,\n              d = e.u,\n              p = e.o;\n          e.o = !0, l ? (e.u = !1, s = i.replace(tn, \"\\n\\n\")) : (e.u = !0, s = i.replace(tn, \"\"));\n          var m = r(s, e);\n          return e.u = d, e.o = p, m;\n        }),\n        m: t,\n        g: a\n      };\n    },\n    v: function (r, t, e) {\n      return n(r.m ? \"ol\" : \"ul\", {\n        key: e.h,\n        start: r.g\n      }, r.p.map(function (r, o) {\n        return n(\"li\", {\n          key: o\n        }, t(r, e));\n      }));\n    }\n  };\n}\n\nvar kn = /^\\[([^\\]]*)]\\( *((?:\\([^)]*\\)|[^() ])*) *\"?([^)\"]*)?\"?\\)/,\n    xn = /^!\\[([^\\]]*)]\\( *((?:\\([^)]*\\)|[^() ])*) *\"?([^)\"]*)?\"?\\)/,\n    bn = [_, d, p, b, S, w, R, pn, vn, mn, yn],\n    Sn = [].concat(bn, [/^[^\\n]+(?:  \\n|\\n{2,})/, $, E]);\n\nfunction $n(n) {\n  return n.replace(/[ÀÁÂÃÄÅàáâãäåæÆ]/g, \"a\").replace(/[çÇ]/g, \"c\").replace(/[ðÐ]/g, \"d\").replace(/[ÈÉÊËéèêë]/g, \"e\").replace(/[ÏïÎîÍíÌì]/g, \"i\").replace(/[Ññ]/g, \"n\").replace(/[øØœŒÕõÔôÓóÒò]/g, \"o\").replace(/[ÜüÛûÚúÙù]/g, \"u\").replace(/[ŸÿÝý]/g, \"y\").replace(/[^a-z0-9- ]/gi, \"\").replace(/ /gi, \"-\").toLowerCase();\n}\n\nfunction zn(n) {\n  return U.test(n) ? \"right\" : H.test(n) ? \"center\" : q.test(n) ? \"left\" : null;\n}\n\nfunction wn(n, r, t) {\n  var e = t.k;\n  t.k = !0;\n  var o = r(n.trim(), t);\n  t.k = e;\n  var u = [[]];\n  return o.forEach(function (n, r) {\n    \"tableSeparator\" === n.type ? 0 !== r && r !== o.length - 1 && u.push([]) : (\"text\" !== n.type || null != o[r + 1] && \"tableSeparator\" !== o[r + 1].type || (n.S = n.S.replace(G, \"\")), u[u.length - 1].push(n));\n  }), u;\n}\n\nfunction An(n, r, t) {\n  t.u = !0;\n\n  var e = wn(n[1], r, t),\n      o = n[2].replace(P, \"\").split(\"|\").map(zn),\n      u = function (n, r, t) {\n    return n.trim().split(\"\\n\").map(function (n) {\n      return wn(n, r, t);\n    });\n  }(n[3], r, t);\n\n  return t.u = !1, {\n    $: o,\n    A: u,\n    L: e,\n    type: \"table\"\n  };\n}\n\nfunction En(n, r) {\n  return null == n.$[r] ? {} : {\n    textAlign: n.$[r]\n  };\n}\n\nfunction Ln(n) {\n  return function (r, t) {\n    return t.u ? n.exec(r) : null;\n  };\n}\n\nfunction Mn(n) {\n  return function (r, t) {\n    return t.u || t.i ? n.exec(r) : null;\n  };\n}\n\nfunction In(n) {\n  return function (r, t) {\n    return t.u || t.i ? null : n.exec(r);\n  };\n}\n\nfunction On(n) {\n  return function (r) {\n    return n.exec(r);\n  };\n}\n\nfunction Bn(n, r, t) {\n  if (r.u || r.i) return null;\n  if (t && !t.endsWith(\"\\n\")) return null;\n  var e = \"\";\n  n.split(\"\\n\").every(function (n) {\n    return !bn.some(function (r) {\n      return r.test(n);\n    }) && (e += n + \"\\n\", n.trim());\n  });\n  var o = e.trimEnd();\n  return \"\" == o ? null : [e, o];\n}\n\nfunction Rn(n) {\n  try {\n    if (decodeURIComponent(n).replace(/[^A-Za-z0-9/:]/g, \"\").match(/^\\s*(javascript|vbscript|data(?!:image)):/i)) return null;\n  } catch (n) {\n    return null;\n  }\n\n  return n;\n}\n\nfunction Tn(n) {\n  return n.replace(rn, \"$1\");\n}\n\nfunction jn(n, r, t) {\n  var e = t.u || !1,\n      o = t.i || !1;\n  t.u = !0, t.i = !0;\n  var u = n(r, t);\n  return t.u = e, t.i = o, u;\n}\n\nfunction Cn(n, r, t) {\n  var e = t.u || !1,\n      o = t.i || !1;\n  t.u = !1, t.i = !0;\n  var u = n(r, t);\n  return t.u = e, t.i = o, u;\n}\n\nfunction Dn(n, r, t) {\n  return t.u = !1, n(r + \"\\n\\n\", t);\n}\n\nvar Nn,\n    Zn = function (n, r, t) {\n  return {\n    S: jn(r, n[1], t)\n  };\n};\n\nfunction Fn() {\n  return {};\n}\n\nfunction Pn() {\n  return null;\n}\n\nfunction Gn() {\n  return [].slice.call(arguments).filter(Boolean).join(\" \");\n}\n\nfunction Hn(n, r, t) {\n  for (var e = n, o = r.split(\".\"); o.length && void 0 !== (e = e[o[0]]);) o.shift();\n\n  return e || t;\n}\n\nfunction qn(n, r) {\n  var t = Hn(r, n);\n  return t ? \"function\" == typeof t || \"object\" == typeof t && \"render\" in t ? t : Hn(r, n + \".component\", n) : n;\n}\n\nfunction Un(t, i) {\n  void 0 === i && (i = {}), i.overrides = i.overrides || {}, i.slugify = i.slugify || $n, i.namedCodesToUnicode = i.namedCodesToUnicode ? r({}, o, i.namedCodesToUnicode) : o;\n  var P = i.createElement || n.createElement;\n\n  function G(n, t) {\n    var e = Hn(i.overrides, n + \".props\", {});\n    return P.apply(void 0, [qn(n, i.overrides), r({}, t, e, {\n      className: Gn(null == t ? void 0 : t.className, e.className) || void 0\n    })].concat([].slice.call(arguments, 2)));\n  }\n\n  function H(r) {\n    var t = !1;\n    i.forceInline ? t = !0 : i.forceBlock || (t = !1 === N.test(r));\n\n    for (var e = un(on(t ? r : r.trimEnd().replace(Y, \"\") + \"\\n\\n\", {\n      u: t\n    })); \"string\" == typeof e[e.length - 1] && !e[e.length - 1].trim();) e.pop();\n\n    if (null === i.wrapper) return e;\n    var o,\n        u = i.wrapper || (t ? \"span\" : \"div\");\n    if (e.length > 1 || i.forceWrapper) o = e;else {\n      if (1 === e.length) return \"string\" == typeof (o = e[0]) ? G(\"span\", {\n        key: \"outer\"\n      }, o) : o;\n      o = null;\n    }\n    return n.createElement(u, {\n      key: \"outer\"\n    }, o);\n  }\n\n  function q(r) {\n    var t = r.match(a);\n    return t ? t.reduce(function (r, t, o) {\n      var u = t.indexOf(\"=\");\n\n      if (-1 !== u) {\n        var a = function (n) {\n          return -1 !== n.indexOf(\"-\") && null === n.match(A) && (n = n.replace(B, function (n, r) {\n            return r.toUpperCase();\n          })), n;\n        }(t.slice(0, u)).trim(),\n            c = function (n) {\n          var r = n[0];\n          return ('\"' === r || \"'\" === r) && n.length >= 2 && n[n.length - 1] === r ? n.slice(1, -1) : n;\n        }(t.slice(u + 1).trim()),\n            i = e[a] || a,\n            _ = r[i] = function (n, r) {\n          return \"style\" === n ? r.split(/;\\s?/).reduce(function (n, r) {\n            var t = r.slice(0, r.indexOf(\":\"));\n            return n[t.replace(/(-[a-z])/g, function (n) {\n              return n[1].toUpperCase();\n            })] = r.slice(t.length + 1).trim(), n;\n          }, {}) : \"href\" === n ? Rn(r) : (r.match(L) && (r = r.slice(1, r.length - 1)), \"true\" === r || \"false\" !== r && r);\n        }(a, c);\n\n        \"string\" == typeof _ && ($.test(_) || E.test(_)) && (r[i] = n.cloneElement(H(_.trim()), {\n          key: o\n        }));\n      } else \"style\" !== t && (r[e[t] || t] = !0);\n\n      return r;\n    }, {}) : null;\n  }\n\n  var U = [],\n      rn = {},\n      tn = {\n    blockQuote: {\n      t: In(_),\n      _: Nn.HIGH,\n      l: function (n, r, t) {\n        return {\n          S: r(n[0].replace(f, \"\"), t)\n        };\n      },\n      v: function (n, r, t) {\n        return G(\"blockquote\", {\n          key: t.h\n        }, r(n.S, t));\n      }\n    },\n    breakLine: {\n      t: On(l),\n      _: Nn.HIGH,\n      l: Fn,\n      v: function (n, r, t) {\n        return G(\"br\", {\n          key: t.h\n        });\n      }\n    },\n    breakThematic: {\n      t: In(s),\n      _: Nn.HIGH,\n      l: Fn,\n      v: function (n, r, t) {\n        return G(\"hr\", {\n          key: t.h\n        });\n      }\n    },\n    codeBlock: {\n      t: In(p),\n      _: Nn.MAX,\n      l: function (n) {\n        return {\n          S: n[0].replace(/^ {4}/gm, \"\").replace(/\\n+$/, \"\"),\n          M: void 0\n        };\n      },\n      v: function (n, t, e) {\n        return G(\"pre\", {\n          key: e.h\n        }, G(\"code\", r({}, n.I, {\n          className: n.M ? \"lang-\" + n.M : \"\"\n        }), n.S));\n      }\n    },\n    codeFenced: {\n      t: In(d),\n      _: Nn.MAX,\n      l: function (n) {\n        return {\n          I: q(n[3] || \"\"),\n          S: n[4],\n          M: n[2] || void 0,\n          type: \"codeBlock\"\n        };\n      }\n    },\n    codeInline: {\n      t: Mn(m),\n      _: Nn.LOW,\n      l: function (n) {\n        return {\n          S: n[2]\n        };\n      },\n      v: function (n, r, t) {\n        return G(\"code\", {\n          key: t.h\n        }, n.S);\n      }\n    },\n    footnote: {\n      t: In(y),\n      _: Nn.MAX,\n      l: function (n) {\n        return U.push({\n          O: n[2],\n          B: n[1]\n        }), {};\n      },\n      v: Pn\n    },\n    footnoteReference: {\n      t: Ln(h),\n      _: Nn.HIGH,\n      l: function (n) {\n        return {\n          S: n[1],\n          R: \"#\" + i.slugify(n[1])\n        };\n      },\n      v: function (n, r, t) {\n        return G(\"a\", {\n          key: t.h,\n          href: Rn(n.R)\n        }, G(\"sup\", {\n          key: t.h\n        }, n.S));\n      }\n    },\n    gfmTask: {\n      t: Ln(x),\n      _: Nn.HIGH,\n      l: function (n) {\n        return {\n          T: \"x\" === n[1].toLowerCase()\n        };\n      },\n      v: function (n, r, t) {\n        return G(\"input\", {\n          checked: n.T,\n          key: t.h,\n          readOnly: !0,\n          type: \"checkbox\"\n        });\n      }\n    },\n    heading: {\n      t: In(b),\n      _: Nn.HIGH,\n      l: function (n, r, t) {\n        return {\n          S: jn(r, n[2], t),\n          j: i.slugify(n[2]),\n          C: n[1].length\n        };\n      },\n      v: function (n, r, t) {\n        return G(\"h\" + n.C, {\n          id: n.j,\n          key: t.h\n        }, r(n.S, t));\n      }\n    },\n    headingSetext: {\n      t: In(S),\n      _: Nn.MAX,\n      l: function (n, r, t) {\n        return {\n          S: jn(r, n[1], t),\n          C: \"=\" === n[2] ? 1 : 2,\n          type: \"heading\"\n        };\n      }\n    },\n    htmlComment: {\n      t: On(w),\n      _: Nn.HIGH,\n      l: function () {\n        return {};\n      },\n      v: Pn\n    },\n    image: {\n      t: Mn(xn),\n      _: Nn.HIGH,\n      l: function (n) {\n        return {\n          D: n[1],\n          R: Tn(n[2]),\n          N: n[3]\n        };\n      },\n      v: function (n, r, t) {\n        return G(\"img\", {\n          key: t.h,\n          alt: n.D || void 0,\n          title: n.N || void 0,\n          src: Rn(n.R)\n        });\n      }\n    },\n    link: {\n      t: Ln(kn),\n      _: Nn.LOW,\n      l: function (n, r, t) {\n        return {\n          S: Cn(r, n[1], t),\n          R: Tn(n[2]),\n          N: n[3]\n        };\n      },\n      v: function (n, r, t) {\n        return G(\"a\", {\n          key: t.h,\n          href: Rn(n.R),\n          title: n.N\n        }, r(n.S, t));\n      }\n    },\n    linkAngleBraceStyleDetector: {\n      t: Ln(O),\n      _: Nn.MAX,\n      l: function (n) {\n        return {\n          S: [{\n            S: n[1],\n            type: \"text\"\n          }],\n          R: n[1],\n          type: \"link\"\n        };\n      }\n    },\n    linkBareUrlDetector: {\n      t: function (n, r) {\n        return r.Z ? null : Ln(M)(n, r);\n      },\n      _: Nn.MAX,\n      l: function (n) {\n        return {\n          S: [{\n            S: n[1],\n            type: \"text\"\n          }],\n          R: n[1],\n          N: void 0,\n          type: \"link\"\n        };\n      }\n    },\n    linkMailtoDetector: {\n      t: Ln(I),\n      _: Nn.MAX,\n      l: function (n) {\n        var r = n[1],\n            t = n[1];\n        return c.test(t) || (t = \"mailto:\" + t), {\n          S: [{\n            S: r.replace(\"mailto:\", \"\"),\n            type: \"text\"\n          }],\n          R: t,\n          type: \"link\"\n        };\n      }\n    },\n    orderedList: hn(G, 1),\n    unorderedList: hn(G, 2),\n    newlineCoalescer: {\n      t: In(g),\n      _: Nn.LOW,\n      l: Fn,\n      v: function () {\n        return \"\\n\";\n      }\n    },\n    paragraph: {\n      t: Bn,\n      _: Nn.LOW,\n      l: Zn,\n      v: function (n, r, t) {\n        return G(\"p\", {\n          key: t.h\n        }, r(n.S, t));\n      }\n    },\n    ref: {\n      t: Ln(T),\n      _: Nn.MAX,\n      l: function (n) {\n        return rn[n[1]] = {\n          R: n[2],\n          N: n[4]\n        }, {};\n      },\n      v: Pn\n    },\n    refImage: {\n      t: Mn(j),\n      _: Nn.MAX,\n      l: function (n) {\n        return {\n          D: n[1] || void 0,\n          F: n[2]\n        };\n      },\n      v: function (n, r, t) {\n        return G(\"img\", {\n          key: t.h,\n          alt: n.D,\n          src: Rn(rn[n.F].R),\n          title: rn[n.F].N\n        });\n      }\n    },\n    refLink: {\n      t: Ln(C),\n      _: Nn.MAX,\n      l: function (n, r, t) {\n        return {\n          S: r(n[1], t),\n          P: r(n[0].replace(D, \"\\\\$1\"), t),\n          F: n[2]\n        };\n      },\n      v: function (n, r, t) {\n        return rn[n.F] ? G(\"a\", {\n          key: t.h,\n          href: Rn(rn[n.F].R),\n          title: rn[n.F].N\n        }, r(n.S, t)) : G(\"span\", {\n          key: t.h\n        }, r(n.P, t));\n      }\n    },\n    table: {\n      t: In(R),\n      _: Nn.HIGH,\n      l: An,\n      v: function (n, r, t) {\n        return G(\"table\", {\n          key: t.h\n        }, G(\"thead\", null, G(\"tr\", null, n.L.map(function (e, o) {\n          return G(\"th\", {\n            key: o,\n            style: En(n, o)\n          }, r(e, t));\n        }))), G(\"tbody\", null, n.A.map(function (e, o) {\n          return G(\"tr\", {\n            key: o\n          }, e.map(function (e, o) {\n            return G(\"td\", {\n              key: o,\n              style: En(n, o)\n            }, r(e, t));\n          }));\n        })));\n      }\n    },\n    tableSeparator: {\n      t: function (n, r) {\n        return r.k ? F.exec(n) : null;\n      },\n      _: Nn.HIGH,\n      l: function () {\n        return {\n          type: \"tableSeparator\"\n        };\n      },\n      v: function () {\n        return \" | \";\n      }\n    },\n    text: {\n      t: On(K),\n      _: Nn.MIN,\n      l: function (n) {\n        return {\n          S: n[0].replace(z, function (n, r) {\n            return i.namedCodesToUnicode[r] ? i.namedCodesToUnicode[r] : n;\n          })\n        };\n      },\n      v: function (n) {\n        return n.S;\n      }\n    },\n    textBolded: {\n      t: Mn(V),\n      _: Nn.MED,\n      l: function (n, r, t) {\n        return {\n          S: r(n[2], t)\n        };\n      },\n      v: function (n, r, t) {\n        return G(\"strong\", {\n          key: t.h\n        }, r(n.S, t));\n      }\n    },\n    textEmphasized: {\n      t: Mn(W),\n      _: Nn.LOW,\n      l: function (n, r, t) {\n        return {\n          S: r(n[2], t)\n        };\n      },\n      v: function (n, r, t) {\n        return G(\"em\", {\n          key: t.h\n        }, r(n.S, t));\n      }\n    },\n    textEscaped: {\n      t: Mn(J),\n      _: Nn.HIGH,\n      l: function (n) {\n        return {\n          S: n[1],\n          type: \"text\"\n        };\n      }\n    },\n    textMarked: {\n      t: Mn(Q),\n      _: Nn.LOW,\n      l: Zn,\n      v: function (n, r, t) {\n        return G(\"mark\", {\n          key: t.h\n        }, r(n.S, t));\n      }\n    },\n    textStrikethroughed: {\n      t: Mn(X),\n      _: Nn.LOW,\n      l: Zn,\n      v: function (n, r, t) {\n        return G(\"del\", {\n          key: t.h\n        }, r(n.S, t));\n      }\n    }\n  };\n  !0 !== i.disableParsingRawHTML && (tn.htmlBlock = {\n    t: On($),\n    _: Nn.HIGH,\n    l: function (n, r, t) {\n      var e,\n          o = n[3].match(nn),\n          a = new RegExp(\"^\" + o[1], \"gm\"),\n          c = n[3].replace(a, \"\"),\n          i = (e = c, Sn.some(function (n) {\n        return n.test(e);\n      }) ? Dn : jn),\n          _ = n[1].toLowerCase(),\n          f = -1 !== u.indexOf(_);\n\n      t.Z = t.Z || \"a\" === _;\n      var l = f ? n[3] : i(r, c, t);\n      return t.Z = !1, {\n        I: q(n[2]),\n        S: l,\n        G: f,\n        H: f ? _ : n[1]\n      };\n    },\n    v: function (n, t, e) {\n      return G(n.H, r({\n        key: e.h\n      }, n.I), n.G ? n.S : t(n.S, e));\n    }\n  }, tn.htmlSelfClosing = {\n    t: On(E),\n    _: Nn.HIGH,\n    l: function (n) {\n      return {\n        I: q(n[2] || \"\"),\n        H: n[1]\n      };\n    },\n    v: function (n, t, e) {\n      return G(n.H, r({}, n.I, {\n        key: e.h\n      }));\n    }\n  });\n\n  var en,\n      on = function (n) {\n    var r = Object.keys(n);\n\n    function t(e, o) {\n      for (var u = [], a = \"\"; e;) for (var c = 0; c < r.length;) {\n        var i = r[c],\n            _ = n[i],\n            f = _.t(e, o, a);\n\n        if (f) {\n          var l = f[0];\n          e = e.substring(l.length);\n\n          var s = _.l(f, t, o);\n\n          null == s.type && (s.type = i), u.push(s), a = l;\n          break;\n        }\n\n        c++;\n      }\n\n      return u;\n    }\n\n    return r.sort(function (r, t) {\n      var e = n[r]._,\n          o = n[t]._;\n      return e !== o ? e - o : r < t ? -1 : 1;\n    }), function (n, r) {\n      return t(function (n) {\n        return n.replace(v, \"\\n\").replace(k, \"\").replace(Z, \"    \");\n      }(n), r);\n    };\n  }(tn),\n      un = (en = function (n) {\n    return function (r, t, e) {\n      return n[r.type].v(r, t, e);\n    };\n  }(tn), function n(r, t) {\n    if (void 0 === t && (t = {}), Array.isArray(r)) {\n      for (var e = t.h, o = [], u = !1, a = 0; a < r.length; a++) {\n        t.h = a;\n        var c = n(r[a], t),\n            i = \"string\" == typeof c;\n        i && u ? o[o.length - 1] += c : null !== c && o.push(c), u = i;\n      }\n\n      return t.h = e, o;\n    }\n\n    return en(r, n, t);\n  }),\n      an = H(t);\n\n  return U.length ? G(\"div\", null, an, G(\"footer\", {\n    key: \"footer\"\n  }, U.map(function (n) {\n    return G(\"div\", {\n      id: i.slugify(n.B),\n      key: n.B\n    }, n.B, un(on(n.O, {\n      u: !0\n    })));\n  }))) : an;\n}\n\n!function (n) {\n  n[n.MAX = 0] = \"MAX\", n[n.HIGH = 1] = \"HIGH\", n[n.MED = 2] = \"MED\", n[n.LOW = 3] = \"LOW\", n[n.MIN = 4] = \"MIN\";\n}(Nn || (Nn = {}));\nexport default function (r) {\n  var e = r.children,\n      o = r.options,\n      u = function (n, r) {\n    if (null == n) return {};\n    var t,\n        e,\n        o = {},\n        u = Object.keys(n);\n\n    for (e = 0; e < u.length; e++) r.indexOf(t = u[e]) >= 0 || (o[t] = n[t]);\n\n    return o;\n  }(r, t);\n\n  return n.cloneElement(Un(e, o), u);\n}\nexport { Un as compiler };","map":{"version":3,"sources":["../index.tsx"],"names":["ATTRIBUTE_TO_JSX_PROP_MAP","reduce","obj","x","toLowerCase","for","namedCodesToUnicode","amp","apos","gt","lt","nbsp","quot","DO_NOT_PROCESS_HTML_ELEMENTS","ATTR_EXTRACTOR_R","AUTOLINK_MAILTO_CHECK_R","BLOCK_END_R","BLOCKQUOTE_R","BLOCKQUOTE_TRIM_LEFT_MULTILINE_R","BREAK_LINE_R","BREAK_THEMATIC_R","CODE_BLOCK_FENCED_R","CODE_BLOCK_R","CODE_INLINE_R","CONSECUTIVE_NEWLINE_R","CR_NEWLINE_R","FOOTNOTE_R","FOOTNOTE_REFERENCE_R","FORMFEED_R","GFM_TASK_R","HEADING_R","HEADING_SETEXT_R","HTML_BLOCK_ELEMENT_R","HTML_CHAR_CODE_R","HTML_COMMENT_R","HTML_CUSTOM_ATTR_R","HTML_SELF_CLOSING_ELEMENT_R","INTERPOLATION_R","LINK_AUTOLINK_BARE_URL_R","LINK_AUTOLINK_MAILTO_R","LINK_AUTOLINK_R","CAPTURE_LETTER_AFTER_HYPHEN","NP_TABLE_R","REFERENCE_IMAGE_OR_LINK","REFERENCE_IMAGE_R","REFERENCE_LINK_R","SQUARE_BRACKETS_R","SHOULD_RENDER_AS_BLOCK_R","TAB_R","TABLE_SEPARATOR_R","TABLE_TRIM_PIPES","TABLE_CELL_END_TRIM","TABLE_CENTER_ALIGN","TABLE_LEFT_ALIGN","TABLE_RIGHT_ALIGN","TEXT_BOLD_R","TEXT_EMPHASIZED_R","TEXT_MARKED_R","TEXT_STRIKETHROUGHED_R","TEXT_ESCAPED_R","TEXT_PLAIN_R","TRIM_STARTING_NEWLINES","HTML_LEFT_TRIM_AMOUNT_R","UNESCAPE_URL_R","LIST_ITEM_END_R","LIST_LOOKBEHIND_R","ORDERED_LIST_BULLET","UNORDERED_LIST_BULLET","generateListItemPrefix","type","ORDERED_LIST_ITEM_PREFIX","UNORDERED_LIST_ITEM_PREFIX","generateListItemPrefixRegex","RegExp","ORDERED_LIST_ITEM_PREFIX_R","UNORDERED_LIST_ITEM_PREFIX_R","generateListItemRegex","ORDERED_LIST_ITEM_R","UNORDERED_LIST_ITEM_R","generateListRegex","bullet","ORDERED_LIST_R","UNORDERED_LIST_R","generateListRule","h","ordered","LIST_R","LIST_ITEM_R","LIST_ITEM_PREFIX_R","_match","source","state","prevCapture","isStartOfLine","exec","_list","_inline","_simple","_order","Priority","HIGH","_parse","capture","parse","start","undefined","items","replace","match","lastItemWasAParagraph","map","item","i","space","length","spaceRegex","content","isLastItem","indexOf","thisItemIsAParagraph","oldStateInline","oldStateList","adjustedContent","result","_items","_ordered","_start","_react","node","output","key","_key","LINK_R","IMAGE_R","NON_PARAGRAPH_BLOCK_SYNTAXES","BLOCK_SYNTAXES","input","some","r","test","str","first","slice","slugify","parseTableAlignCapture","alignCapture","parseTableRow","prevInTable","_inTable","tableRow","trim","cells","forEach","push","_content","split","rowText","parseTable","header","align","parseTableCells","_align","_cells","_header","getTableStyle","colIndex","textAlign","_","letter","toUpperCase","value","styles","kvPair","substr","sanitizeUrl","rules","ruleList","Object","keys","sort","typeA","typeB","orderA","orderB","nestedParse","ruleType","rule","currCaptureString","substring","parsed","normalizeWhitespace","inlineRegex","regex","simpleInlineRegex","blockRegex","anyScopeRegex","matchParagraph","prevCapturedString","endsWith","every","line","captured","trimEnd","outputFunc","nestedReactOutput","ast","Array","isArray","oldKey","lastWasString","nodeOut","isString","url","decodeURIComponent","e","unescapeUrl","rawUrlString","parseInline","isCurrentlyInline","isCurrentlySimple","parseSimpleInline","parseBlock","parseCaptureInline","captureNothing","renderNothing","cx","filter","Boolean","join","get","src","path","fb","ptr","frags","shift","getTag","tag","overrides","override","compiler","markdown","options","createElementFn","createElement","React","props","overrideProps","className","compile","forceInline","forceBlock","arr","emitter","parser","pop","wrapper","jsx","forceWrapper","attrStringToMap","attributes","raw","index","delimiterIdx","normalizeAttributeKey","unquote","mappedKey","normalizedValue","attributeValueToJSXPropValue","cloneElement","footnotes","refs","blockQuote","breakLine","__","breakThematic","codeBlock","MAX","_lang","_attrs","codeFenced","codeInline","LOW","footnote","_footnote","_identifier","footnoteReference","_target","href","gfmTask","_completed","checked","readOnly","heading","_id","_level","id","headingSetext","htmlComment","image","_alt","_title","alt","title","link","linkAngleBraceStyleDetector","linkBareUrlDetector","_inAnchor","linkMailtoDetector","address","target","orderedList","unorderedList","newlineCoalescer","paragraph","ref","refImage","_ref","refLink","_fallbackContent","table","style","row","c","tableSeparator","text","MIN","full","inner","textBolded","MED","textEmphasized","textEscaped","textMarked","textStrikethroughed","disableParsingRawHTML","htmlBlock","trimmer","trimmed","parseFunc","tagName","noInnerParse","_noInnerParse","_tag","htmlSelfClosing","parserFor","ruleOutput","def","children"],"mappings":"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","sourcesContent":["/* @jsx h */\n/**\n * markdown-to-jsx is a fork of [simple-markdown v0.2.2](https://github.com/Khan/simple-markdown)\n * from Khan Academy. Thank you Khan devs for making such an awesome and extensible\n * parsing infra... without it, half of the optimizations here wouldn't be feasible. 🙏🏼\n */\nimport * as React from 'react'\n\nexport namespace MarkdownToJSX {\n  /**\n   * RequireAtLeastOne<{ ... }> <- only requires at least one key\n   */\n  type RequireAtLeastOne<T, Keys extends keyof T = keyof T> = Pick<\n    T,\n    Exclude<keyof T, Keys>\n  > &\n    {\n      [K in Keys]-?: Required<Pick<T, K>> & Partial<Pick<T, Exclude<Keys, K>>>\n    }[Keys]\n\n  export type CreateElement = typeof React.createElement\n\n  export type HTMLTags = keyof JSX.IntrinsicElements\n\n  export type State = {\n    _inAnchor?: boolean\n    _inline?: boolean\n    _inTable?: boolean\n    _key?: React.Key\n    _list?: boolean\n    _simple?: boolean\n  }\n\n  export type ParserResult = {\n    [key: string]: any\n    type?: string\n  }\n\n  export type NestedParser = (\n    input: string,\n    state?: MarkdownToJSX.State\n  ) => MarkdownToJSX.ParserResult\n\n  export type Parser<ParserOutput> = (\n    capture: RegExpMatchArray,\n    nestedParse: NestedParser,\n    state?: MarkdownToJSX.State\n  ) => ParserOutput\n\n  export type RuleOutput = (\n    ast: MarkdownToJSX.ParserResult,\n    state: MarkdownToJSX.State\n  ) => JSX.Element\n\n  export type Rule<ParserOutput = MarkdownToJSX.ParserResult> = {\n    _match: (\n      source: string,\n      state: MarkdownToJSX.State,\n      prevCapturedString?: string\n    ) => RegExpMatchArray\n    _order: Priority\n    _parse: MarkdownToJSX.Parser<ParserOutput>\n    _react?: (\n      node: ParserOutput,\n      output: RuleOutput,\n      state?: MarkdownToJSX.State\n    ) => React.ReactChild\n  }\n\n  export type Rules = {\n    [key: string]: Rule\n  }\n\n  export type Override =\n    | RequireAtLeastOne<{\n        component: React.ElementType\n        props: Object\n      }>\n    | React.ElementType\n\n  export type Overrides = {\n    [tag in HTMLTags]?: Override\n  } & {\n    [customComponent: string]: Override\n  }\n\n  export type Options = Partial<{\n    /**\n     * Ultimate control over the output of all rendered JSX.\n     */\n    createElement: (\n      tag: Parameters<CreateElement>[0],\n      props: JSX.IntrinsicAttributes,\n      ...children: React.ReactChild[]\n    ) => JSX.Element\n\n    /**\n     * Disable the compiler's best-effort transcription of provided raw HTML\n     * into JSX-equivalent. This is the functionality that prevents the need to\n     * use `dangerouslySetInnerHTML` in React.\n     */\n    disableParsingRawHTML: boolean\n\n    /**\n     * Forces the compiler to always output content with a block-level wrapper\n     * (`<p>` or any block-level syntax your markdown already contains.)\n     */\n    forceBlock: boolean\n\n    /**\n     * Forces the compiler to always output content with an inline wrapper (`<span>`)\n     */\n    forceInline: boolean\n\n    /**\n     * Supply additional HTML entity: unicode replacement mappings.\n     *\n     * Pass only the inner part of the entity as the key,\n     * e.g. `&le;` -> `{ \"le\": \"\\u2264\" }`\n     *\n     * By default\n     * the following entities are replaced with their unicode equivalents:\n     *\n     * ```\n     * &amp;\n     * &apos;\n     * &gt;\n     * &lt;\n     * &nbsp;\n     * &quot;\n     * ```\n     */\n    namedCodesToUnicode: {\n      [key: string]: string\n    }\n\n    /**\n     * Selectively control the output of particular HTML tags as they would be\n     * emitted by the compiler.\n     */\n    overrides: Overrides\n\n    /**\n     * Declare the type of the wrapper to be used when there are multiple\n     * children to render. Set to `null` to get an array of children back\n     * without any wrapper, or use `React.Fragment` to get a React element\n     * that won't show up in the DOM.\n     */\n    wrapper: React.ElementType | null\n\n    /**\n     * Forces the compiler to wrap results, even if there is only a single\n     * child or no children.\n     */\n    forceWrapper: boolean\n\n    /**\n     * Override normalization of non-URI-safe characters for use in generating\n     * HTML IDs for anchor linking purposes.\n     */\n    slugify: (source: string) => string\n  }>\n}\n\n/** TODO: Drop for React 16? */\nconst ATTRIBUTE_TO_JSX_PROP_MAP = [\n  'allowFullScreen',\n  'allowTransparency',\n  'autoComplete',\n  'autoFocus',\n  'autoPlay',\n  'cellPadding',\n  'cellSpacing',\n  'charSet',\n  'className',\n  'classId',\n  'colSpan',\n  'contentEditable',\n  'contextMenu',\n  'crossOrigin',\n  'encType',\n  'formAction',\n  'formEncType',\n  'formMethod',\n  'formNoValidate',\n  'formTarget',\n  'frameBorder',\n  'hrefLang',\n  'inputMode',\n  'keyParams',\n  'keyType',\n  'marginHeight',\n  'marginWidth',\n  'maxLength',\n  'mediaGroup',\n  'minLength',\n  'noValidate',\n  'radioGroup',\n  'readOnly',\n  'rowSpan',\n  'spellCheck',\n  'srcDoc',\n  'srcLang',\n  'srcSet',\n  'tabIndex',\n  'useMap',\n].reduce(\n  (obj, x) => {\n    obj[x.toLowerCase()] = x\n    return obj\n  },\n  { for: 'htmlFor' }\n)\n\nconst namedCodesToUnicode = {\n  amp: '\\u0026',\n  apos: '\\u0027',\n  gt: '\\u003e',\n  lt: '\\u003c',\n  nbsp: '\\u00a0',\n  quot: '\\u201c',\n} as const\n\nconst DO_NOT_PROCESS_HTML_ELEMENTS = ['style', 'script']\n\n/**\n * the attribute extractor regex looks for a valid attribute name,\n * followed by an equal sign (whitespace around the equal sign is allowed), followed\n * by one of the following:\n *\n * 1. a single quote-bounded string, e.g. 'foo'\n * 2. a double quote-bounded string, e.g. \"bar\"\n * 3. an interpolation, e.g. {something}\n *\n * JSX can be be interpolated into itself and is passed through the compiler using\n * the same options and setup as the current run.\n *\n * <Something children={<SomeOtherThing />} />\n *                      ==================\n *                              ↳ children: [<SomeOtherThing />]\n *\n * Otherwise, interpolations are handled as strings or simple booleans\n * unless HTML syntax is detected.\n *\n * <Something color={green} disabled={true} />\n *                   =====            ====\n *                     ↓                ↳ disabled: true\n *                     ↳ color: \"green\"\n *\n * Numbers are not parsed at this time due to complexities around int, float,\n * and the upcoming bigint functionality that would make handling it unwieldy.\n * Parse the string in your component as desired.\n *\n * <Something someBigNumber={123456789123456789} />\n *                           ==================\n *                                   ↳ someBigNumber: \"123456789123456789\"\n */\nconst ATTR_EXTRACTOR_R =\n  /([-A-Z0-9_:]+)(?:\\s*=\\s*(?:(?:\"((?:\\\\.|[^\"])*)\")|(?:'((?:\\\\.|[^'])*)')|(?:\\{((?:\\\\.|{[^}]*?}|[^}])*)\\})))?/gi\n\n/** TODO: Write explainers for each of these */\n\nconst AUTOLINK_MAILTO_CHECK_R = /mailto:/i\nconst BLOCK_END_R = /\\n{2,}$/\nconst BLOCKQUOTE_R = /^( *>[^\\n]+(\\n[^\\n]+)*\\n*)+\\n{2,}/\nconst BLOCKQUOTE_TRIM_LEFT_MULTILINE_R = /^ *> ?/gm\nconst BREAK_LINE_R = /^ {2,}\\n/\nconst BREAK_THEMATIC_R = /^(?:( *[-*_])){3,} *(?:\\n *)+\\n/\nconst CODE_BLOCK_FENCED_R =\n  /^\\s*(`{3,}|~{3,}) *(\\S+)?([^\\n]*?)?\\n([\\s\\S]+?)\\s*\\1 *(?:\\n *)*\\n?/\nconst CODE_BLOCK_R = /^(?: {4}[^\\n]+\\n*)+(?:\\n *)+\\n?/\nconst CODE_INLINE_R = /^(`+)\\s*([\\s\\S]*?[^`])\\s*\\1(?!`)/\nconst CONSECUTIVE_NEWLINE_R = /^(?:\\n *)*\\n/\nconst CR_NEWLINE_R = /\\r\\n?/g\nconst FOOTNOTE_R = /^\\[\\^([^\\]]+)](:.*)\\n/\nconst FOOTNOTE_REFERENCE_R = /^\\[\\^([^\\]]+)]/\nconst FORMFEED_R = /\\f/g\nconst GFM_TASK_R = /^\\s*?\\[(x|\\s)\\]/\nconst HEADING_R = /^ *(#{1,6}) *([^\\n]+?)(?: +#*)?(?:\\n *)*(?:\\n|$)/\nconst HEADING_SETEXT_R = /^([^\\n]+)\\n *(=|-){3,} *(?:\\n *)+\\n/\n\n/**\n * Explanation:\n *\n * 1. Look for a starting tag, preceded by any amount of spaces\n *    ^ *<\n *\n * 2. Capture the tag name (capture 1)\n *    ([^ >/]+)\n *\n * 3. Ignore a space after the starting tag and capture the attribute portion of the tag (capture 2)\n *     ?([^>]*)\\/{0}>\n *\n * 4. Ensure a matching closing tag is present in the rest of the input string\n *    (?=[\\s\\S]*<\\/\\1>)\n *\n * 5. Capture everything until the matching closing tag -- this might include additional pairs\n *    of the same tag type found in step 2 (capture 3)\n *    ((?:[\\s\\S]*?(?:<\\1[^>]*>[\\s\\S]*?<\\/\\1>)*[\\s\\S]*?)*?)<\\/\\1>\n *\n * 6. Capture excess newlines afterward\n *    \\n*\n */\nconst HTML_BLOCK_ELEMENT_R =\n  /^ *(?!<[a-z][^ >/]* ?\\/>)<([a-z][^ >/]*) ?([^>]*)\\/{0}>\\n?(\\s*(?:<\\1[^>]*?>[\\s\\S]*?<\\/\\1>|(?!<\\1)[\\s\\S])*?)<\\/\\1>\\n*/i\n\nconst HTML_CHAR_CODE_R = /&([a-zA-Z]+);/g\n\nconst HTML_COMMENT_R = /^<!--[\\s\\S]*?(?:-->)/\n\n/**\n * borrowed from React 15(https://github.com/facebook/react/blob/894d20744cba99383ffd847dbd5b6e0800355a5c/src/renderers/dom/shared/HTMLDOMPropertyConfig.js)\n */\nconst HTML_CUSTOM_ATTR_R = /^(data|aria|x)-[a-z_][a-z\\d_.-]*$/\n\nconst HTML_SELF_CLOSING_ELEMENT_R =\n  /^ *<([a-z][a-z0-9:]*)(?:\\s+((?:<.*?>|[^>])*))?\\/?>(?!<\\/\\1>)(\\s*\\n)?/i\nconst INTERPOLATION_R = /^\\{.*\\}$/\nconst LINK_AUTOLINK_BARE_URL_R = /^(https?:\\/\\/[^\\s<]+[^<.,:;\"')\\]\\s])/\nconst LINK_AUTOLINK_MAILTO_R = /^<([^ >]+@[^ >]+)>/\nconst LINK_AUTOLINK_R = /^<([^ >]+:\\/[^ >]+)>/\nconst CAPTURE_LETTER_AFTER_HYPHEN = /-([a-z])?/gi\nconst NP_TABLE_R = /^(.*\\|?.*)\\n *(\\|? *[-:]+ *\\|[-| :]*)\\n((?:.*\\|.*\\n)*)\\n?/\nconst PARAGRAPH_R = /^[^\\n]+(?:  \\n|\\n{2,})/\nconst REFERENCE_IMAGE_OR_LINK = /^\\[([^\\]]*)\\]:\\s+<?([^\\s>]+)>?\\s*(\"([^\"]*)\")?/\nconst REFERENCE_IMAGE_R = /^!\\[([^\\]]*)\\] ?\\[([^\\]]*)\\]/\nconst REFERENCE_LINK_R = /^\\[([^\\]]*)\\] ?\\[([^\\]]*)\\]/\nconst SQUARE_BRACKETS_R = /(\\[|\\])/g\nconst SHOULD_RENDER_AS_BLOCK_R = /(\\n|^[-*]\\s|^#|^ {2,}|^-{2,}|^>\\s)/\nconst TAB_R = /\\t/g\nconst TABLE_SEPARATOR_R = /^ *\\| */\nconst TABLE_TRIM_PIPES = /(^ *\\||\\| *$)/g\nconst TABLE_CELL_END_TRIM = / *$/\nconst TABLE_CENTER_ALIGN = /^ *:-+: *$/\nconst TABLE_LEFT_ALIGN = /^ *:-+ *$/\nconst TABLE_RIGHT_ALIGN = /^ *-+: *$/\n\nconst TEXT_BOLD_R =\n  /^([*_])\\1((?:\\[.*?\\][([].*?[)\\]]|<.*?>(?:.*?<.*?>)?|`.*?`|~+.*?~+|.)*?)\\1\\1(?!\\1)/\nconst TEXT_EMPHASIZED_R =\n  /^([*_])((?:\\[.*?\\][([].*?[)\\]]|<.*?>(?:.*?<.*?>)?|`.*?`|~+.*?~+|.)*?)\\1(?!\\1|\\w)/\nconst TEXT_MARKED_R = /^==((?:\\[.*?\\]|<.*?>(?:.*?<.*?>)?|`.*?`|.)*?)==/\nconst TEXT_STRIKETHROUGHED_R = /^~~((?:\\[.*?\\]|<.*?>(?:.*?<.*?>)?|`.*?`|.)*?)~~/\n\nconst TEXT_ESCAPED_R = /^\\\\([^0-9A-Za-z\\s])/\nconst TEXT_PLAIN_R =\n  /^[\\s\\S]+?(?=[^0-9A-Z\\s\\u00c0-\\uffff&;.()'\"]|\\d+\\.|\\n\\n| {2,}\\n|\\w+:\\S|$)/i\n\nconst TRIM_STARTING_NEWLINES = /^\\n+/\n\nconst HTML_LEFT_TRIM_AMOUNT_R = /^([ \\t]*)/\n\nconst UNESCAPE_URL_R = /\\\\([^\\\\])/g\n\ntype LIST_TYPE = 1 | 2\nconst ORDERED: LIST_TYPE = 1\nconst UNORDERED: LIST_TYPE = 2\n\nconst LIST_ITEM_END_R = / *\\n+$/\nconst LIST_LOOKBEHIND_R = /(?:^|\\n)( *)$/\n\n// recognize a `*` `-`, `+`, `1.`, `2.`... list bullet\nconst ORDERED_LIST_BULLET = '(?:\\\\d+\\\\.)'\nconst UNORDERED_LIST_BULLET = '(?:[*+-])'\n\nfunction generateListItemPrefix(type: LIST_TYPE) {\n  return (\n    '( *)(' +\n    (type === ORDERED ? ORDERED_LIST_BULLET : UNORDERED_LIST_BULLET) +\n    ') +'\n  )\n}\n\n// recognize the start of a list item:\n// leading space plus a bullet plus a space (`   * `)\nconst ORDERED_LIST_ITEM_PREFIX = generateListItemPrefix(ORDERED)\nconst UNORDERED_LIST_ITEM_PREFIX = generateListItemPrefix(UNORDERED)\n\nfunction generateListItemPrefixRegex(type: LIST_TYPE) {\n  return new RegExp(\n    '^' +\n      (type === ORDERED ? ORDERED_LIST_ITEM_PREFIX : UNORDERED_LIST_ITEM_PREFIX)\n  )\n}\n\nconst ORDERED_LIST_ITEM_PREFIX_R = generateListItemPrefixRegex(ORDERED)\nconst UNORDERED_LIST_ITEM_PREFIX_R = generateListItemPrefixRegex(UNORDERED)\n\nfunction generateListItemRegex(type: LIST_TYPE) {\n  // recognize an individual list item:\n  //  * hi\n  //    this is part of the same item\n  //\n  //    as is this, which is a new paragraph in the same item\n  //\n  //  * but this is not part of the same item\n  return new RegExp(\n    '^' +\n      (type === ORDERED\n        ? ORDERED_LIST_ITEM_PREFIX\n        : UNORDERED_LIST_ITEM_PREFIX) +\n      '[^\\\\n]*(?:\\\\n' +\n      '(?!\\\\1' +\n      (type === ORDERED ? ORDERED_LIST_BULLET : UNORDERED_LIST_BULLET) +\n      ' )[^\\\\n]*)*(\\\\n|$)',\n    'gm'\n  )\n}\n\nconst ORDERED_LIST_ITEM_R = generateListItemRegex(ORDERED)\nconst UNORDERED_LIST_ITEM_R = generateListItemRegex(UNORDERED)\n\n// check whether a list item has paragraphs: if it does,\n// we leave the newlines at the end\nfunction generateListRegex(type: LIST_TYPE) {\n  const bullet = type === ORDERED ? ORDERED_LIST_BULLET : UNORDERED_LIST_BULLET\n\n  return new RegExp(\n    '^( *)(' +\n      bullet +\n      ') ' +\n      '[\\\\s\\\\S]+?(?:\\\\n{2,}(?! )' +\n      '(?!\\\\1' +\n      bullet +\n      ' (?!' +\n      bullet +\n      ' ))\\\\n*' +\n      // the \\\\s*$ here is so that we can parse the inside of nested\n      // lists, where our content might end before we receive two `\\n`s\n      '|\\\\s*\\\\n*$)'\n  )\n}\n\nconst ORDERED_LIST_R = generateListRegex(ORDERED)\nconst UNORDERED_LIST_R = generateListRegex(UNORDERED)\n\nfunction generateListRule(h: any, type: LIST_TYPE) {\n  const ordered = type === ORDERED\n  const LIST_R = ordered ? ORDERED_LIST_R : UNORDERED_LIST_R\n  const LIST_ITEM_R = ordered ? ORDERED_LIST_ITEM_R : UNORDERED_LIST_ITEM_R\n  const LIST_ITEM_PREFIX_R = ordered\n    ? ORDERED_LIST_ITEM_PREFIX_R\n    : UNORDERED_LIST_ITEM_PREFIX_R\n\n  return {\n    _match(source, state, prevCapture) {\n      // We only want to break into a list if we are at the start of a\n      // line. This is to avoid parsing \"hi * there\" with \"* there\"\n      // becoming a part of a list.\n      // You might wonder, \"but that's inline, so of course it wouldn't\n      // start a list?\". You would be correct! Except that some of our\n      // lists can be inline, because they might be inside another list,\n      // in which case we can parse with inline scope, but need to allow\n      // nested lists inside this inline scope.\n      const isStartOfLine = LIST_LOOKBEHIND_R.exec(prevCapture)\n      const isListBlock = state._list || (!state._inline && !state._simple)\n\n      if (isStartOfLine && isListBlock) {\n        source = isStartOfLine[1] + source\n\n        return LIST_R.exec(source)\n      } else {\n        return null\n      }\n    },\n    _order: Priority.HIGH,\n    _parse(capture, parse, state) {\n      const bullet = capture[2]\n      const start = ordered ? +bullet : undefined\n      const items = capture[0]\n        // recognize the end of a paragraph block inside a list item:\n        // two or more newlines at end end of the item\n        .replace(BLOCK_END_R, '\\n')\n        .match(LIST_ITEM_R)\n\n      let lastItemWasAParagraph = false\n      const itemContent = items.map(function (item, i) {\n        // We need to see how far indented the item is:\n        const space = LIST_ITEM_PREFIX_R.exec(item)[0].length\n\n        // And then we construct a regex to \"unindent\" the subsequent\n        // lines of the items by that amount:\n        const spaceRegex = new RegExp('^ {1,' + space + '}', 'gm')\n\n        // Before processing the item, we need a couple things\n        const content = item\n          // remove indents on trailing lines:\n          .replace(spaceRegex, '')\n          // remove the bullet:\n          .replace(LIST_ITEM_PREFIX_R, '')\n\n        // Handling \"loose\" lists, like:\n        //\n        //  * this is wrapped in a paragraph\n        //\n        //  * as is this\n        //\n        //  * as is this\n        const isLastItem = i === items.length - 1\n        const containsBlocks = content.indexOf('\\n\\n') !== -1\n\n        // Any element in a list is a block if it contains multiple\n        // newlines. The last element in the list can also be a block\n        // if the previous item in the list was a block (this is\n        // because non-last items in the list can end with \\n\\n, but\n        // the last item can't, so we just \"inherit\" this property\n        // from our previous element).\n        const thisItemIsAParagraph =\n          containsBlocks || (isLastItem && lastItemWasAParagraph)\n        lastItemWasAParagraph = thisItemIsAParagraph\n\n        // backup our state for restoration afterwards. We're going to\n        // want to set state._list to true, and state._inline depending\n        // on our list's looseness.\n        const oldStateInline = state._inline\n        const oldStateList = state._list\n        state._list = true\n\n        // Parse inline if we're in a tight list, or block if we're in\n        // a loose list.\n        let adjustedContent\n        if (thisItemIsAParagraph) {\n          state._inline = false\n          adjustedContent = content.replace(LIST_ITEM_END_R, '\\n\\n')\n        } else {\n          state._inline = true\n          adjustedContent = content.replace(LIST_ITEM_END_R, '')\n        }\n\n        const result = parse(adjustedContent, state)\n\n        // Restore our state before returning\n        state._inline = oldStateInline\n        state._list = oldStateList\n\n        return result\n      })\n\n      return {\n        _items: itemContent,\n        _ordered: ordered,\n        _start: start,\n      }\n    },\n    _react(node, output, state) {\n      const Tag = node._ordered ? 'ol' : 'ul'\n\n      return (\n        <Tag key={state._key} start={node._start}>\n          {node._items.map(function generateListItem(item, i) {\n            return <li key={i}>{output(item, state)}</li>\n          })}\n        </Tag>\n      )\n    },\n  } as MarkdownToJSX.Rule<{\n    _items: MarkdownToJSX.ParserResult[]\n    _ordered: boolean\n    _start?: number\n  }>\n}\n\nconst LINK_R = /^\\[([^\\]]*)]\\( *((?:\\([^)]*\\)|[^() ])*) *\"?([^)\"]*)?\"?\\)/\nconst IMAGE_R = /^!\\[([^\\]]*)]\\( *((?:\\([^)]*\\)|[^() ])*) *\"?([^)\"]*)?\"?\\)/\n\nconst NON_PARAGRAPH_BLOCK_SYNTAXES = [\n  BLOCKQUOTE_R,\n  CODE_BLOCK_FENCED_R,\n  CODE_BLOCK_R,\n  HEADING_R,\n  HEADING_SETEXT_R,\n  HTML_COMMENT_R,\n  NP_TABLE_R,\n  ORDERED_LIST_ITEM_R,\n  ORDERED_LIST_R,\n  UNORDERED_LIST_ITEM_R,\n  UNORDERED_LIST_R,\n]\n\nconst BLOCK_SYNTAXES = [\n  ...NON_PARAGRAPH_BLOCK_SYNTAXES,\n  PARAGRAPH_R,\n  HTML_BLOCK_ELEMENT_R,\n  HTML_SELF_CLOSING_ELEMENT_R,\n]\n\nfunction containsBlockSyntax(input: string) {\n  return BLOCK_SYNTAXES.some(r => r.test(input))\n}\n\n/** Remove symmetrical leading and trailing quotes */\nfunction unquote(str: string) {\n  const first = str[0]\n  if (\n    (first === '\"' || first === \"'\") &&\n    str.length >= 2 &&\n    str[str.length - 1] === first\n  ) {\n    return str.slice(1, -1)\n  }\n  return str\n}\n\n// based on https://stackoverflow.com/a/18123682/1141611\n// not complete, but probably good enough\nfunction slugify(str: string) {\n  return str\n    .replace(/[ÀÁÂÃÄÅàáâãäåæÆ]/g, 'a')\n    .replace(/[çÇ]/g, 'c')\n    .replace(/[ðÐ]/g, 'd')\n    .replace(/[ÈÉÊËéèêë]/g, 'e')\n    .replace(/[ÏïÎîÍíÌì]/g, 'i')\n    .replace(/[Ññ]/g, 'n')\n    .replace(/[øØœŒÕõÔôÓóÒò]/g, 'o')\n    .replace(/[ÜüÛûÚúÙù]/g, 'u')\n    .replace(/[ŸÿÝý]/g, 'y')\n    .replace(/[^a-z0-9- ]/gi, '')\n    .replace(/ /gi, '-')\n    .toLowerCase()\n}\n\nfunction parseTableAlignCapture(alignCapture: string) {\n  if (TABLE_RIGHT_ALIGN.test(alignCapture)) {\n    return 'right'\n  } else if (TABLE_CENTER_ALIGN.test(alignCapture)) {\n    return 'center'\n  } else if (TABLE_LEFT_ALIGN.test(alignCapture)) {\n    return 'left'\n  }\n\n  return null\n}\n\nfunction parseTableRow(\n  source: string,\n  parse: MarkdownToJSX.NestedParser,\n  state: MarkdownToJSX.State\n) {\n  const prevInTable = state._inTable\n  state._inTable = true\n  const tableRow = parse(source.trim(), state)\n  state._inTable = prevInTable\n\n  let cells = [[]]\n  tableRow.forEach(function (node, i) {\n    if (node.type === 'tableSeparator') {\n      // Filter out empty table separators at the start/end:\n      if (i !== 0 && i !== tableRow.length - 1) {\n        // Split the current row:\n        cells.push([])\n      }\n    } else {\n      if (\n        node.type === 'text' &&\n        (tableRow[i + 1] == null || tableRow[i + 1].type === 'tableSeparator')\n      ) {\n        node._content = node._content.replace(TABLE_CELL_END_TRIM, '')\n      }\n      cells[cells.length - 1].push(node)\n    }\n  })\n  return cells\n}\n\nfunction parseTableAlign(source: string /*, parse, state*/) {\n  const alignText = source.replace(TABLE_TRIM_PIPES, '').split('|')\n\n  return alignText.map(parseTableAlignCapture)\n}\n\nfunction parseTableCells(\n  source: string,\n  parse: MarkdownToJSX.NestedParser,\n  state: MarkdownToJSX.State\n) {\n  const rowsText = source.trim().split('\\n')\n\n  return rowsText.map(function (rowText) {\n    return parseTableRow(rowText, parse, state)\n  })\n}\n\nfunction parseTable(\n  capture: RegExpMatchArray,\n  parse: MarkdownToJSX.NestedParser,\n  state: MarkdownToJSX.State\n) {\n  state._inline = true\n  const header = parseTableRow(capture[1], parse, state)\n  const align = parseTableAlign(capture[2])\n  const cells = parseTableCells(capture[3], parse, state)\n  state._inline = false\n\n  return {\n    _align: align,\n    _cells: cells,\n    _header: header,\n    type: 'table',\n  }\n}\n\nfunction getTableStyle(node, colIndex) {\n  return node._align[colIndex] == null\n    ? {}\n    : {\n        textAlign: node._align[colIndex],\n      }\n}\n\n/** TODO: remove for react 16 */\nfunction normalizeAttributeKey(key) {\n  const hyphenIndex = key.indexOf('-')\n\n  if (hyphenIndex !== -1 && key.match(HTML_CUSTOM_ATTR_R) === null) {\n    key = key.replace(CAPTURE_LETTER_AFTER_HYPHEN, function (_, letter) {\n      return letter.toUpperCase()\n    })\n  }\n\n  return key\n}\n\nfunction attributeValueToJSXPropValue(\n  key: keyof React.AllHTMLAttributes<Element>,\n  value: string\n): any {\n  if (key === 'style') {\n    return value.split(/;\\s?/).reduce(function (styles, kvPair) {\n      const key = kvPair.slice(0, kvPair.indexOf(':'))\n\n      // snake-case to camelCase\n      // also handles PascalCasing vendor prefixes\n      const camelCasedKey = key.replace(/(-[a-z])/g, substr =>\n        substr[1].toUpperCase()\n      )\n\n      // key.length + 1 to skip over the colon\n      styles[camelCasedKey] = kvPair.slice(key.length + 1).trim()\n\n      return styles\n    }, {})\n  } else if (key === 'href') {\n    return sanitizeUrl(value)\n  } else if (value.match(INTERPOLATION_R)) {\n    // return as a string and let the consumer decide what to do with it\n    value = value.slice(1, value.length - 1)\n  }\n\n  if (value === 'true') {\n    return true\n  } else if (value === 'false') {\n    return false\n  }\n\n  return value\n}\n\nfunction normalizeWhitespace(source: string): string {\n  return source\n    .replace(CR_NEWLINE_R, '\\n')\n    .replace(FORMFEED_R, '')\n    .replace(TAB_R, '    ')\n}\n\n/**\n * Creates a parser for a given set of rules, with the precedence\n * specified as a list of rules.\n *\n * @rules: an object containing\n * rule type -> {match, order, parse} objects\n * (lower order is higher precedence)\n * (Note: `order` is added to defaultRules after creation so that\n *  the `order` of defaultRules in the source matches the `order`\n *  of defaultRules in terms of `order` fields.)\n *\n * @returns The resulting parse function, with the following parameters:\n *   @source: the input source string to be parsed\n *   @state: an optional object to be threaded through parse\n *     calls. Allows clients to add stateful operations to\n *     parsing, such as keeping track of how many levels deep\n *     some nesting is. For an example use-case, see passage-ref\n *     parsing in src/widgets/passage/passage-markdown.jsx\n */\nfunction parserFor(\n  rules: MarkdownToJSX.Rules\n): (\n  source: string,\n  state: MarkdownToJSX.State\n) => ReturnType<MarkdownToJSX.NestedParser> {\n  // Sorts rules in order of increasing order, then\n  // ascending rule name in case of ties.\n  let ruleList = Object.keys(rules)\n\n  /* istanbul ignore next */\n  if (process.env.NODE_ENV !== 'production') {\n    ruleList.forEach(function (type) {\n      let order = rules[type]._order\n      if (\n        process.env.NODE_ENV !== 'production' &&\n        (typeof order !== 'number' || !isFinite(order))\n      ) {\n        console.warn(\n          'markdown-to-jsx: Invalid order for rule `' + type + '`: ' + order\n        )\n      }\n    })\n  }\n\n  ruleList.sort(function (typeA, typeB) {\n    let orderA = rules[typeA]._order\n    let orderB = rules[typeB]._order\n\n    // First sort based on increasing order\n    if (orderA !== orderB) {\n      return orderA - orderB\n\n      // Then based on increasing unicode lexicographic ordering\n    } else if (typeA < typeB) {\n      return -1\n    }\n\n    return 1\n  })\n\n  function nestedParse(\n    source: string,\n    state: MarkdownToJSX.State\n  ): MarkdownToJSX.ParserResult[] {\n    let result = []\n\n    // We store the previous capture so that match functions can\n    // use some limited amount of lookbehind. Lists use this to\n    // ensure they don't match arbitrary '- ' or '* ' in inline\n    // text (see the list rule for more information).\n    let prevCapture = ''\n    while (source) {\n      let i = 0\n      while (i < ruleList.length) {\n        const ruleType = ruleList[i]\n        const rule = rules[ruleType]\n        const capture = rule._match(source, state, prevCapture)\n\n        if (capture) {\n          const currCaptureString = capture[0]\n          source = source.substring(currCaptureString.length)\n          const parsed = rule._parse(capture, nestedParse, state)\n\n          // We also let rules override the default type of\n          // their parsed node if they would like to, so that\n          // there can be a single output function for all links,\n          // even if there are several rules to parse them.\n          if (parsed.type == null) {\n            parsed.type = ruleType\n          }\n\n          result.push(parsed)\n\n          prevCapture = currCaptureString\n          break\n        }\n\n        i++\n      }\n    }\n\n    return result\n  }\n\n  return function outerParse(source, state) {\n    return nestedParse(normalizeWhitespace(source), state)\n  }\n}\n\n// Creates a match function for an inline scoped or simple element from a regex\nfunction inlineRegex(regex: RegExp) {\n  return function match(source, state: MarkdownToJSX.State) {\n    if (state._inline) {\n      return regex.exec(source)\n    } else {\n      return null\n    }\n  }\n}\n\n// basically any inline element except links\nfunction simpleInlineRegex(regex: RegExp) {\n  return function match(source: string, state: MarkdownToJSX.State) {\n    if (state._inline || state._simple) {\n      return regex.exec(source)\n    } else {\n      return null\n    }\n  }\n}\n\n// Creates a match function for a block scoped element from a regex\nfunction blockRegex(regex: RegExp) {\n  return function match(source: string, state: MarkdownToJSX.State) {\n    if (state._inline || state._simple) {\n      return null\n    } else {\n      return regex.exec(source)\n    }\n  }\n}\n\n// Creates a match function from a regex, ignoring block/inline scope\nfunction anyScopeRegex(regex: RegExp) {\n  return function match(source: string /*, state*/) {\n    return regex.exec(source)\n  }\n}\n\nfunction matchParagraph(\n  source: string,\n  state: MarkdownToJSX.State,\n  prevCapturedString?: string\n) {\n  if (state._inline || state._simple) {\n    return null\n  }\n\n  if (prevCapturedString && !prevCapturedString.endsWith('\\n')) {\n    // don't match continuation of a line\n    return null\n  }\n\n  let match = ''\n\n  source.split('\\n').every(line => {\n    // bail out on first sign of non-paragraph block\n    if (NON_PARAGRAPH_BLOCK_SYNTAXES.some(regex => regex.test(line))) {\n      return false\n    }\n    match += line + '\\n'\n    return line.trim()\n  })\n\n  const captured = match.trimEnd()\n  if (captured == '') {\n    return null\n  }\n\n  return [match, captured]\n}\n\nfunction reactFor(outputFunc) {\n  return function nestedReactOutput(\n    ast: MarkdownToJSX.ParserResult | MarkdownToJSX.ParserResult[],\n    state: MarkdownToJSX.State = {}\n  ): React.ReactChild[] {\n    if (Array.isArray(ast)) {\n      const oldKey = state._key\n      const result = []\n\n      // map nestedOutput over the ast, except group any text\n      // nodes together into a single string output.\n      let lastWasString = false\n\n      for (let i = 0; i < ast.length; i++) {\n        state._key = i\n\n        const nodeOut = nestedReactOutput(ast[i], state)\n        const isString = typeof nodeOut === 'string'\n\n        if (isString && lastWasString) {\n          result[result.length - 1] += nodeOut\n        } else if (nodeOut !== null) {\n          result.push(nodeOut)\n        }\n\n        lastWasString = isString\n      }\n\n      state._key = oldKey\n\n      return result\n    }\n\n    return outputFunc(ast, nestedReactOutput, state)\n  }\n}\n\nfunction sanitizeUrl(url: string): string | null {\n  try {\n    const decoded = decodeURIComponent(url).replace(/[^A-Za-z0-9/:]/g, '')\n\n    if (decoded.match(/^\\s*(javascript|vbscript|data(?!:image)):/i)) {\n      if (process.env.NODE_ENV !== 'production') {\n        console.warn(\n          'Anchor URL contains an unsafe JavaScript/VBScript/data expression, it will not be rendered.',\n          decoded\n        )\n      }\n\n      return null\n    }\n  } catch (e) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.warn(\n        'Anchor URL could not be decoded due to malformed syntax or characters, it will not be rendered.',\n        url\n      )\n    }\n\n    // decodeURIComponent sometimes throws a URIError\n    // See `decodeURIComponent('a%AFc');`\n    // http://stackoverflow.com/questions/9064536/javascript-decodeuricomponent-malformed-uri-exception\n    return null\n  }\n\n  return url\n}\n\nfunction unescapeUrl(rawUrlString: string): string {\n  return rawUrlString.replace(UNESCAPE_URL_R, '$1')\n}\n\n/**\n * Everything inline, including links.\n */\nfunction parseInline(\n  parse: MarkdownToJSX.NestedParser,\n  content: string,\n  state: MarkdownToJSX.State\n): MarkdownToJSX.ParserResult {\n  const isCurrentlyInline = state._inline || false\n  const isCurrentlySimple = state._simple || false\n  state._inline = true\n  state._simple = true\n  const result = parse(content, state)\n  state._inline = isCurrentlyInline\n  state._simple = isCurrentlySimple\n  return result\n}\n\n/**\n * Anything inline that isn't a link.\n */\nfunction parseSimpleInline(\n  parse: MarkdownToJSX.NestedParser,\n  content: string,\n  state: MarkdownToJSX.State\n): MarkdownToJSX.ParserResult {\n  const isCurrentlyInline = state._inline || false\n  const isCurrentlySimple = state._simple || false\n  state._inline = false\n  state._simple = true\n  const result = parse(content, state)\n  state._inline = isCurrentlyInline\n  state._simple = isCurrentlySimple\n  return result\n}\n\nfunction parseBlock(\n  parse,\n  content,\n  state: MarkdownToJSX.State\n): MarkdownToJSX.ParserResult {\n  state._inline = false\n  return parse(content + '\\n\\n', state)\n}\n\nconst parseCaptureInline: MarkdownToJSX.Parser<\n  ReturnType<typeof parseInline>\n> = (capture, parse, state: MarkdownToJSX.State) => {\n  return {\n    _content: parseInline(parse, capture[1], state),\n  }\n}\n\nfunction captureNothing() {\n  return {}\n}\n\nfunction renderNothing() {\n  return null\n}\n\nfunction ruleOutput(rules: MarkdownToJSX.Rules) {\n  return function nestedRuleOutput(\n    ast: MarkdownToJSX.ParserResult,\n    outputFunc: MarkdownToJSX.RuleOutput,\n    state: MarkdownToJSX.State\n  ): React.ReactChild {\n    return rules[ast.type]._react(ast, outputFunc, state)\n  }\n}\n\nfunction cx(...args) {\n  return args.filter(Boolean).join(' ')\n}\n\nfunction get(src: Object, path: string, fb?: any) {\n  let ptr = src\n  const frags = path.split('.')\n\n  while (frags.length) {\n    ptr = ptr[frags[0]]\n\n    if (ptr === undefined) break\n    else frags.shift()\n  }\n\n  return ptr || fb\n}\n\nfunction getTag(tag: string, overrides: MarkdownToJSX.Overrides) {\n  const override = get(overrides, tag)\n\n  if (!override) return tag\n\n  return typeof override === 'function' ||\n    (typeof override === 'object' && 'render' in override)\n    ? override\n    : get(overrides, `${tag}.component`, tag)\n}\n\nenum Priority {\n  /**\n   * anything that must scan the tree before everything else\n   */\n  MAX,\n  /**\n   * scans for block-level constructs\n   */\n  HIGH,\n  /**\n   * inline w/ more priority than other inline\n   */\n  MED,\n  /**\n   * inline elements\n   */\n  LOW,\n  /**\n   * bare text and stuff that is considered leftovers\n   */\n  MIN,\n}\n\nexport function compiler(\n  markdown: string,\n  options: MarkdownToJSX.Options = {}\n) {\n  options.overrides = options.overrides || {}\n  options.slugify = options.slugify || slugify\n  options.namedCodesToUnicode = options.namedCodesToUnicode\n    ? { ...namedCodesToUnicode, ...options.namedCodesToUnicode }\n    : namedCodesToUnicode\n\n  const createElementFn = options.createElement || React.createElement\n\n  // JSX custom pragma\n  // eslint-disable-next-line no-unused-vars\n  function h(\n    // locally we always will render a known string tag\n    tag: MarkdownToJSX.HTMLTags,\n    props: Parameters<MarkdownToJSX.CreateElement>[1] & {\n      className?: string\n      id?: string\n    },\n    ...children\n  ) {\n    const overrideProps = get(options.overrides, `${tag}.props`, {})\n\n    return createElementFn(\n      getTag(tag, options.overrides),\n      {\n        ...props,\n        ...overrideProps,\n        className: cx(props?.className, overrideProps.className) || undefined,\n      },\n      ...children\n    )\n  }\n\n  function compile(input: string): JSX.Element {\n    let _inline = false\n\n    if (options.forceInline) {\n      _inline = true\n    } else if (!options.forceBlock) {\n      /**\n       * should not contain any block-level markdown like newlines, lists, headings,\n       * thematic breaks, blockquotes, tables, etc\n       */\n      _inline = SHOULD_RENDER_AS_BLOCK_R.test(input) === false\n    }\n\n    const arr = emitter(\n      parser(\n        _inline\n          ? input\n          : `${input.trimEnd().replace(TRIM_STARTING_NEWLINES, '')}\\n\\n`,\n        {\n          _inline,\n        }\n      )\n    )\n\n    while (\n      typeof arr[arr.length - 1] === 'string' &&\n      !arr[arr.length - 1].trim()\n    ) {\n      arr.pop()\n    }\n\n    if (options.wrapper === null) {\n      return arr\n    }\n\n    const wrapper = options.wrapper || (_inline ? 'span' : 'div')\n    let jsx\n\n    if (arr.length > 1 || options.forceWrapper) {\n      jsx = arr\n    } else if (arr.length === 1) {\n      jsx = arr[0]\n\n      // TODO: remove this for React 16\n      if (typeof jsx === 'string') {\n        return <span key=\"outer\">{jsx}</span>\n      } else {\n        return jsx\n      }\n    } else {\n      // TODO: return null for React 16\n      jsx = null\n    }\n\n    return React.createElement(wrapper, { key: 'outer' }, jsx)\n  }\n\n  function attrStringToMap(str: string): JSX.IntrinsicAttributes {\n    const attributes = str.match(ATTR_EXTRACTOR_R)\n    if (!attributes) {\n      return null\n    }\n\n    return attributes.reduce(function (map, raw, index) {\n      const delimiterIdx = raw.indexOf('=')\n\n      if (delimiterIdx !== -1) {\n        const key = normalizeAttributeKey(raw.slice(0, delimiterIdx)).trim()\n        const value = unquote(raw.slice(delimiterIdx + 1).trim())\n\n        const mappedKey = ATTRIBUTE_TO_JSX_PROP_MAP[key] || key\n        const normalizedValue = (map[mappedKey] = attributeValueToJSXPropValue(\n          key,\n          value\n        ))\n\n        if (\n          typeof normalizedValue === 'string' &&\n          (HTML_BLOCK_ELEMENT_R.test(normalizedValue) ||\n            HTML_SELF_CLOSING_ELEMENT_R.test(normalizedValue))\n        ) {\n          map[mappedKey] = React.cloneElement(compile(normalizedValue.trim()), {\n            key: index,\n          })\n        }\n      } else if (raw !== 'style') {\n        map[ATTRIBUTE_TO_JSX_PROP_MAP[raw] || raw] = true\n      }\n\n      return map\n    }, {})\n  }\n\n  /* istanbul ignore next */\n  if (process.env.NODE_ENV !== 'production') {\n    if (typeof markdown !== 'string') {\n      throw new Error(`markdown-to-jsx: the first argument must be\n                             a string`)\n    }\n\n    if (\n      Object.prototype.toString.call(options.overrides) !== '[object Object]'\n    ) {\n      throw new Error(`markdown-to-jsx: options.overrides (second argument property) must be\n                             undefined or an object literal with shape:\n                             {\n                                htmltagname: {\n                                    component: string|ReactComponent(optional),\n                                    props: object(optional)\n                                }\n                             }`)\n    }\n  }\n\n  const footnotes: { _footnote: string; _identifier: string }[] = []\n  const refs: { [key: string]: { _target: string; _title: string } } = {}\n\n  /**\n   * each rule's react() output function goes through our custom h() JSX pragma;\n   * this allows the override functionality to be automatically applied\n   */\n  const rules: MarkdownToJSX.Rules = {\n    blockQuote: {\n      _match: blockRegex(BLOCKQUOTE_R),\n      _order: Priority.HIGH,\n      _parse(capture, parse, state) {\n        return {\n          _content: parse(\n            capture[0].replace(BLOCKQUOTE_TRIM_LEFT_MULTILINE_R, ''),\n            state\n          ),\n        }\n      },\n      _react(node, output, state) {\n        return (\n          <blockquote key={state._key}>\n            {output(node._content, state)}\n          </blockquote>\n        )\n      },\n    } as MarkdownToJSX.Rule<{ _content: MarkdownToJSX.ParserResult }>,\n\n    breakLine: {\n      _match: anyScopeRegex(BREAK_LINE_R),\n      _order: Priority.HIGH,\n      _parse: captureNothing,\n      _react(_, __, state) {\n        return <br key={state._key} />\n      },\n    },\n\n    breakThematic: {\n      _match: blockRegex(BREAK_THEMATIC_R),\n      _order: Priority.HIGH,\n      _parse: captureNothing,\n      _react(_, __, state) {\n        return <hr key={state._key} />\n      },\n    },\n\n    codeBlock: {\n      _match: blockRegex(CODE_BLOCK_R),\n      _order: Priority.MAX,\n      _parse(capture /*, parse, state*/) {\n        return {\n          _content: capture[0].replace(/^ {4}/gm, '').replace(/\\n+$/, ''),\n          _lang: undefined,\n        }\n      },\n\n      _react(node, output, state) {\n        return (\n          <pre key={state._key}>\n            <code\n              {...node._attrs}\n              className={node._lang ? `lang-${node._lang}` : ''}\n            >\n              {node._content}\n            </code>\n          </pre>\n        )\n      },\n    } as MarkdownToJSX.Rule<{\n      _attrs?: ReturnType<typeof attrStringToMap>\n      _content: string\n      _lang?: string\n    }>,\n\n    codeFenced: {\n      _match: blockRegex(CODE_BLOCK_FENCED_R),\n      _order: Priority.MAX,\n      _parse(capture /*, parse, state*/) {\n        return {\n          // if capture[3] it's additional metadata\n          _attrs: attrStringToMap(capture[3] || ''),\n          _content: capture[4],\n          _lang: capture[2] || undefined,\n          type: 'codeBlock',\n        }\n      },\n    },\n\n    codeInline: {\n      _match: simpleInlineRegex(CODE_INLINE_R),\n      _order: Priority.LOW,\n      _parse(capture /*, parse, state*/) {\n        return {\n          _content: capture[2],\n        }\n      },\n      _react(node, output, state) {\n        return <code key={state._key}>{node._content}</code>\n      },\n    } as MarkdownToJSX.Rule<{ _content: string }>,\n\n    /**\n     * footnotes are emitted at the end of compilation in a special <footer> block\n     */\n    footnote: {\n      _match: blockRegex(FOOTNOTE_R),\n      _order: Priority.MAX,\n      _parse(capture /*, parse, state*/) {\n        footnotes.push({\n          _footnote: capture[2],\n          _identifier: capture[1],\n        })\n\n        return {}\n      },\n      _react: renderNothing,\n    },\n\n    footnoteReference: {\n      _match: inlineRegex(FOOTNOTE_REFERENCE_R),\n      _order: Priority.HIGH,\n      _parse(capture /*, parse*/) {\n        return {\n          _content: capture[1],\n          _target: `#${options.slugify(capture[1])}`,\n        }\n      },\n      _react(node, output, state) {\n        return (\n          <a key={state._key} href={sanitizeUrl(node._target)}>\n            <sup key={state._key}>{node._content}</sup>\n          </a>\n        )\n      },\n    } as MarkdownToJSX.Rule<{ _content: string; _target: string }>,\n\n    gfmTask: {\n      _match: inlineRegex(GFM_TASK_R),\n      _order: Priority.HIGH,\n      _parse(capture /*, parse, state*/) {\n        return {\n          _completed: capture[1].toLowerCase() === 'x',\n        }\n      },\n      _react(node, output, state) {\n        return (\n          <input\n            checked={node._completed}\n            key={state._key}\n            readOnly\n            type=\"checkbox\"\n          />\n        )\n      },\n    } as MarkdownToJSX.Rule<{ _completed: boolean }>,\n\n    heading: {\n      _match: blockRegex(HEADING_R),\n      _order: Priority.HIGH,\n      _parse(capture, parse, state) {\n        return {\n          _content: parseInline(parse, capture[2], state),\n          _id: options.slugify(capture[2]),\n          _level: capture[1].length,\n        }\n      },\n      _react(node, output, state) {\n        return h(\n          `h${node._level}`,\n          { id: node._id, key: state._key },\n          output(node._content, state)\n        )\n      },\n    } as MarkdownToJSX.Rule<{\n      _content: MarkdownToJSX.ParserResult\n      _id: string\n      _level: 1 | 2 | 3 | 4 | 5 | 6\n      _tag: MarkdownToJSX.HTMLTags\n    }>,\n\n    headingSetext: {\n      _match: blockRegex(HEADING_SETEXT_R),\n      _order: Priority.MAX,\n      _parse(capture, parse, state) {\n        return {\n          _content: parseInline(parse, capture[1], state),\n          _level: capture[2] === '=' ? 1 : 2,\n          type: 'heading',\n        }\n      },\n    },\n\n    htmlComment: {\n      _match: anyScopeRegex(HTML_COMMENT_R),\n      _order: Priority.HIGH,\n      _parse() {\n        return {}\n      },\n      _react: renderNothing,\n    },\n\n    image: {\n      _match: simpleInlineRegex(IMAGE_R),\n      _order: Priority.HIGH,\n      _parse(capture /*, parse, state*/) {\n        return {\n          _alt: capture[1],\n          _target: unescapeUrl(capture[2]),\n          _title: capture[3],\n        }\n      },\n      _react(node, output, state) {\n        return (\n          <img\n            key={state._key}\n            alt={node._alt || undefined}\n            title={node._title || undefined}\n            src={sanitizeUrl(node._target)}\n          />\n        )\n      },\n    } as MarkdownToJSX.Rule<{\n      _alt?: string\n      _target: string\n      _title?: string\n    }>,\n\n    link: {\n      _match: inlineRegex(LINK_R),\n      _order: Priority.LOW,\n      _parse(capture, parse, state) {\n        return {\n          _content: parseSimpleInline(parse, capture[1], state),\n          _target: unescapeUrl(capture[2]),\n          _title: capture[3],\n        }\n      },\n      _react(node, output, state) {\n        return (\n          <a\n            key={state._key}\n            href={sanitizeUrl(node._target)}\n            title={node._title}\n          >\n            {output(node._content, state)}\n          </a>\n        )\n      },\n    } as MarkdownToJSX.Rule<{\n      _content: MarkdownToJSX.ParserResult\n      _target: string\n      _title?: string\n    }>,\n\n    // https://daringfireball.net/projects/markdown/syntax#autolink\n    linkAngleBraceStyleDetector: {\n      _match: inlineRegex(LINK_AUTOLINK_R),\n      _order: Priority.MAX,\n      _parse(capture /*, parse, state*/) {\n        return {\n          _content: [\n            {\n              _content: capture[1],\n              type: 'text',\n            },\n          ],\n          _target: capture[1],\n          type: 'link',\n        }\n      },\n    },\n\n    linkBareUrlDetector: {\n      _match: (source, state) => {\n        if (state._inAnchor) {\n          return null\n        }\n        return inlineRegex(LINK_AUTOLINK_BARE_URL_R)(source, state)\n      },\n      _order: Priority.MAX,\n      _parse(capture /*, parse, state*/) {\n        return {\n          _content: [\n            {\n              _content: capture[1],\n              type: 'text',\n            },\n          ],\n          _target: capture[1],\n          _title: undefined,\n          type: 'link',\n        }\n      },\n    },\n\n    linkMailtoDetector: {\n      _match: inlineRegex(LINK_AUTOLINK_MAILTO_R),\n      _order: Priority.MAX,\n      _parse(capture /*, parse, state*/) {\n        let address = capture[1]\n        let target = capture[1]\n\n        // Check for a `mailto:` already existing in the link:\n        if (!AUTOLINK_MAILTO_CHECK_R.test(target)) {\n          target = 'mailto:' + target\n        }\n\n        return {\n          _content: [\n            {\n              _content: address.replace('mailto:', ''),\n              type: 'text',\n            },\n          ],\n          _target: target,\n          type: 'link',\n        }\n      },\n    },\n\n    orderedList: generateListRule(h, ORDERED),\n    unorderedList: generateListRule(h, UNORDERED),\n\n    newlineCoalescer: {\n      _match: blockRegex(CONSECUTIVE_NEWLINE_R),\n      _order: Priority.LOW,\n      _parse: captureNothing,\n      _react(/*node, output, state*/) {\n        return '\\n'\n      },\n    },\n\n    paragraph: {\n      _match: matchParagraph,\n      _order: Priority.LOW,\n      _parse: parseCaptureInline,\n      _react(node, output, state) {\n        return <p key={state._key}>{output(node._content, state)}</p>\n      },\n    } as MarkdownToJSX.Rule<ReturnType<typeof parseCaptureInline>>,\n\n    ref: {\n      _match: inlineRegex(REFERENCE_IMAGE_OR_LINK),\n      _order: Priority.MAX,\n      _parse(capture /*, parse*/) {\n        refs[capture[1]] = {\n          _target: capture[2],\n          _title: capture[4],\n        }\n\n        return {}\n      },\n      _react: renderNothing,\n    },\n\n    refImage: {\n      _match: simpleInlineRegex(REFERENCE_IMAGE_R),\n      _order: Priority.MAX,\n      _parse(capture) {\n        return {\n          _alt: capture[1] || undefined,\n          _ref: capture[2],\n        }\n      },\n      _react(node, output, state) {\n        return (\n          <img\n            key={state._key}\n            alt={node._alt}\n            src={sanitizeUrl(refs[node._ref]._target)}\n            title={refs[node._ref]._title}\n          />\n        )\n      },\n    } as MarkdownToJSX.Rule<{ _alt?: string; _ref: string }>,\n\n    refLink: {\n      _match: inlineRegex(REFERENCE_LINK_R),\n      _order: Priority.MAX,\n      _parse(capture, parse, state) {\n        return {\n          _content: parse(capture[1], state),\n          _fallbackContent: parse(\n            capture[0].replace(SQUARE_BRACKETS_R, '\\\\$1'),\n            state\n          ),\n          _ref: capture[2],\n        }\n      },\n      _react(node, output, state) {\n        return refs[node._ref] ? (\n          <a\n            key={state._key}\n            href={sanitizeUrl(refs[node._ref]._target)}\n            title={refs[node._ref]._title}\n          >\n            {output(node._content, state)}\n          </a>\n        ) : (\n          <span key={state._key}>{output(node._fallbackContent, state)}</span>\n        )\n      },\n    } as MarkdownToJSX.Rule<{\n      _content: MarkdownToJSX.ParserResult\n      _fallbackContent: MarkdownToJSX.ParserResult\n      _ref: string\n    }>,\n\n    table: {\n      _match: blockRegex(NP_TABLE_R),\n      _order: Priority.HIGH,\n      _parse: parseTable,\n      _react(node, output, state) {\n        return (\n          <table key={state._key}>\n            <thead>\n              <tr>\n                {node._header.map(function generateHeaderCell(content, i) {\n                  return (\n                    <th key={i} style={getTableStyle(node, i)}>\n                      {output(content, state)}\n                    </th>\n                  )\n                })}\n              </tr>\n            </thead>\n\n            <tbody>\n              {node._cells.map(function generateTableRow(row, i) {\n                return (\n                  <tr key={i}>\n                    {row.map(function generateTableCell(content, c) {\n                      return (\n                        <td key={c} style={getTableStyle(node, c)}>\n                          {output(content, state)}\n                        </td>\n                      )\n                    })}\n                  </tr>\n                )\n              })}\n            </tbody>\n          </table>\n        )\n      },\n    } as MarkdownToJSX.Rule<ReturnType<typeof parseTable>>,\n\n    tableSeparator: {\n      _match: function (source, state) {\n        if (!state._inTable) {\n          return null\n        }\n        return TABLE_SEPARATOR_R.exec(source)\n      },\n      _order: Priority.HIGH,\n      _parse: function () {\n        return { type: 'tableSeparator' }\n      },\n      // These shouldn't be reached, but in case they are, be reasonable:\n      _react() {\n        return ' | '\n      },\n    },\n\n    text: {\n      // Here we look for anything followed by non-symbols,\n      // double newlines, or double-space-newlines\n      // We break on any symbol characters so that this grammar\n      // is easy to extend without needing to modify this regex\n      _match: anyScopeRegex(TEXT_PLAIN_R),\n      _order: Priority.MIN,\n      _parse(capture /*, parse, state*/) {\n        return {\n          _content: capture[0]\n            // nbsp -> unicode equivalent for named chars\n            .replace(HTML_CHAR_CODE_R, (full, inner) => {\n              return options.namedCodesToUnicode[inner]\n                ? options.namedCodesToUnicode[inner]\n                : full\n            }),\n        }\n      },\n      _react(node /*, output, state*/) {\n        return node._content\n      },\n    } as MarkdownToJSX.Rule<{ _content: string }>,\n\n    textBolded: {\n      _match: simpleInlineRegex(TEXT_BOLD_R),\n      _order: Priority.MED,\n      _parse(capture, parse, state) {\n        return {\n          // capture[1] -> the syntax control character\n          // capture[2] -> inner content\n          _content: parse(capture[2], state),\n        }\n      },\n      _react(node, output, state) {\n        return <strong key={state._key}>{output(node._content, state)}</strong>\n      },\n    } as MarkdownToJSX.Rule<ReturnType<MarkdownToJSX.NestedParser>>,\n\n    textEmphasized: {\n      _match: simpleInlineRegex(TEXT_EMPHASIZED_R),\n      _order: Priority.LOW,\n      _parse(capture, parse, state) {\n        return {\n          // capture[1] -> opening * or _\n          // capture[2] -> inner content\n          _content: parse(capture[2], state),\n        }\n      },\n      _react(node, output, state) {\n        return <em key={state._key}>{output(node._content, state)}</em>\n      },\n    } as MarkdownToJSX.Rule<ReturnType<MarkdownToJSX.NestedParser>>,\n\n    textEscaped: {\n      // We don't allow escaping numbers, letters, or spaces here so that\n      // backslashes used in plain text still get rendered. But allowing\n      // escaping anything else provides a very flexible escape mechanism,\n      // regardless of how this grammar is extended.\n      _match: simpleInlineRegex(TEXT_ESCAPED_R),\n      _order: Priority.HIGH,\n      _parse(capture /*, parse, state*/) {\n        return {\n          _content: capture[1],\n          type: 'text',\n        }\n      },\n    },\n\n    textMarked: {\n      _match: simpleInlineRegex(TEXT_MARKED_R),\n      _order: Priority.LOW,\n      _parse: parseCaptureInline,\n      _react(node, output, state) {\n        return <mark key={state._key}>{output(node._content, state)}</mark>\n      },\n    } as MarkdownToJSX.Rule<ReturnType<typeof parseCaptureInline>>,\n\n    textStrikethroughed: {\n      _match: simpleInlineRegex(TEXT_STRIKETHROUGHED_R),\n      _order: Priority.LOW,\n      _parse: parseCaptureInline,\n      _react(node, output, state) {\n        return <del key={state._key}>{output(node._content, state)}</del>\n      },\n    } as MarkdownToJSX.Rule<ReturnType<typeof parseCaptureInline>>,\n  }\n\n  // Object.keys(rules).forEach(key => {\n  //   let { _match: match, _parse: parse } = rules[key]\n\n  //   rules[key]._match = (...args) => {\n  //     const start = performance.now()\n  //     const result = match(...args)\n  //     const delta = performance.now() - start\n\n  //     if (delta > 5)\n  //       console.warn(\n  //         `Slow match for ${key}: ${delta.toFixed(3)}ms, input: ${args[0]}`\n  //       )\n\n  //     return result\n  //   }\n\n  //   rules[key]._parse = (...args) => {\n  //     const start = performance.now()\n  //     const result = parse(...args)\n  //     const delta = performance.now() - start\n\n  //     if (delta > 5)\n  //       console.warn(`Slow parse for ${key}: ${delta.toFixed(3)}ms`)\n\n  //     console.log(`${key}:parse`, `${delta.toFixed(3)}ms`, args[0])\n\n  //     return result\n  //   }\n  // })\n\n  if (options.disableParsingRawHTML !== true) {\n    rules.htmlBlock = {\n      /**\n       * find the first matching end tag and process the interior\n       */\n      _match: anyScopeRegex(HTML_BLOCK_ELEMENT_R),\n      _order: Priority.HIGH,\n      _parse(capture, parse, state) {\n        const [, whitespace] = capture[3].match(HTML_LEFT_TRIM_AMOUNT_R)\n        const trimmer = new RegExp(`^${whitespace}`, 'gm')\n        const trimmed = capture[3].replace(trimmer, '')\n\n        const parseFunc = containsBlockSyntax(trimmed)\n          ? parseBlock\n          : parseInline\n\n        const tagName = capture[1].toLowerCase() as MarkdownToJSX.HTMLTags\n        const noInnerParse =\n          DO_NOT_PROCESS_HTML_ELEMENTS.indexOf(tagName) !== -1\n\n        state._inAnchor = state._inAnchor || tagName === 'a'\n\n        /**\n         * if another html block is detected within, parse as block,\n         * otherwise parse as inline to pick up any further markdown\n         */\n        const content = noInnerParse\n          ? capture[3]\n          : parseFunc(parse, trimmed, state)\n\n        state._inAnchor = false\n\n        return {\n          _attrs: attrStringToMap(capture[2]),\n          _content: content,\n          _noInnerParse: noInnerParse,\n          _tag: noInnerParse ? tagName : capture[1],\n        }\n      },\n      _react(node, output, state) {\n        return (\n          // @ts-ignore\n          <node._tag key={state._key} {...node._attrs}>\n            {node._noInnerParse\n              ? (node._content as string)\n              : output(node._content as MarkdownToJSX.ParserResult, state)}\n          </node._tag>\n        )\n      },\n    } as MarkdownToJSX.Rule<{\n      _attrs: ReturnType<typeof attrStringToMap>\n      _content: string | ReturnType<MarkdownToJSX.NestedParser>\n      _noInnerParse: Boolean\n      _tag: string\n    }>\n\n    rules.htmlSelfClosing = {\n      /**\n       * find the first matching end tag and process the interior\n       */\n      _match: anyScopeRegex(HTML_SELF_CLOSING_ELEMENT_R),\n      _order: Priority.HIGH,\n      _parse(capture /*, parse, state*/) {\n        return {\n          _attrs: attrStringToMap(capture[2] || ''),\n          _tag: capture[1],\n        }\n      },\n      _react(node, output, state) {\n        return <node._tag {...node._attrs} key={state._key} />\n      },\n    } as MarkdownToJSX.Rule<{\n      _attrs: ReturnType<typeof attrStringToMap>\n      _tag: string\n    }>\n  }\n\n  const parser = parserFor(rules)\n  const emitter: Function = reactFor(ruleOutput(rules))\n\n  const jsx = compile(markdown)\n\n  if (footnotes.length) {\n    return (\n      <div>\n        {jsx}\n        <footer key=\"footer\">\n          {footnotes.map(function createFootnote(def) {\n            return (\n              <div id={options.slugify(def._identifier)} key={def._identifier}>\n                {def._identifier}\n                {emitter(parser(def._footnote, { _inline: true }))}\n              </div>\n            )\n          })}\n        </footer>\n      </div>\n    )\n  }\n\n  return jsx\n}\n\n/**\n * A simple HOC for easy React use. Feed the markdown content as a direct child\n * and the rest is taken care of automatically.\n */\nconst Markdown: React.FC<{\n  [key: string]: any\n  children: string\n  options?: MarkdownToJSX.Options\n}> = ({ children, options, ...props }) => {\n  return React.cloneElement(\n    compiler(children, options),\n    props as JSX.IntrinsicAttributes\n  )\n}\n\nexport default Markdown\n"]},"metadata":{},"sourceType":"module"}