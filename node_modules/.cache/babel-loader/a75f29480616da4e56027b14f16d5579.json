{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;\n\nconst codegen_1 = require(\"./codegen\");\n\nconst code_1 = require(\"./codegen/code\"); // TODO refactor to use Set\n\n\nfunction toHash(arr) {\n  const hash = {};\n\n  for (const item of arr) hash[item] = true;\n\n  return hash;\n}\n\nexports.toHash = toHash;\n\nfunction alwaysValidSchema(it, schema) {\n  if (typeof schema == \"boolean\") return schema;\n  if (Object.keys(schema).length === 0) return true;\n  checkUnknownRules(it, schema);\n  return !schemaHasRules(schema, it.self.RULES.all);\n}\n\nexports.alwaysValidSchema = alwaysValidSchema;\n\nfunction checkUnknownRules(it) {\n  let schema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : it.schema;\n  const {\n    opts,\n    self\n  } = it;\n  if (!opts.strictSchema) return;\n  if (typeof schema === \"boolean\") return;\n  const rules = self.RULES.keywords;\n\n  for (const key in schema) {\n    if (!rules[key]) checkStrictMode(it, `unknown keyword: \"${key}\"`);\n  }\n}\n\nexports.checkUnknownRules = checkUnknownRules;\n\nfunction schemaHasRules(schema, rules) {\n  if (typeof schema == \"boolean\") return !schema;\n\n  for (const key in schema) if (rules[key]) return true;\n\n  return false;\n}\n\nexports.schemaHasRules = schemaHasRules;\n\nfunction schemaHasRulesButRef(schema, RULES) {\n  if (typeof schema == \"boolean\") return !schema;\n\n  for (const key in schema) if (key !== \"$ref\" && RULES.all[key]) return true;\n\n  return false;\n}\n\nexports.schemaHasRulesButRef = schemaHasRulesButRef;\n\nfunction schemaRefOrVal(_ref, schema, keyword, $data) {\n  let {\n    topSchemaRef,\n    schemaPath\n  } = _ref;\n\n  if (!$data) {\n    if (typeof schema == \"number\" || typeof schema == \"boolean\") return schema;\n    if (typeof schema == \"string\") return (0, codegen_1._)`${schema}`;\n  }\n\n  return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;\n}\n\nexports.schemaRefOrVal = schemaRefOrVal;\n\nfunction unescapeFragment(str) {\n  return unescapeJsonPointer(decodeURIComponent(str));\n}\n\nexports.unescapeFragment = unescapeFragment;\n\nfunction escapeFragment(str) {\n  return encodeURIComponent(escapeJsonPointer(str));\n}\n\nexports.escapeFragment = escapeFragment;\n\nfunction escapeJsonPointer(str) {\n  if (typeof str == \"number\") return `${str}`;\n  return str.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n}\n\nexports.escapeJsonPointer = escapeJsonPointer;\n\nfunction unescapeJsonPointer(str) {\n  return str.replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n}\n\nexports.unescapeJsonPointer = unescapeJsonPointer;\n\nfunction eachItem(xs, f) {\n  if (Array.isArray(xs)) {\n    for (const x of xs) f(x);\n  } else {\n    f(xs);\n  }\n}\n\nexports.eachItem = eachItem;\n\nfunction makeMergeEvaluated(_ref2) {\n  let {\n    mergeNames,\n    mergeToName,\n    mergeValues,\n    resultToName\n  } = _ref2;\n  return (gen, from, to, toName) => {\n    const res = to === undefined ? from : to instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1.Name ? (mergeToName(gen, to, from), from) : mergeValues(from, to);\n    return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;\n  };\n}\n\nexports.mergeEvaluated = {\n  props: makeMergeEvaluated({\n    mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => {\n      gen.if((0, codegen_1._)`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._)`${to} || {}`).code((0, codegen_1._)`Object.assign(${to}, ${from})`));\n    }),\n    mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => {\n      if (from === true) {\n        gen.assign(to, true);\n      } else {\n        gen.assign(to, (0, codegen_1._)`${to} || {}`);\n        setEvaluated(gen, to, from);\n      }\n    }),\n    mergeValues: (from, to) => from === true ? true : { ...from,\n      ...to\n    },\n    resultToName: evaluatedPropsToName\n  }),\n  items: makeMergeEvaluated({\n    mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),\n    mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._)`${to} > ${from} ? ${to} : ${from}`)),\n    mergeValues: (from, to) => from === true ? true : Math.max(from, to),\n    resultToName: (gen, items) => gen.var(\"items\", items)\n  })\n};\n\nfunction evaluatedPropsToName(gen, ps) {\n  if (ps === true) return gen.var(\"props\", true);\n  const props = gen.var(\"props\", (0, codegen_1._)`{}`);\n  if (ps !== undefined) setEvaluated(gen, props, ps);\n  return props;\n}\n\nexports.evaluatedPropsToName = evaluatedPropsToName;\n\nfunction setEvaluated(gen, props, ps) {\n  Object.keys(ps).forEach(p => gen.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p)}`, true));\n}\n\nexports.setEvaluated = setEvaluated;\nconst snippets = {};\n\nfunction useFunc(gen, f) {\n  return gen.scopeValue(\"func\", {\n    ref: f,\n    code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code))\n  });\n}\n\nexports.useFunc = useFunc;\nvar Type;\n\n(function (Type) {\n  Type[Type[\"Num\"] = 0] = \"Num\";\n  Type[Type[\"Str\"] = 1] = \"Str\";\n})(Type = exports.Type || (exports.Type = {}));\n\nfunction getErrorPath(dataProp, dataPropType, jsPropertySyntax) {\n  // let path\n  if (dataProp instanceof codegen_1.Name) {\n    const isNumber = dataPropType === Type.Num;\n    return jsPropertySyntax ? isNumber ? (0, codegen_1._)`\"[\" + ${dataProp} + \"]\"` : (0, codegen_1._)`\"['\" + ${dataProp} + \"']\"` : isNumber ? (0, codegen_1._)`\"/\" + ${dataProp}` : (0, codegen_1._)`\"/\" + ${dataProp}.replace(/~/g, \"~0\").replace(/\\\\//g, \"~1\")`; // TODO maybe use global escapePointer\n  }\n\n  return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : \"/\" + escapeJsonPointer(dataProp);\n}\n\nexports.getErrorPath = getErrorPath;\n\nfunction checkStrictMode(it, msg) {\n  let mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : it.opts.strictSchema;\n  if (!mode) return;\n  msg = `strict mode: ${msg}`;\n  if (mode === true) throw new Error(msg);\n  it.self.logger.warn(msg);\n}\n\nexports.checkStrictMode = checkStrictMode;","map":{"version":3,"sources":["../../lib/compile/util.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;\nconst codegen_1 = require(\"./codegen\");\nconst code_1 = require(\"./codegen/code\");\n// TODO refactor to use Set\nfunction toHash(arr) {\n    const hash = {};\n    for (const item of arr)\n        hash[item] = true;\n    return hash;\n}\nexports.toHash = toHash;\nfunction alwaysValidSchema(it, schema) {\n    if (typeof schema == \"boolean\")\n        return schema;\n    if (Object.keys(schema).length === 0)\n        return true;\n    checkUnknownRules(it, schema);\n    return !schemaHasRules(schema, it.self.RULES.all);\n}\nexports.alwaysValidSchema = alwaysValidSchema;\nfunction checkUnknownRules(it, schema = it.schema) {\n    const { opts, self } = it;\n    if (!opts.strictSchema)\n        return;\n    if (typeof schema === \"boolean\")\n        return;\n    const rules = self.RULES.keywords;\n    for (const key in schema) {\n        if (!rules[key])\n            checkStrictMode(it, `unknown keyword: \"${key}\"`);\n    }\n}\nexports.checkUnknownRules = checkUnknownRules;\nfunction schemaHasRules(schema, rules) {\n    if (typeof schema == \"boolean\")\n        return !schema;\n    for (const key in schema)\n        if (rules[key])\n            return true;\n    return false;\n}\nexports.schemaHasRules = schemaHasRules;\nfunction schemaHasRulesButRef(schema, RULES) {\n    if (typeof schema == \"boolean\")\n        return !schema;\n    for (const key in schema)\n        if (key !== \"$ref\" && RULES.all[key])\n            return true;\n    return false;\n}\nexports.schemaHasRulesButRef = schemaHasRulesButRef;\nfunction schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {\n    if (!$data) {\n        if (typeof schema == \"number\" || typeof schema == \"boolean\")\n            return schema;\n        if (typeof schema == \"string\")\n            return (0, codegen_1._) `${schema}`;\n    }\n    return (0, codegen_1._) `${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;\n}\nexports.schemaRefOrVal = schemaRefOrVal;\nfunction unescapeFragment(str) {\n    return unescapeJsonPointer(decodeURIComponent(str));\n}\nexports.unescapeFragment = unescapeFragment;\nfunction escapeFragment(str) {\n    return encodeURIComponent(escapeJsonPointer(str));\n}\nexports.escapeFragment = escapeFragment;\nfunction escapeJsonPointer(str) {\n    if (typeof str == \"number\")\n        return `${str}`;\n    return str.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n}\nexports.escapeJsonPointer = escapeJsonPointer;\nfunction unescapeJsonPointer(str) {\n    return str.replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n}\nexports.unescapeJsonPointer = unescapeJsonPointer;\nfunction eachItem(xs, f) {\n    if (Array.isArray(xs)) {\n        for (const x of xs)\n            f(x);\n    }\n    else {\n        f(xs);\n    }\n}\nexports.eachItem = eachItem;\nfunction makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName, }) {\n    return (gen, from, to, toName) => {\n        const res = to === undefined\n            ? from\n            : to instanceof codegen_1.Name\n                ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to)\n                : from instanceof codegen_1.Name\n                    ? (mergeToName(gen, to, from), from)\n                    : mergeValues(from, to);\n        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;\n    };\n}\nexports.mergeEvaluated = {\n    props: makeMergeEvaluated({\n        mergeNames: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true && ${from} !== undefined`, () => {\n            gen.if((0, codegen_1._) `${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._) `${to} || {}`).code((0, codegen_1._) `Object.assign(${to}, ${from})`));\n        }),\n        mergeToName: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true`, () => {\n            if (from === true) {\n                gen.assign(to, true);\n            }\n            else {\n                gen.assign(to, (0, codegen_1._) `${to} || {}`);\n                setEvaluated(gen, to, from);\n            }\n        }),\n        mergeValues: (from, to) => (from === true ? true : { ...from, ...to }),\n        resultToName: evaluatedPropsToName,\n    }),\n    items: makeMergeEvaluated({\n        mergeNames: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._) `${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),\n        mergeToName: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._) `${to} > ${from} ? ${to} : ${from}`)),\n        mergeValues: (from, to) => (from === true ? true : Math.max(from, to)),\n        resultToName: (gen, items) => gen.var(\"items\", items),\n    }),\n};\nfunction evaluatedPropsToName(gen, ps) {\n    if (ps === true)\n        return gen.var(\"props\", true);\n    const props = gen.var(\"props\", (0, codegen_1._) `{}`);\n    if (ps !== undefined)\n        setEvaluated(gen, props, ps);\n    return props;\n}\nexports.evaluatedPropsToName = evaluatedPropsToName;\nfunction setEvaluated(gen, props, ps) {\n    Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._) `${props}${(0, codegen_1.getProperty)(p)}`, true));\n}\nexports.setEvaluated = setEvaluated;\nconst snippets = {};\nfunction useFunc(gen, f) {\n    return gen.scopeValue(\"func\", {\n        ref: f,\n        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code)),\n    });\n}\nexports.useFunc = useFunc;\nvar Type;\n(function (Type) {\n    Type[Type[\"Num\"] = 0] = \"Num\";\n    Type[Type[\"Str\"] = 1] = \"Str\";\n})(Type = exports.Type || (exports.Type = {}));\nfunction getErrorPath(dataProp, dataPropType, jsPropertySyntax) {\n    // let path\n    if (dataProp instanceof codegen_1.Name) {\n        const isNumber = dataPropType === Type.Num;\n        return jsPropertySyntax\n            ? isNumber\n                ? (0, codegen_1._) `\"[\" + ${dataProp} + \"]\"`\n                : (0, codegen_1._) `\"['\" + ${dataProp} + \"']\"`\n            : isNumber\n                ? (0, codegen_1._) `\"/\" + ${dataProp}`\n                : (0, codegen_1._) `\"/\" + ${dataProp}.replace(/~/g, \"~0\").replace(/\\\\//g, \"~1\")`; // TODO maybe use global escapePointer\n    }\n    return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : \"/\" + escapeJsonPointer(dataProp);\n}\nexports.getErrorPath = getErrorPath;\nfunction checkStrictMode(it, msg, mode = it.opts.strictSchema) {\n    if (!mode)\n        return;\n    msg = `strict mode: ${msg}`;\n    if (mode === true)\n        throw new Error(msg);\n    it.self.logger.warn(msg);\n}\nexports.checkStrictMode = checkStrictMode;\n//# sourceMappingURL=util.js.map"]},"metadata":{},"sourceType":"script"}